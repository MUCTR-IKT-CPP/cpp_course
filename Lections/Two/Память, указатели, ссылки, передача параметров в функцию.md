# Лекция 2: Память, указатели, ссылки, передача параметров в функцию

### План лекции:

1. Как работает Git
2. Линейное представление памяти. 
3. Указатель в рамках линейного представления памяти
4. Указатель в С++
5. Ссылка в С++
6. Операции взятия и разименования указателя
7. Массив в памяти
8. Арифметика указателей
9. Примеры
10. Void и Void*
11. Два вида памяти
    1.  Статическая
    2.  Динамическая
12. Выделение динамической памяти, оператор new
13. Освобождение памяти, оператор delete
14. Массивы и операторы new и delete
15. Передача по указателю
16. Изменяемый и не изменяемый указатель
17. Передача по ссылке, разница
18. Умные указатели
19. Статические переменные


----------------
### Как работает Git


Первое о чем нам следует поговрить на этой лекции, это принципы и основы работы гита, ведь без понимания какой либо технилогии ее использование в повседневной практике практически невозможно. В качестве помощи для объяснения всего принципа работы рассмотрим следующую илюстрацию:

![Гит](imgs/GitSheme.png)

На ней мы видим 2 процесса, 1 расположен сверху, второй расположен снизу.  
Начнем с верхнего процесса, его можно сравнить с закатыванием консервов. Конечно, это не более чем анология, но она достаточно хорошо илюстрирует все особенности и смыслы производимых манипуляций. Итак, у нас имеется следующие операции:

1. Самой первой операцией является подготовка нашего варева перед закаткой в банку, под этим мы понимаем процесс **написания кода**, создания файлов и папок в нашей рабочей дирректирии проекта, их переименование и прочие операции со всем что находится в корне репозитория(под корнем понимается то место в котором лежит папка с названием .git).
2. Затем, следуют операция перекладывания нашего варева в банку, как бы подготовка ее к закатке, ошпаривание, дезинфекция и прочие операции свойственные подготовки консервы к консервированию. В нашем же случае, и нашей же терминологии эта операция называется **ADD** или добавление кода в индекс репозитория. Под этой операцией подразумевается, что гит берет все наши текущие изменения рабочей директории и делает их слепок, по сути копию, в минимизированном и специально обработанном виде, который позволяем ему в будущем, вернуть наш репозиторий в это же состояние. Изменения, которые прошли через эту операцию подготовки, считаются и называются добавленными в индекс, или staged changes. 
   > После попадания в индекс, даже если в рабочей директории произойдут какие либо изменения, они не будут учитываться без повторения команды ADD, продолжая аналогию, если мы продолжим варить что-то в кастрюле дальше, и добавлять новые ингридиенты, сами по себе они не появятся в банке для консервирования.
3. Последней идет операция консервирования, наша банка уже подготовлена, в ней есть все что мы хотим закрыть в ней, и нам остается только поместить крышку, закатать консерву и подписать банку, что бы не запутаться в будущем, что же мы там наварили. В нашей же терминологии эта операция называется **COMMIT**, а результат всего процесса по аналогии с ней, называется коммитом. Т.е., вспоминая аналогию, коммит = банка. В нем хранятся все наши изменения, которые мы посчитали необходимыми в него записать. 
   > Гит присваивает коммиту уникальное имя, однако это уникальное имя не приспособлено для восприятия и использования человеком и как следствие не подходит для программиста в качестве того, что могло бы подсказать о чем был коммит, поэтому мы и обязаны добавлять к коммиту поясняющее сообщение, условно говоря как будто, наша закатная машинка сама ставит дату закатки, но она абсолютно не представляет что же мы закатали внутрь. 
   > Именно в этот момент, наш комит помещается в цепочку комитов, если продолжить аналогию, помещаются на полку с баками, единственное что полка локальна, однако локальная полка, ее наличие не влияет на объяснения дальнейшего процесса.

По итогу описанного процесса у нас получается банка. Однако, сама по себе эта банка не несет никакой пользы, именно поэтому, нам необходимо поместить эту банку на полку для банок, которая отражена в нижней части илюстрации: 
> отдельно стоит отметить, что помимо удаленной полки, которая отражена в нижней части илюстрации существует аналогичная локальная полка, с которой мы и работаем, а весь процесс описанный далее занимается синхронизацией локальной и удаленной полок, однако, он не является обязательным, и допускается работа только с локальной полкой, таким образом обеспечивается версионность, но не обеспечивается синхронизация и коллективная работа.

Для того что бы это сделать, нам необходимо выполнить операцию **PUSH** которая отправит наш коммит в удаленный репозиторий. Эта операция, если продолжать аналогию, является операцией передачи банки на удаленную полку для длительного хранения, или для того, что бы ее кто то мог взять и использовать.  

В процессе операций с основной удаленной веткой, можно создавать некоторое количество параллельных ей малых веток. Для этого мы берем какой либо комит и от него выполняем операцию **CHECKOUT -b "название ветки"**. 

> Используя введенную ранее аналогию, мы берем одну из закатанных банок, исходя из иллюстрации банку с номером 2, и вскрываем, ее содержимое мы выливаем в кастрюлю для варева, после чего добавляем или удаляем какие либо ингридиенты. По завершению этого процесса мы закатываем новую банку с названием 2.1, а потом еще 2, 2.2 и 2.3. Эти банки идут паралельно основной полке, и не всключают в себя какие либо новые ингридиеты из банок на ней.  

Однако в какой то момент, мы заканчиваем все наши манипуляции c второстепенной веткой и хотим объеденить работу с основной. Для этого нам необходимо выполнить их объединение, в правильной терминологии **MERGE**.
> Продолжая нашу аналогию, результатом такого действия станет объединения содержимого банки 2.3 и банки с основной полки за номером 5. В итоге получиться банка за номером 6, в которую попадет их объединение стоящая на основной полке, и все остальные банки помещаемые на основную полку будут следовать строго за ней, а значит базироваться на ее содержимом, т.е. включать в себя то что было добавлено в процессе работы с паралельной полкой. При этом на паралельную полку, новая банка не попадет, так как операция объединения вызывалась для передачи варева от второстепенной полке к основной.

Важно отметить, что ветка с которой происходит объединения не обязана закрываться и работа с ней не обязана завершаться, т.е. можно продолжать работать с ней и периодически объединять свою работу с основной веткой. В том числе и забирать сделанные изменения из основной ветки, не отдавая свои изменения.

В случае если кто-то, помимо нас решил добавить какие либо изменения(а именно это и предполагается в случае совместной работы над проектом), его изменения так же будет помещенеы в удаленную ветку, и мы можем забрать их себе операцией **PULL**.
> Продолжая нашу аналогию, кто то поставил после наших действий свою банку, сваренную на основании того, что ранее варили мы. Следовательно все, что мы будем делать далее в основной ветке, мы должны делать учитывая эти изменения, и для этого мы возьмем банку и вытащим ее содержимое к себе. При этом, если какое либо содержимое банки будет отличаться от наших локальных изменений, мы обязаны будем сначала закатать новую консерву с этими изменениями, и только после этого объеденить их, иначе на придеться расстаться с нашей незавершенной консервой, но такая ситуация возникает только если мы изменяем те же ингредиенты, что и тот чьи изменения мы у себя учитываем.

На это экскурс в мир гита можно считать законченным, а так же можно предположить, что основная масса читателей поняла принципы работы, ну по крайней мере я на это надеюсь.

----------------
### Линейное представление памяти 

Предметом этой лекции являются указатели и ссылки, а соответсвенно и то, без чего понять эти две сущности в С++ достаточно сложно. Это память. Если быть точным, это представление и понимание памяти которое заложено в С++, и, если говорить чуточку шире, в целом во многие языки программирования и работу операционной системы, так как во многом такое предствание памяти в С++ связано с его достаточно глубокими возможностями по взаимодействию с ней, а значит нужно оперировать максильно приближенными к реальному положению вещей понятиями и идеями.  

На изображении ниже представлено линейное представление памяти.
![Линейная память](imgs/MemoryLine.png)
Как можно заметить вся цепочка, состоит из последовательно следующих друг за другом сегментов, называемых ячейками памяти. Каждая ячейка в линейном представлении памяти имеет свой уникальный адрес, по сути порядковый номер этой ячейки относительно начала. Одна ячейка представляет собой ровно один байт информации.
> можно было бы предположить что будет один бит, однако бит слишком малое с точки зрения значимости значение, плюс, исторически так сложилось, что информация кодируется битами, но храниться пачками по 8 бит, называемых байтами.  

Переменные в рамках линейного представления памяти могут занимать от одной и более ячеек памяти. При этом адрес ячейки памяти для 32 битной системы всегда будет занимать 4 байта, или 32 бита, а для 64 битной системы, 8 байт, или 64 бита, собственно этим они и отличаются друг от друга.

Важно отметить, что линейное представление памяти это не единственный вариант, и более того, в физическом виде память не храниться как последовательность битов, очень часто она может быть двумерной матрицей, однако, в случае программирования на общих языках программирования с ней работают как с единой длинной линией. Это связано с тем, что двумерное представление памяти не является столь универсальным и гибким как линейное, и используется как правило в строго подходящих для этого ситуациях.

----------------
### Переменные в памяти

Итак, как и упоминалось ранее, каждая ячейка в памяти имеет адресс, а перменаня занимает от одной до нескольких ячеек, соотсвенно каждая переменная имеет свой уникальный адресс, который однозначно позволит найти ее внутри нашей линии данных. Так же логично будет отметить, что адрессом переменной будет являться не пара адресов, начальной и конечной ячейки, а лишь один адресс, только начальный. Это связано с тем, что для каждого типа, в том числе и не стандартного можно рассчитать значение занимаемых им в памяти ячеек, а значит для прочтения перменной нам достаточно найти первую ячейку, после чего обработать столько ячеек сколько занимает тот или иной тип.  
На изображении ниже представлена переменная расопложенная в памяти, она начинается с ячейки за номером 4, поэтому будем считать что ее адресс пишется как &Ячейка4.
![Переменная в памяти](imgs/VariableAndReferenseInMemoryLine.png)

Стрелкой с подпись `int n = 10;` указано основное название переменной, это то символьное обозначение которое в нашей программе от его появления и до его очистки, будет ассоциироваться с ячейкой номер 4, т.е. скрывать за собой определенный сегмент памяти и предоставлять к нему доступ.   

----------------
### Ссылка
Второй же стрелкой, так же ведущей к нашей ячейки является ссылка, определяемая строчкой `int& n2 = 2;`. Хорошей аналогией, через которую можно объяснить понятие ссылки, является синоним. Так же, как и в случае синонимов в русском языке, ссылка имеет тот же смысл что и наша изначальная переменная, т.е. предоставление доступа к тому же участку памяти, но имеет другое название, по которому мы можем обращаться к этой памяти. Со ссылкой мы можем проводить абсолютно все то же самое что и обычной переменной, при этом значение которое храниться в этой переменной будет меняться как через ссылку, так и через саму переменную.

#### Ссылка в С++

Для обозначения указателя используется следующие строчки:
```cpp
int& reference_n = origin_n;
float& reference_f = origin_f;
char& reference_c = origin_c;
```
Исходя из этого можно выделить следующую сигнатуру.
```
<тип>& <название ссылки> = <название переменной на которую ссылаются>;
```


----------------
### Указатель

Помимо ссылки, в процессе работы с памятью возникает такое понятие как указатель  
![Указатель](imgs/VariableAndPointerInMemoryLine.png)

В отличии от ссылки, указатель не является простым синонимом для переменной. Указатель является абсолютно отличной переменной, он имеет свою собственную занимаемую память, и хранит свое собственное значение. Весь секрет кроется именно в том, какое значение в себе хранит указатель, этим значением является номер первой ячейки переменной. Таким образом, использую эту значение из переменной указателя, мы можем обратиться непосредственно к памяти которая скрыта за этим номером, и взаимодействовать с ней не имея буквенного названия переменной.

#### Указатель в С++

Как можно заметить в предыдущем изображении объявления указателя происходит следующим образом:

----------------
### Операции взятия и разименования указателя
![](imgs/PointerAndOperations.png)
----------------
### Массив в памяти
![](imgs/ArrayInMemoryLine.png)
![](imgs/MassivePointerArithmetic.png)
----------------
### Арифметика указателей
----------------
### Примеры
----------------
### Void и Void*
![](imgs/Sadness.png)
----------------
### Два вида памяти

#### Статическая

#### Динамическая
----------------
### Выделение динамической памяти, оператор new
----------------
### Освобождение памяти, оператор delete
----------------
### Массивы и операторы new и delete
----------------
### Передача по указателю
----------------
### Изменяемый и не изменяемый указатель
----------------
### Передача по ссылке, разница
----------------
### Умные указатели
----------------
### Статические переменные