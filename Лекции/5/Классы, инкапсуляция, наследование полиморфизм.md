# Лекция 5: Классы, инкапсуляция, наследование полиморфизм.

### План лекции:

1. ООП
2. Три кита
3. Наследование
4. Инкапсуляция
5. Полиморфизм
6. Дружественные функции
7. Перегрузка операторов
8. Перегрузка операторов через дружественные функции
9. Конструктор который нельзя копировать
10. Конструктор который нельзя создать


----------------
### ООП

Как мы уже говорили в предыдущей лекции, объектно ориентированная парадигма оперирует объектами и рассуждает о классах этих объектов, что позволяет при помощи нее успешно решать некоторые задачи ориентированные на процессы реального мира в которых участвует различное количество агентов. Однако, сами по себе классы не дают того о чем написано выше. Они сами по себе в отрыве от того о чем мы будем говорить далее достаточно скудны на функциональность и все то ради чего мы хотим их использовать, хотя и предоставляют большую степень агрегации функций и данных в себе, что разумеется упрощает решение задач.

----------------
### Три кита ООП на черепахе абстракции

Именно поэтому часто ооп пытаются объяснять и раскрывать через так называемое понятие о трех китах или трех слонах, на которых стоит ооп, это **наследование**, **инкапсуляция** и **полиморфизм**, часто прибавляя к нему черепаху **абстракции** на которой собственно лежат эти киты, или стоят эти слоны. Но, так же как одними классами самими по себе не объясняются все возможности ООП, так и наследование, инкапсуляция, и полиморфизм не дают полного понимания ООП, но без них полного понимания быть точно не может.
Далее рассмотрим каждое из этих понятий по отдельности, как в отрыве друг от друга, так и рассмотрим как они между собой соотносятся.

----------------
### Наследование

Первое о чем разумеется стоит поговорить, это пожалуй то, что является как серьезным камнем преткновения у любителей разных подходов из за которого ведутся споры, так и главным преимуществом ООП, это **наследование**.  
**Наследование** - это специализированный механизм представленный в большинстве языков программирования поддерживающих объектную модель, который позволяет выстраивать родительски-дочерние взаимоотношения между классами, таким образом образу иерархию классов.  
Что же означают эти отношения, для этого обратимся к примеру на картинке ниже:
![Семейные отношения](imgs/FamiliInfo.png)

Как можно увидеть из этой схемы, у нас имеется древовидная структура, в которой есть несколько веток каждая из которых начинается от условного прародителя Рода - деда. Далее идут две поддерева, это поддерево отца, и поддерево матери, в каждом из которых есть конечные потомки. К чему же здесь эта древовидная структура? Разумный вопрос. Предположим, что наш прародитель рода за время своей жизни накопил какую то информацию, и поделился ей со своими детьми, таким образом, получается что его дети, в схеме это отец и мать, являются носителями той же информации что и дед, но так же они еще и накопили в процессе своей деятельности свою информацию, которую не могут передать деду, так как он их не хочет особо слушать, да и ему она уже не нужна. Однако, они передают ее своим потомкам, а вместе с ней и информацию полученную от своих родителей, т.е. дедушки в этой схеме. Таким образом конечные потомки знают всю информацию что накопили их предшественники, при этом предшественники эту информацию от наследников получить не могут. Под информацией в данном случае можно подразумевать как знания так и умения.  
В итоге, если отойти от бытовой терминологии и говорит о классах, то предположим что есть класс Дедушка, у него были описаны ряд полей и методов, что позволило ему выполнять его функции. Далее, в процессе разработки, от него наследовали два других класса, Отец и Мать, таким образом получили, что оба этих класса способны и могут делать те же действия что и класс родительский класс, но при этом примешали к этому свое собственное дополнительное поведение т.е. методы и дополнительные поля. От этих классов наследовались другие класса, и т.д. и т.п. Таким образом получилась древовидная структура в которой каждый последующий наследник расширяет поведение его родительских классов, при это храня ту же информацию, при этом нам не требуется постоянно писать те методы которые уже были написаны в родительских классах, т.е. базовое поведение сохраняется, в этом и заключается вся суть наследования. Передача и расширение базового поведения и хранимой информации родительского класса дочерними. 

Для отражения и запуска этого механизма при объявлении класса нам необходимо после его имени через двоеточие указать ключевое слово public и имя Родительского класса:
```
class <ИмяКласса>:public <ИмяРодительскогоКласса>{
    // блок кода
}
```

Для большей наглядности рассмотрим следующий пример кода:
```cpp
#include <iostream>
#include <string>
#include <cstdarg>

using namespace std;

class Weapon{
    public:
        string name;
        double damage;
        double distance;
        Weapon(string name, double damage, double distance): 
            name(name),
            damage(damage),
            distance(distance)
        {}
        void printCharacteristics(){
            cout << 
            "name: " << name << 
            "\ndamage: " << damage << 
            "\ndistance: " << distance << endl;
        }
};

class Pistol: public Weapon{
    public:
        int rounds_in_holder;
        double caliber;
        Pistol(string name, double damage, double distance, int rounds_in_holder, double caliber):
            rounds_in_holder(rounds_in_holder),
            caliber(caliber),
            Weapon(name, damage, distance)
        {}
        void printPistolCharacteristics(){
            printCharacteristics();
            cout << 
            "rounds_in_holder: " << rounds_in_holder << 
            "\ncaliber: " << caliber << endl;
        }
        double shotByDistance(double distance){
            if(distance > this->distance){
                cout << "To far" << endl;
                return 0;
            }else {
                return damage;
            }
        }
};

class Sword: public Weapon{
    public:
        string steel;
        double length;
        Sword(string name, double damage, string steel, double length):
            steel(steel),
            length(length),
            Weapon(name, damage, length)
        {}
        void printSwordCharacteristics(){
            printCharacteristics();
            cout << 
            "steel: " << steel << 
            "\nlength: " << length << endl;
        }
        double strike(){
            return damage;
        }
};

int main(){
    Weapon w("Test", 0, 0);
    Pistol p("9mm", 10, 15, 9, 9.);
    Sword s("ecs", 10, "1060 CARBON STEEL", 1.5);
    w.printCharacteristics();
    p.printPistolCharacteristics();
    p.printCharacteristics();
    cout << p.shotByDistance(8) << endl;
    cout << p.shotByDistance(20) << endl;
    s.printSwordCharacteristics();
    cout << s.strike() << endl;
    return 0;
}
```

В этом примере у нас имеется базовый или родительский класс `Weapon` который определяет для себя набор хранимых данных, в виде полей `name`, `damage`, `distance`, а так же набор методов, в данном случае он один `printCharacteristics`. Эти свойства и методы можно использовать посредством создания объекта этого класса и обращения к ним. Далее после класса `Weapon`, определен класс наследник или дочерний класс, `Pistol`. Этот класс расширяет изначальный набор полей добавляя к нему поля `caliber`, `rounds_in_holder` и добавляет метод который напечатает все характеристики уже именно объекта типа `Pistol`. Ну и третьим классом определен класс `Sword`, который так же как и `Pistol` является наследником и определяет свои поля: `steel`, `length` и свой метод: `printSwordCharacteristics`, при этом можно заметить, что он приравнивает параметр `distance` к параметру `length` что логично для меча.  
В итоге, в консоли мы увидим следующий вывод:
```
name: Test
damage: 0
distance: 0
name: 9mm
damage: 10
distance: 15
rounds_in_holder: 9
caliber: 9
name: 9mm
damage: 10
distance: 15
10
To far
0
name: ecs
damage: 10
distance: 1.5
steel: 1060 CARBON STEEL
length: 1.5
10
```
Во всем этом процессе наследования и описания классов важно отметить следующее:
- во первых, атрибуты наследуемого класса не принадлежат классу наследнику, они принадлежат все так же объекту класса родителя, который скрыт внутри объекта класса наследника, поэтому при вызове конструктора необходимо отдельно вызывать конструктор родительского класса.
- во вторых, как можно заметить внутри класса наследника можно вызывать методы класса родителя
- в третьих, через объект класса наследника можно вызвать методы класса родителя

Таким образом мы на примере убедились, что наследование позволяет не копировать а как бы передавать поведение и расширять его, значительно сокращая написание кода.
> Важной ремаркой будет то, что в некоторых языках(к примеру в GO) от механизма наследования отказались, и в том виде в котором мы его видим в С++ его нет.


----------------
### Инкапсуляция

В процессе рассмотрения всех предыдущих примеров про классы никак не были прокомментировано ключевое слово public, разумеется пора исправить эту досадную оплошность. Вторым важным элементом ООП является **Инкапсуляция** - этом механизм языка позволяющий скомбинировав свойства и методы объекта в нем разграничить права доступа к ним. Таким образом обычно говорят что инкапсуляция позволяет скрыть от внешнего для класса наблюдателя, т.е. того кто его использует, реализацию этого класса, т.е. спрятать все промежуточные и чисто системные методы и атрибуты которые не должны меняться из вне.

Для большего понимания, вернемся к примеру с родителями и детьми:
![Инкапсуляция в семье](imgs/FamiliProtectedInfo.png)

На изображении отображается пример того, как в семье распространяется информация. У каждого члена семьи в иерархии есть то, что они могут и рассказывают всем, есть то, что они рассказывают только членам семьи, и есть то, что они не раскалывают даже им. Таким образом мы можем увидеть, что дедушка хранит только ту информацию которую знает сам и сам ей распоряжается. Его сын, т.е. отец, хранит информацию деда котору он рассказывает всем и ту которую он рассказывает только в семье, и как следствие уже сам управляет этой информацией как ему хочется, но он не знает ничего о том что дед не говорит никому. И в конце сын, знает всю информацию которую рассказывают отец и дед как в кругу семьи так и в целом, но ничего не знает о их личной информации, но так же как и они имеет ее. В итоге, каждый из членов семьи имеет 3 набора информации:
- общедоступную, или публичную
- защищенную, или семейную
- закрытую, или личную
Если переходить от бытовой терминологии к классической, то каждый класс может управлять информацией и методами которыми он владеет и разграничивать доступ к ним посредством использования модификаторов доступа которые ставятся перед группой объявлений методов и свойств и отделяются от них двоеточием и переносом строки. Возможно использование следующих модификаторов:
- public - общедоступные свойства и методы
- protected - защищенные свойства и методы, доступные только классам наследникам
- private - закрытые свойства и методы не доступные никому кроме этого класса.

При наследовании класс наследник сам решает как поступать с той информацией которую он наследует, а соответственно и кому когда и как ее предоставлять, так:
- Когда вы открыто наследуете родительский класс, то унаследованные члены public остаются public, унаследованные члены protected остаются protected, а унаследованные члены private остаются недоступными для дочернего класса.

|Спецификатор доступа в родительском классе|Спецификатор доступа при наследовании типа public в дочернем классе|
--- | ---
|public|public|
|private|Недоступен|
|protected|protected|

- При закрытом наследовании все члены родительского класса наследуются как закрытые. Это означает, что члены private остаются недоступными, а члены protected и public становятся private в дочернем классе.

Спецификатор доступа в родительском классе|Спецификатор доступа при наследовании типа private в дочернем классе
--- | ---
public|private
private|Недоступен
protected|private

- С защищенным наследованием, члены public и protected становятся protected, а члены private остаются недоступными.

Спецификатор доступа в родительском классе|Спецификатор доступа при наследовании типа protected в дочернем классе
--- | ---
public|protected
private|Недоступен
protected|protected

Для большей наглядности, рассмотрим следующий пример:
```cpp
#include <iostream>
#include <string>
#include <cstdarg>

using namespace std;

class Weapon{
    private:
        string name;
        double damage;
        double distance;
    protected:
        double getDistance(){
            return distance;
        }
        double getDamage(){
            return distance;
        }
        Weapon(string name, double damage, double distance): 
            name(name),
            damage(damage),
            distance(distance)
        {}
    public:
        string getName(){
            return name;
        }
        void printCharacteristics(){
            cout << 
            "name: " << name << 
            "\ndamage: " << damage << 
            "\ndistance: " << distance << endl;
        }
};

class Pistol: public Weapon{
    private:
        int rounds_in_holder;
        double caliber;
    public:
        Pistol(string name, double damage, double distance, int rounds_in_holder, double caliber):
            rounds_in_holder(rounds_in_holder),
            caliber(caliber),
            Weapon(name, damage, distance)
        {}
        void printPistolCharacteristics(){
            printCharacteristics();
            cout << 
            "rounds_in_holder: " << rounds_in_holder << 
            "\ncaliber: " << caliber << endl;
        }
        double shotByDistance(double distance){
            if(distance > getDistance()){
                cout << "To far" << endl;
                return 0;
            }else {
                return getDamage();
            }
        }
};


int main(){
    // Weapon w("Test", 0, 0); <-- ошибка
    Pistol p("9mm", 10, 15, 9, 9.);
    // w.printCharacteristics();
    p.printPistolCharacteristics();
    cout << p.shotByDistance(8) << endl;
    cout << p.shotByDistance(20) << endl;
    return 0;
}
```

В консоли мы увидим следующее:
```
name: 9mm
damage: 10
distance: 15
rounds_in_holder: 9
caliber: 9
15
To far
0
```

Как можно заметить, то что мы видим в консоли не сильно отличается от того что было представлено в примере про наследование, однако теперь нельзя непосредственно создать объект класса `Weapon`, да и если мы хотим обратиться к какому либо полю относящемуся к классу `Weapon` даже из дочернего класса нам теперь необходимо использовать методы которые реализуют эти обращения, в данном случае в методе `shotByDistance` мы не можем просто обратиться к полю `distance`, мы используем метод `getDistance` реализующий чтение этого поля, и часто называемый гетером. В этом маленьком примере и описывается вся суть инкапсуляции, программист сам может определять как работать с его классом и таким образом ограничивать других программистов от неправильных и ломающих все действий.


----------------
### Полиморфизм

Последним понятием которое относиться к китам ООП является полиморфизм, это понятие описывает механизм при котором в зависимости от того с каким классом мы работаем, мы можем получать разное поведение вызывая одну и ту же функцию, если они наследуются от одного родительского класса, т.е. мы так же как обычные функции можем перегружать методы, но не просто в рамках одного класса с разными аргументами, а в рамках дерева наследования иметь один и тот же метод у всех наследников с одинаковым названием и одинаковыми параметрами но при этом с абсолютно разным поведением.

В качестве иллюстрации рассмотрим следующую схему:
![методы автомобиля](imgs/CarMethods.png)

На изображении выше мы можем видеть что у нас есть некоторая абстрактная машина, и от нее есть 3 наследника, условно говоря разные модели машин. Каждая из этих моделей имеет свои особенности и свою специфику в управлении, но концептуально управление каждой из машин описывается определенным одинаковым для всех набором функций, и поэтому принципиально любой человек умеющий управлять одной из этих моделей может спокойной выполнив тот же принципиальный алгоритм действий использовать ее по назначению для перемещения.

В качестве примера кода, рассмотрим наши предыдущие классы, с учетом одного дополнения:
```cpp
#include <iostream>
#include <string>
#include <cstdarg>

using namespace std;

class Weapon{
    public:
        string name;
        double damage;
        double distance;
        Weapon(string name, double damage, double distance): 
            name(name),
            damage(damage),
            distance(distance)
        {}
        void printCharacteristics(){
            cout << 
            "name: " << name << 
            "\ndamage: " << damage << 
            "\ndistance: " << distance << endl;
        }
};

class Pistol: public Weapon{
    public:
        int rounds_in_holder;
        double caliber;
        Pistol(string name, double damage, double distance, int rounds_in_holder, double caliber):
            rounds_in_holder(rounds_in_holder),
            caliber(caliber),
            Weapon(name, damage, distance)
        {}
        void printCharacteristics(){
            Weapon::printCharacteristics();
            cout << 
            "rounds_in_holder: " << rounds_in_holder << 
            "\ncaliber: " << caliber << endl;
        }
        double shotByDistance(double distance){
            if(distance > this->distance){
                cout << "To far" << endl;
                return 0;
            }else {
                return damage;
            }
        }
};

class Sword: public Weapon{
    public:
        string steel;
        double length;
        Sword(string name, double damage, double distance, string steel, double length):
            steel(steel),
            length(length),
            Weapon(name, damage, distance)
        {}
        void printCharacteristics(){
            Weapon::printCharacteristics();
            cout << 
            "steel: " << steel << 
            "\nlength: " << length << endl;
        }
        double strike(){
            return damage;
        }
};

```

Как видно, методы `printPistolCharacteristics` и `printSwordCharacteristics` заменены на `printCharacteristics`, обеспечив таким образом единообразия работы с любым подклассом оружия. В итоге работа с классом будет выглядеть следующим образом:

```cpp
int main(){
    Weapon w("Test", 0, 0);
    Pistol p("9mm", 10, 15, 9, 9.);
    Sword s("ecs", 10, 1, "1060 CARBON STEEL", 1.5);
    w.printCharacteristics();
    p.printCharacteristics();
    cout << p.shotByDistance(8) << endl;
    cout << p.shotByDistance(20) << endl;
    s.printCharacteristics();
    cout << s.strike() << endl;
    return 0;
}
```

Тут важным дополнением будет то, что при работе с наследованием, связывание методов с типами происходит на момент компиляции, а соответственно если мы будем работать с каким либо классом наследником через указатель на тип родителя, то и метод который будет вызываться будет методом родительского класса, поэтому для обращения к методу именно наследника придется выполнить приведение типа.
> Есть и более правильный вариант называемый абстрактными методами и связыванием на этапе исполнения, но его мы рассмотрим в следующей лекции.

----------------
### Дружественные функции

Когда мы говорим о инкапсуляции, мы должны так же упомянуть важный пункт связанный с взаимодействием между объектами и их закрытыми членами. Таким пунктом являются дружественные функции, это такие функции которые формально не являются членами класса но имеют доступ к приватным членам класса, что позволяет им будучи внешними функциями взаимодействовать с внутренним устройством класса.

Для того что бы объявить функцию как дружественную нужно внутри класса для которого она является дружественной объявить ее с ключевым словом `friend`:
```
class <название класса>{
    ... Описание класса
    friend <тип возвращаемого значение> <название функции>(<аргументы, один из которых должен как то связан с классом>);
}

<тип возвращаемого значение> <название функции>(<аргументы, один из которых должен как то связан с классом>){
    ... Реализация дружественной функции
}
```
Исходя из данной сигнатуры и того факта, что дружественная функция обязательно должна фигурировать внутри определения класса, мы можем сделать вывод, что написать дружественную функцию к классу к коду которого вы не имеете доступ не получиться, а соответственно и не сможете таким образом получить доступ к тем данным класса к которым не предполагается доступ. Но при этом реализация функции в обязательном порядке пишется вне класса, что позволяет сделать одну и ту же функцию дружественной к нескольким классам и обеспечить удобное их взаимодействие друг с другому посредством этой функции.
> логично, что указателя this внутри дружественной функции не существует.

Рассмотрим дружественные функции на примере:
```cpp
#include <iostream>
#include <string>
#include <cstdarg>
#include <ostream>

using namespace std;

class MyPrintedInt{
    private:
        int data;
    public:
        MyPrintedInt(int data): data(data){}
    friend void printInt(MyPrintedInt& mpi);
};

void printInt(MyPrintedInt& mpi){
    cout << "MPI: " << mpi.data << endl;
}

void printInt(int i){
    cout << "Int: " << i << endl;
}

int main(){
    MyPrintedInt mpi(10);
    // cout << mpi.data << endl; <- ошибка
    printInt(mpi); // 10
    printInt(12); // 12
    return 0;
}
```

Как видно из этого примера, посредством такой функции мы можем делать перегрузку в том числе уже существующих функций обеспечивая их более понятную работу с нашими пользовательскими классами.

----------------
### Перегрузка операторов

Так же еще одним важным аспектом требующим упоминания является наличия возможности в C++ перегружать не только методы классов но и такие операторы как например +, - или *. По устройству языка С++, эти операторы являются не более чем простой функцией со специфическим названием начинающейся со слова `operator`, после чего следует тот оператор, который мы переопределяем.

В качестве илюстрации рассмотрим такой пример:
```cpp
#include <iostream>
#include <string>
#include <cstdarg>
#include <ostream>

using namespace std;

class MyPrintedInt{
    private:
        int data;
    public:
        MyPrintedInt(int data): data(data){}
        int operator+(int i) {
            return data + i;
        }
        void print(){
            cout << "MPI: " << data << endl;
        }
};

int main(){
    MyPrintedInt mpi(10);
    mpi.print(); // 10
    cout << mpi + 10 << endl; // 10
    mpi.print(); // 10
    return 0;
}
```
Как видно из примера, мы смогли обеспечить взаимодействие между базовым типом целочисленного значения int и нашим произвольным типом MyPrintedInt посредством классического оператора сложения.  
Для перегрузки доступны практически все операторы, так В C++17 стандарт разрешает перегружать следующие операторы: +, -, *, /, %, ^, &, |, ~, !, ,, =, <, >, <=, >=, ++, –-, <<, >>, ==, !=, &&, ||, +=, -=, /=, %=, ^=, &=, |=, *=, <<=, >>=, [], (), ->, ->*, new, new[], delete, delete[].(Обратим внимание на то, что этот список не менялся с C++98.)  
> Не рекомендуется перегружать следующие три бинарных оператора: , (запятая), &&, ||. Дело в том, что для них стандарт предусматривает порядок вычисления операндов (слева направо), а для последних двух еще и так называемую семантику быстрых вычислений (short-circuit evaluation), но для перегруженных операторов это уже не гарантируется или просто бессмысленно, что может оказаться весьма неприятной неожиданностью для программиста. (Семантика быстрых вычислений, называемая еще закорачиванием, заключается в том, для оператора && второй операнд не вычисляется, если первый равен false, а для оператора || второй операнд не вычисляется, если первый равен true.)  
> Более подробно о перегрузке операторов можно прочесть в статье https://habr.com/ru/post/489666/

Важно обратить внимание на то, что при перегрузке операторов таким образом с лева от бинарного оператора обязательно должен стоять объект нашего класса, иначе оператор не будет выполняться, потому что у всех методов класса первым неуказываемым но всегда существующим аргументом является объект класса к которому метод и относиться.

----------------
### Перегрузка операторов через дружественные функции

Как отмечалось выше, перегрузка операторов внутри класса для бинарных операторов подразумевает их использование только в определенном порядке, если быть точным то в порядке снача объект класса в котором перегружен оператор и только после второй аргумент, хотя как правило действия являются коммутативными, а значит не зависят от того с какой стороны находиться тот или иной аргумент. Т.е. в случае сложения целочисленнного значения и дробного и в случае сложения дробного и целочисленного результат должен быть одинаков. Для таких ситуация предпочтительным вариантом перегрузки оператора будут перегрузки через дружественные(не обязательно дружественные) функции, в которых мы можем сами указывать первый и второй аргумент:

```
class <название класса>{
    ... Описание класса
    friend <тип возвращаемого значение> operator<оператор>(<аргументы>);
}

friend <тип возвращаемого значение> operator<оператор>(<аргументы>){
    ... Реализация дружественной функции
}
```
Благодаря совмещению двух вариантов, можно обеспечить поддержку математчиеских операций совмещающих пользовательские и встроенные типы.

Типичным примером перегрузки оператора через дружественную функцию может служить перегрузка оператора << для того, что бы наш класс мог самостоятельно определять свой вывод в консоль:
```cpp
#include <iostream>
#include <string>
#include <cstdarg>
#include <ostream>

using namespace std;

class MyPrintedInt{
    private:
        int data;
    public:
        MyPrintedInt(int data): data(data){}
    friend ostream& operator<<(ostream& os, MyPrintedInt& mpi);
};

ostream& operator<<(ostream& os, MyPrintedInt& mpi){
    return os << "MPI: " << mpi.data;
}

int main(){
    MyPrintedInt mpi(10);
    cout << 5 << " " << mpi << " " << 15 << endl; // 5 MPI: 10 15
    return 0;
}
```

----------------
### Конструктор который нельзя копировать

Зная все то что было указано вышел в разделах инкапсуляции, наследования и полиморфизма можно создать две интересные конструкции, и выполнить соответвенно две задачи которые переодически могут возникать в практике программирования.  
Первым таким объектом и задаче будет объект который нельзя скопировать:
```cpp
#include <iostream>
#include <string>
#include <cstdarg>
#include <ostream>

using namespace std;

class NotToCopyInt{
    public:
        int data;
        NotToCopyInt(int data): data(data){}
        ostream& operator<<(ostream& os){
            os << data;
            return os;
        }
    private:
        NotToCopyInt( const NotToCopyInt& );
        void operator=( const NotToCopyInt& );
};

int main(){
    NotToCopyInt i1(10);
    // cout << i1 << endl;
    i1 << cout << endl;
    // NotToCopyInt i2 = i1; <- ошибка
    NotToCopyInt* i3 = new NotToCopyInt(13);
    (*i3) << cout << endl;
    return 0;
}
```
Как можно увидеть из кода, для того что бы сделать объект который нельзя скопировать, мы скрываем его конструктор копирования и оператор присвоения в закрытую, т.е. доступную только объекту непосредственно этого класса область, что гарантирует нам невозможность компилировать код который пытается скопировать объект такого класса.

Для чего же может понадобиться такой класс, ну к примеру для создания какого то разделяемого состояния, которое должно существовать в единственном экземпляре на всю программу, либо же управление этим состоянием и его копирование является более сложной задачей свзяанной со множеством дополнительных действий, либо же это не какое либо состояние, а какой либо ресурс который может должен использоваться там где открывается и никуда не передоваться.

----------------
### Конструктор который нельзя создать

Второй конструкцией и задачей является объект который нельзя создать:
```cpp
#include <iostream>
#include <string>
#include <cstdarg>
#include <ostream>

using namespace std;

class NotCreate{
    public:
        int data;
        ostream& operator<<(ostream& os){
            os << data;
            return os;
        }
        static NotCreate& create(int data){
            NotCreate* instance = new NotCreate(data);
            return *instance;
        }
    private:
        NotCreate(int data): data(data){}
};

int main(){
    // NotCreate i1(10); <- ошибка
    // cout << i1 << endl;
    NotCreate& i1 = NotCreate::create(10);
    i1 << cout << endl;
    NotCreate i2 = i1;
    i2 << cout << endl;
    // NotToCopyInt* i3 = new NotToCopyInt(13); <- ошибка
    return 0;
}
```
С этим объектом, как и с предыдущим все просто, все что от нас потребовалось это скрыть все конструкторы в закрытую часть класса, и теперь простым путем объект этого класса создать не получиться.

Опять же, для чего такое может понадобиться, в принчипе, для решения примерно тех же задач что и прошлая конструкция, только с той лишь разницей, что мы управляем не передачей объекта куда либо, а его созданием, что позволит нам не дать создать больше 1 реального такого объекта, что является типичным представлением такого патерна проектирования как одиночка.

