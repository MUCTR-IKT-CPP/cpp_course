# Лекция 4: Классы, конструкторы и деструкторы.

### План лекции:

1. Парадигма
2. ООП
3. Абстрагирование
4. Преимущества ООП
5. Критика ООП
6. Класс в С++
7. Конструктор
8. Перегрузка конструкторов
9. Конструктор по умолчанию
10. Короткий конструктор присвоения
11. Конструктор копирования
12. Деструктор
13. RAII
14. Правило трех
15. Указатель this


----------------
### Парадигма программирования

Как уже говорилось ранее, парадигмой программирования является некоторый набор правил, подходов и идей к написанию программ обеспечивающие особое ее построение и дающие свои определенные преимущества. В прошлых лекциях рассматривая различные аспекты языка С++ мы фокусировались на парадигме блочного или процедурного программирования, которая позволила нам познакомиться с такими понятиями как условия, циклы, функции и структры. Каждая из этих конструкций языка пришла в него от языков которые в первую очередь совершали переход от постоянных директив go to к минимальной и во многом необходимой структуризации кода, избавлению от огромного количества спагети кода и отвечали на тенденцию времени выражающуюся во все большем усложнении программ поддержание которых в рабочем состоянии при подходах использовавшихся ранее была уже невозможна. Именно этим же, но только со своей стороны занялся и язык С++, он совершил качественный переход от структруной парадигмы программирования к объектно ориентированной парадигме.

----------------
### Объектно ориентированная парадигма

Объектно ориентированной она называется потому, что во главу угла в ней ставиться привязка к понятию объекта, причем под объектом в данном случае понимается как некий объект реального мира, такой как машина, велосипед, солнце, здание, так и более абстрактные объекты, на примере файла или подключения к базе данных. Опираясь на различные понятия реального мира, ООП задается вопросом, а какие собственно объекты свойства есть у реальных и не только объектов, и какие действия они и с ними можно выполнять.  
В итоге, ООП, определяется следующим образом:  
**Объектно-ориентированное программирование (ООП)** — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.
Таким образом из определения получается, что идеологически ООП это подход к программированию как к моделированию информационных объектов, решающий на новом уровне основную задачу структурного программирования: структурирование информации с точки зрения управляемости, что существенно улучшает управляемость самим процессом моделирования, что, в свою очередь, особенно важно при реализации крупных проектов.
Объектно-ориентированное программирование рассматривает данные не само по себе, а в связке с операциями с этими данными, в этой парадигме структуры представляют собой наборы данных и функций по работе с этими данными.

----------------
### Абстрагирование

Для того, что бы ООП могло оперировать различными информационными объектами оно базируется и операется на такое процесс познания окружающего мира как абстрагирование, определяемое как:  
**Абстрагирование** — это метод познания, мысленное выделение, вычленение некоторых элементов конкретного множества и отвлечение их от прочих элементов данного множества.  
Абстрагирование является одним из основных процессов умственной деятельности человека опирающейся на знаковое опосредлование и позволяющее превратить в объект рассмотрения различные свойства предметов. С этим методом познания каждый из нас сталкивается еще с самого детства, так как именно этот процесс позволяет нам запоминать и идентифицировать различные объекты реального мира. Конечно, это не единственный метод познания используемый в повседневной жизни, но он однозначно является важным и значимым для каждого из нас, и так же как со временем учены начали использовать его осознано в своей научной деятельности, специалисты по компьютерным наукам и программированию пришли к осознанию необходимости его применения, и выстроили на его основе целую парадигму. Разумеется ООП не является единственной парадигмой оперирующей понятием абстракции как результата процесса абстрагирования, однако оно не опирается только на математические абстракции, как например функциональное программирование, а оперирует самим процессом, предлагая создавать и выстраивать свои абстракции и выделять свои абстрактные понятия. Разумеется сейчас и в других парадигмах используется как понятие абстракции так и процесс абстрагирования, но ооп первым подняло это на уровень постоянной практики, связав область проектирования программ с предметной областью.

----------------
### Преимущества ООП

Как и у любого другого подхода, у ООП, есть свои преемущества и недостатки. Основными преимуществами являются следующие:

- ООП код легче понимать и проектировать, так как программист оперирует терминами предметной области, что позволяет разговаривать с заказчиком на одном языке и позволяет лучше предусмотреть все варианты действий с данными.
-  Программисту не приходится решать множество технических вопросов хранения и локализации данных одного абстрактного понятия, разграничивания и локализации функций работы с ними, что позволяет не учитывать эту специфику во время проектирования и ускорить программирование.
-  ООП код легче поддерживать чем процедурный, так как локализация всех функций и данных позволяет лучше в нем ориентироваться
-  Высокая степень повторного использования кода из-за выделения множества абстрактных понятий, которые могут быть не жестко привязаны к текущему проекту, что позволит использовать их в других проектах.

> Разумеется это не все преимущества, да и если вы придете в стан ценителей другой парадигмы, вряд ли вы сможете убедить их этими аргументами, так как этот спор длиться уже множество времени и конца ему нет. Однако важно то, что несмотря на то, что у ООП много критики, преимущества у него реально есть, и именно поэтому эта парадигма получила такое широкое распространение, и сейчас редко какой язык ее не поддерживает в том или ином виде и вариации
----------------
### Критика ООП

Разумеется по мимо преимуществ у ООП есть и проблемы, и разумеется есть те кто критикует эту парадигму, их критика может быть как разумной так и не очень, поэтому игнорировать ее нет никакого смысла, у всего есть недостатки, и их важно знать и понимать, тогда и только тогда можно эффективно использовать какую либо технологию и идею, и только тогда она может получить развитие. Поэтому пройдемся по основным моментами критик ООП.
- ##### Критика рекламы ООП
    Критикуется явно высказываемое или подразумеваемое в работах некоторых пропагандистов ООП, а также в рекламных материалах «объектно-ориентированных» средств разработки представление об объектном программировании как о некоем всемогущем подходе, который магическим образом устраняет сложность программирования. 
    > Разумеется эта критика разумна, и более того, со стороны сообщества так скажем любителей ООП, такое мнение о нем постоянно критикуется, к сожалению не существует универсальной палочки выручалочки, и поэтому нужно всегда учитывать что является разумным в решении той или иной задачи, готового решения на все случае жизни к сожалению нет.
- ##### Оспаривание эффективности разработки методами ООП 
    Критики оспаривают тезис о том, что разработка объектно-ориентированных программ требует меньше ресурсов или приводит к созданию более качественного ПО. Проводится сравнение затрат на разработку разными методами, на основании которого делается вывод об отсутствии у ООП преимуществ в данном направлении.
    > И тут нельзя не согласиться с критиками, с одной стороны имея свои преимущества в области проектирования программного обеспечения, ООП создает свои сложности, которые требуют скрупулезного отношения к разработке, что влечет за собой временные издержки. Однако, если разработку методологией ООП ведут люди которые хорошо в ней разбираются, используют современные подходы, и не являются сторонниками только этой парадигмы, они вполне способны разрабатывать на ней быстрее, чем на прочих, просто потому что для определенных задач она оказывается невероятно подходящей.
- ##### Производительность объектно-ориентированных программ 
    Указывается на то, что целый ряд «врождённых особенностей» ООП-технологии делает построенные на её основе программы технически менее эффективными, по сравнению с аналогичными необъектными программами. Не отрицая действительно имеющихся дополнительных накладных расходов на организацию работы ООП-программ нужно, однако, отметить, что значение снижения производительности часто преувеличивается критиками.
    > Это пожалуй та претензия, на которую в действительности ответа просто нет, да как не крути, а ООП языки медленнее, чем их структурные собратья, что прекрасно иллюстрируется сравнением языков си и си++. Однако, многие из тех языков приверженцами которых являются критики ООП, порой бывают еще более медленными из-за использования других специфических подходов, которые так же как и ООП, создают свои накладные расходы, но в счет этого хорошо решают возложенные на них задачи. 
- ##### Критика отдельных технологических решений в ООП-языках и библиотеках 
    Эта критика многочисленна, но затрагивает она не ООП как таковое, а приемлемость и применимость в конкретных случаях тех или иных реализаций её механизмов. Одним из излюбленных объектов критики является язык C++, входящий в число наиболее распространённых промышленных ООП-языков.
    > К счастью различной критике тех или иных решений настолько много, что существуют другие языки которые являясь объектно ориентированными решают эти проблемы, правда почему то создавая свои собственные, что опять же должно учитываться при выборе языка для решения конкретной задачи, которая и будет диктовать критичность тех или иных проблем.

В итоге критика ООП и С++ как языка основанного на этой парадигме обширна, но важным замечанием в данном случае является то, что несмотря ни на что, язык С++ получил невероятное распространение, и до сих пор не теряет своей актуальности, что однозначно говорит о том, что программисты и компании которые его используют готовы платить этими недостатками за его достоинства.

----------------
### Классы

Итак, после всей лирики, мы подобрались к основному элементу ООП, это класс. Класс в парадигме является главным результатом процесса абстрагирования и олицетворяет абстракцию которую в дальнейшем мы как программисты собираемся использовать в нашей программе. В нем сосредоточены все те свойства и взаимодействия некоторой сущности которые мы решили выделить и которые считаемым значимыми для решения поставленной задачи. Таким образом получается, что класс это специальная языковая конструкция, являющаяся набором полей и методов взаимодействия с данными хранящимися в этих полях. Итоговая сигнатура класса как конструкции языка выглядит следующим образом:
```
class <Наименование класса> {
    public:
        <тип поля> <название поля>;
        <тип поля> <название поля> = <значение по умолчанию>;
        <тип возвращаемого значения> <название метода> (<параметры метода>){
            // блок кода
        }
};
```
Как можно заметить из этой сигнатуры класс очень похож на обычную структуру, существенное отличие начинается там где появляются методы, которые не отличаются от простых функций, просто они объявлены внутри конструкции с ключевым словом class. 

Конкретная переменная класса называется **объектом** и является размещенными данными полей этого класса в определенной памяти, с которой можно взаимодействовать через эту переменную и вызывать методы класса, которые так же будут взаимодействовать с этой памятью.

Для создания переменной с типом класса необходимо написать следующую строчку:
```
<название класса> <название переменной>(<аргументы конструктора>);
```
Либо, при создании через оператор `new`:
```
<название класса>* <название переменной> = new <название класса>(<аргументы конструктора>);
```
Для обращения к полям и методам класса используется следующая конструкция:
```
// вызов метода
<название переменной>.<название метода>(<аргументы метода>);
// запись в поле
<название переменной>.<название поля> = <значение>;
// чтение из поля
<название переменной>.<название поля>;
```
В случае если создается переменная указателя на объект класса, то обращения происходит через оператор `->`

Примером простого класса можно считать класс точки:
```cpp
class Point{
    public:
        int x = 0;
        int y = 0;
        void printPoint(){
            cout << "(" << x << ", " << y << ")" << endl;
        }
        int getX() {
            return this->x;
        };
        int getY(){
            return this->y;
        }
        Point(int x_value, int y_value){
            x = x_value;
            y = y_value;
        }
};

int main(){
    Point p(12, 10);
    p.printPoint(); // (12, 10)
    cout << "(" << p.getX() << ", " << p.getY() << ")" << endl; // (12, 10)
    cout << "(" << p.x << ", " << p.y << ")" << endl; // (12, 10)
    return 0;
}
```
В этом примере можно заметить множество интересных моментов, которые возможно требуют пояснения, чем собственно сейчас мы и займемся.

----------------
### Конструктор

Начнем мы с самого важного метода для любого класса, таким методом является конструктор.  **Конструктор** - это специальный метод, который вызывается автоматически при выполнении инструкции объявления переменной. При этом память под переменную уже выделена заранее, т.к. память под все локальные переменные выделяется на стеке программы в момент вызова функции. Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые прописаны по умолчанию какими либо сложными способами, рассчитываются исходя из других значений или предоставляются пользователем, выделения динамический памяти, а так же для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определённый файл или базу данных).
В отличие от обычных методов, конструкторы имеют определённые правила по поводу их имён:
- Конструкторы всегда должны иметь то же имя, что и класс (учитываются верхний и нижний регистры).
- Конструкторы не имеют типа возврата (даже void-а).
Сигнатура конструктора следующая:
```
class <наименование класса> {
    public:
        <наименование класса> (<параметры конструктора>){
            // блок кода
        }
};

```
В пример выше конструктором является следующий метод:
```cpp
class Point{
    public:
        // ...
        Point(int x_value, int y_value){
            x = x_value;
            y = y_value;
        }
        // ...
};
```
Конструктор может быть не один, и поддерживает стандартные правила перегрузки функций, поэтому может быть конструктор который использует 1, 2, 3 и т.д параметров.

----------------
### Конструктор по умолчанию

Как можно заметить, при перечислении количества возможных параметров у конструктора я не назвал число 0. Это не означает что такого конструктора быть не может, нет, это означает что этот конструктор выделяется специальным образом отдельно и называется конструктором по умолчанию.  
Конструктор, который не имеет параметров (или содержит параметры, которые все имеют значения по умолчанию), называется **конструктором по умолчанию**. Он вызывается, если пользователем не указаны значения для инициализации.
Сигнатура следующая
```
class <Наименование класса> {
    public:
        <тип поля> <наименование поля>;
        <наименование класса> (){
            // Код конструктора
        }
};

```
Так, для примера выше конструктор по умолчанию будет:
```cpp
class Point{
    public:
        // ...
        Point(){
            x = 0;
            y = 0;
        }
        // ...
};
```
Конструктор по умолчанию вызовет конструкторы всех полей данных. Если эти поля - объекты, для них будут вызваны конструкторы по умолчанию. Если это указатели на объекты, то указатели будут проинициализированы значением 0, сами же объекты созданы не будут (!), память выделена не будет.  
Важно отметить, если ваш класс не имеет конструкторов, то язык C++ автоматически сгенерирует для вашего класса открытый конструктор по умолчанию. Его иногда называют неявным конструктором (или «неявно сгенерированным конструктором»).

----------------
### Короткий конструктор присвоения

В С++, несмотря на то что он является уже достаточно старым языком имеется определенный набор конструкций которые упрощают написанный код, сокращая его. К таким конструкциям относиться и особый подвид конструктора, это короткий конструктор присвоения, сигнатура такого конструктора следующая:
```
class <Наименование класса> {
    public:
        <тип поля> <наименование поля>;
        <наименование класса> (<тип поля> <наименование аргумента>): <наименование поля>(<наименование аргумента>){}
};
```
А для примера выше, он будет выглядеть следующим образом:
```cpp
class Point{
    public:
        // ...
        Point(int x_value, int y_value): x(x_value), y(y_value){}
        // ...
};
```
Как можно заметить из этого примера, значения поданные на вход конструктора просто присваиваются внутренним полям объекта класса, при этом ни кто не запрещает вам добавлять какие либо дополнительные действия к конструктору присвоения, и писать их как у обычного метода между фигурными скобками.

----------------
### Конструктор копирования

Следующим отдельно стоящим видом конструктора является конструктор копирования, который копирует наш объект во время операции присвоения.
Сигнатура у такого конструктора следующая:
```
class <Наименование класса> {
    public:
        <тип поля> <наименование поля>;
        <наименование класса> (const <наименование класса>& <наименование аргумента>){
            // код копирования
        }

```

Как и конструктор по умолчанию конструктор копирования создается автоматически для каждого класса. Однако при копировании через автоматически созданный конструктор копирования не происходит копирование и выделение памяти выделенной в процессе инициализации или работы с классом в динамической памяти при помощи оператора new, а происходит только копирование значения указателя. Это связано с тем, что как и структура поля класса расположены в памяти последовательно друг за другом и локализованы в одном месте, тогда как любая память выделенная через new является отельно стоящей и исполняющая машина с++ сама по себе не знает о ней ничего, поэтому и не может ее скопировать самостоятельно. Процесс такого копирования называется почленной инициализацией объекта, а результатом работы такого процесса получается shadow copy которая лиш ссылается на данные скрытые за указателем, что приведет к потере данных в копии объекта, если удалиться изначальный объект. Поэтому если у вас есть данные выделяемые через new необходимо создавать конструктор копирования. Либо же создавать отдельный метод копирования который позволит вам создавать глубокую полную копию, а теневые копии оставлять для сокращения накладных расходов при передачи аргументов в функцию при помощи копирования.

Примером работы конструктора копирования созданного компилятором по умолчанию может служить следующий код:
```cpp
class Point{
    public:
        int x = 0;
        int y = 0;
        double* error;
        void printPoint(){
            cout << "(" << x << ", " << y << ")" << endl;
        }
        void printAddress(){
            cout << this << endl;
        }
        Point(int x, int y){
            this->x = x;
            this->y = y;
            this->error = new double {0.5};
        }
};

int main(){
    Point p(12, 10);
    p.printPoint(); // (12, 10)
    p.printAddress(); // 0x61fe10
    cout << p.error << endl; // 0x194200
    Point p2 = p;
    p2.printPoint(); // (12, 10)
    p2.printAddress(); // 0x61fe00
    cout << p2.error << endl; // 0x194200
    return 0;
}
```
Результат работы этого кода следующий:
```bash
(12, 10)
0x61fe10
0x194200
(12, 10)
0x61fe00
0x194200
```
Со своим собственным конструктором копирования мы получим следующий код
```cpp
class Point{
    public:
        int x = 0;
        int y = 0;
        double* error;
        void printPoint(){
            cout << "(" << x << ", " << y << ")" << endl;
        }
        void printAddress(){
            cout << this << endl;
        }
        Point(int x, int y){
            this->x = x;
            this->y = y;
            this->error = new double {0.5};
        }
        Point(const Point& point){
            this->x = point.x;
            this->y = point.y;
            this->error = new double {*point.error};
        }
};

int main(){
    Point p(12, 10);
    p.printPoint(); // (12, 10)
    p.printAddress(); // 0x61fe10
    cout << p.error << endl; // 0x6e4220
    Point p2 = p;
    p2.printPoint(); // (12, 10)
    p2.printAddress(); // 0x61fe00
    cout << p2.error << endl; // 0x6e4260
    return 0;
}
```
С результатом:
```bash
(12, 10)
0x61fe00
0x1c4220
(12, 10)
0x61fdf0
0x1c4260
```

Как видно из примере, в случае отсутствия конструктора копирования, значение скрытое за указателем не копируется, копируется лиш сам указатель.

----------------
### Деструктор

Еще одним отдельно стоящим методом который есть у каждого класса, является деструктор.  
**Деструктор** — это специальный тип метода класса, который выполняется при удалении объекта класса. В то время как конструкторы предназначены для инициализации класса, деструкторы предназначены для очистки памяти после него.
Когда объект автоматически выходит из области видимости или динамически выделенный объект явно удаляется с помощью ключевого слова delete, вызывается деструктор класса (если он существует) для выполнения необходимой очистки до того, как объект будет удален из памяти. Для простых классов (тех, которые только инициализируют значения обычных переменных-членов) деструктор не нужен, так как C++ автоматически выполнит очистку самостоятельно.
Так же, как и конструкторы, деструкторы имеют свои правила, которые касаются их имен:
- должен иметь то же имя, что и класс, со знаком тильда (~) в самом начале;
- не может принимать аргументы;
- не имеет типа возврата.

Сигнатура деструктора следующая:
```
~<наименование класса>(){
    // код деструктора
}
```
А для нашего класса точки из примера про конструктор копирования, деструктор будет выглядеть следующим образом:
```cpp
class Point{
    public:
        // ...
        ~Point(){
            delete error;
        }
        // ...
}
```
Как можно заметить в деструкторе происходит удаление только памяти выделенной динамическим образом, так как память которая изначально выделяется под класс подчищается компилятором и для нее не требуется никаких особых действий.

----------------
### Указатель this

Как можно было обратить внимание, в некоторых примерах фигурировало ключевое слово `this`. В каждом методе класса всегда существует указатель с названием `this` который всегда в обязательном порядке указывает на текущий объект класса у которого был вызван этот метод. Чаще всего этот указатель используется для того что бы обращаться к полям  в случае если их названия совпадают с названиями локальных переменных.
- При вызове `obj.method(parm)`, компилятор фактически вызывает `method (&obj, parm)`.
- Внутри `method()`, указатель `*this` содержит адрес объекта `obj`.
- К любым переменным - членам внутри `method()` добавляется префикс `this->.` Поэтому, когда мы говорим `cls_field = parm`, компилятор фактически выполняет `this->cls_field = parm`, который, в этом случае, обновляет `obj.cls_field` на `parm`.  

В качестве примера, можно привести такой конструктор класса Point:
```cpp
class Point{
    public:
        // ...
        Point(int x, int y){
            this->x = x;
            this->y = y;
        }
        // ...
};
```

Так же указатель `this` можно возвращать из метода, так как иногда бывает полезно, чтобы метод класса возвращал объект, с которым работает, в виде возвращаемого значения. Основной смысл здесь — это позволить нескольким методам объединиться в «цепочку», работая при этом с одним объектом.  
Указатель `this` является скрытым параметром, который неявно добавляется к каждому методу класса. В большинстве случаев нам не нужно обращаться к нему напрямую, но при необходимости это можно сделать. Стоит отметить, что указатель `this` является константным указателем — вы можете изменить значение исходного объекта, но вы не можете заставить указатель `this` указывать на что-то другое.


----------------
### RAII

Эта аббревиатура означает специальное идеоматическое выражение Resource Acquisition Is Initialization (Получение ресурсов есть инициализация) которое можно рассматривать как некоторое правило объектно ориентированного программирования:  
> использование ресурсов привязывается к времени жизни объектов с автоматической продолжительностью жизни  

По сути это означает что если нам необходимо использовать в своей программе файл или подключение к серверу, к базе данных и тому подобное, то мы должны обернуть этот ресурс в класс и привязать факты открытия и закрытия этого ресурса к элементам цикла жизни объекта класса, т.е. открывать в конструкторе, а закрывать в деструкторе.

----------------
### Правило трех

Так же при программировании классов и конструкторов на С++, есть некоторое правило которому следует придерживаться:
>Если вам пришлось объявить что-либо из собственного конструктора копирования, собственного оператора присваивания и собственного деструктора, то, скорее всего,вам нужно объявить все вышеперечисленное.

Упрощенное объяснение:
Если среди полей класса есть хотя бы один указатель, вам нужно писать свой конструктор копирования, оператор присваивания и деструктор класса.
