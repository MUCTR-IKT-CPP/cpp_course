# Лекция 7: Контейнеры в C++

## План лекции:
- Контейнерные классы
- Последовательные и ассоциативные контейнеры
- Итераторы
- Цикл for each
- Вектор (vector)
- Массив (array)
- Список (list)
- Стек (stack)
- Очередь (queue)
- Двусторонняя очередь (deque)
- Множество (set)
- Словарь (map)
- Алгоритмическая сложность операций
- Дополнительные контейнеры и адаптеры
- Практические рекомендации по выбору контейнера

## Контейнерные классы

**Контейнерный класс** (или «класс-контейнер») — это класс, предназначенный для хранения и организации нескольких объектов определённого типа данных (пользовательских или фундаментальных).

Контейнерные классы обладают рядом преимуществ по сравнению с обычными массивами:
- Возможность динамического изменения размера
- Повышенная безопасность
- Удобство использования
- Встроенная поддержка итераторов
- Интеграция с алгоритмами STL

Основной функционал контейнерных классов включает:
- Создание пустого контейнера (через конструктор)
- Добавление нового объекта в контейнер
- Удаление объекта из контейнера
- Просмотр количества объектов в контейнере
- Очистка контейнера от всех объектов
- Доступ к сохранённым объектам
- Сортировка объектов/элементов (не всегда)

Типом отношений в классах-контейнерах является «член чего-то» — элементы принадлежат контейнеру.

Контейнеры делятся на два основных типа:
- **Последовательные контейнеры**
- **Ассоциативные контейнеры**

**Важное дополнение:** Все контейнеры STL являются шаблонными классами, что позволяет использовать их с любыми типами данных. Они реализуют принцип "один раз написано — многократно используется", что является основой парадигмы повторного использования кода.

## Последовательные контейнеры

**Последовательные контейнеры** (или «контейнеры последовательности») — это контейнерные классы, элементы которых находятся в последовательности. Их определяющей характеристикой является возможность вставки элемента в любое место контейнера.

Наиболее распространённым примером последовательного контейнера является массив: при вставке элементов они сохраняют порядок вставки.

Начиная с C++11 STL содержит 6 контейнеров последовательности:
- `std::vector`
- `std::deque`
- `std::array`
- `std::list`
- `std::forward_list`
- `std::basic_string`

**Дополнительная информация:** Все последовательные контейнеры обеспечивают гарантию порядка элементов. Это означает, что элементы будут располагаться в контейнере в том порядке, в котором они были добавлены (за исключением случаев явной сортировки).

## Итератор

**Итератор** — структура данных, которая «указывает» на некоторый элемент контейнера и умеет переходить к предыдущему/следующему элементу.

Методы контейнерных классов, возвращающие итераторы:
- `Iterator begin()` — доступ к первому (нулевому) элементу контейнера
- `Iterator end()` — указывает на конец последовательности (несуществующий элемент, следующий за последним, нельзя обращаться к этому элементу!)
- `reverse_iterator rbegin()` — указывает на первый элемент в обратном порядке
- `reverse_iterator rend()` — указывает на несуществующий элемент, следующий за первым в обратном порядке (конец последовательности)

Дополнительные методы:
- `front()` — доступ к первому элементу
- `back()` — доступ к последнему элементу
- Переход к следующему элементу для итератора `p` — с помощью операции инкремента (`++p` или `p++`)

**Дополнительная информация:** Итераторы можно рассматривать как обобщение понятия "указатель". Они предоставляют унифицированный интерфейс для доступа к элементам контейнера, независимо от его внутренней реализации. Существует пять категорий итераторов:
1. **Input iterators** — только для чтения, однопроходные
2. **Output iterators** — только для записи, однопроходные
3. **Forward iterators** — чтение/запись, многопроходные
4. **Bidirectional iterators** — как forward, но с возможностью движения назад
5. **Random access iterators** — полный доступ, включая арифметику указателей

## Цикл for each

**Цикл for each** — особый вид цикла `for`, используемого для последовательных контейнеров, которые предоставляют механизм, подобный арифметике указателей.

Цикл `for each` проходится по каждому элементу последовательного контейнера (например, массива) и сохраняет его в локальную для цикла переменную.

Сигнатура использования:
```cpp
for(<Тип элементов массива> <имя локальной переменной> : <имя массива>) {
    // Блок кода использующий элемент массива
}
```

Важные особенности:
- Цикл `for each` не предоставляет возможности получить номер элемента
- Цикл `for each` не может работать с указателями на массив
- Цикл `for each` допускает использование ссылочных типов в объявлении

Цикл `for each` тесно связан с ключевым словом `auto`, которое позволяет компилятору автоматически определить тип переменной. Важно понимать, что `auto` — это не динамическая типизация, и после первого присвоения тип переменной фиксируется.

**Дополнительная информация:** Цикл for-each был добавлен в C++11 и является синтаксическим сахаром для итераторов. Он гарантирует безопасный обход контейнера без риска выхода за его пределы. При использовании ссылок (`&`) можно модифицировать элементы контейнера напрямую, что более эффективно, чем копирование.

**Пример с различными вариантами:**
```cpp
int main() {
    srand(time(0));
    const int N = 10;
    int array[N] = {0};
    
    // Заполнение массива
    for(int i = 0; i < N; i++) {
        array[i] = (rand() % 100);
    }
    
    // Традиционный цикл
    for(int i = 0; i < N; i++) 
        cout << array[i] << ";";
    cout << endl;
    
    // For-each с копированием
    for(int el : array) 
        cout << el << ";";
    cout << endl;
    
    // For-each с ссылкой (можно модифицировать)
    for(int& el : array) 
        el *= 2;
    
    // For-each с auto
    for(auto el : array) 
        cout << el << ";";
    
    cout << endl;
    return 0;
}
```

## Вектор

**Вектор** (он же одномерный массив) — упорядоченный набор элементов с произвольным доступом по числовому индексу. Это динамический массив, способный увеличиваться по мере необходимости для содержания всех своих элементов.

Класс `vector` обеспечивает:
- Произвольный доступ к элементам через оператор индексации `[]`
- Поддержку вставки и удаления элементов
- Эффективное использование памяти
- Гарантию непрерывного размещения элементов в памяти

```cpp
#include <vector>
vector<Тип> v;
```

### Доступ к элементам

Функции для манипуляции вектором:
- `operator[]()` — обращение к элементу вектора (без проверки границ)
- `at()` — обращение к элементу вектора с проверкой границ (выбрасывает исключение при выходе за пределы)
- `push_back()` — вставка нового значения в конец вектора
- `pop_back()` — изъятие значения из конца вектора
- `insert()` — вставка значения в произвольное место (требует итератор)
- `erase()` — удаление произвольного значения (требует итератор)
- `front()` — доступ к первому элементу
- `back()` — доступ к последнему элементу
- `empty()` — проверка на пустоту
- `size()` — количество элементов
- `clear()` — очистка контейнера

Итератор вектора:
```cpp
vector<Тип>::iterator имя_итератора = имя_вектора.begin();
vector<Тип>::reverse_iterator имя_итератора = имя_вектора.rbegin();
```

### Пример работы с вектором

```cpp
int main() {
    srand(time(0));
    const int N = 10;
    vector<int> v(N);
    
    cout << "Initial size: " << v.size() << endl;
    
    // Заполнение вектора
    for(int i = 0; i < N; i++) {
        v[i] = (rand() % 100);
    }
    
    cout << "Size after filling: " << v.size() << endl;
    
    // Доступ через индекс и at()
    for(int i = 0; i < N; i++) 
        cout << v[i] << " " << v.at(i) << ";";
    cout << endl;
    
    // For-each с auto
    for(auto el : v) 
        cout << el << ";";
    cout << endl;
    
    // Добавление элементов в конец
    for(int i = 0; i < N; i++) {
        v.push_back(rand() % 100);
    }
    
    cout << "Final size: " << v.size() << endl;
    
    // Обход с использованием итераторов
    for(vector<int>::iterator i = v.begin(); i != v.end(); i++) 
        cout << *i << ";";
    cout << endl;
    
    return 0;
}
```

### Размер вектора и его изменение

Функции управления размером:
- `size()` — число элементов в контейнере
- `max_size()` — максимальный размер контейнера (порядка 1 миллиарда элементов)
- `empty()` — возвращает `true`, если контейнер пустой
- `resize()` — изменяет размер хранилища и вектора
- `reserve()` — изменяет размер хранилища, но не размер вектора
- `clear()` — уничтожает все элементы, изменяет размер, но не освобождает память хранилища
- `capacity()` — возвращает текущую ёмкость вектора (количество элементов, которые могут быть размещены без перераспределения памяти)

Важно: правильнее сначала вызывать `clear()`, а затем `resize()`.

**Дополнительная информация:** Вектор реализует стратегию экспоненциального роста. Когда требуется больше памяти, вектор выделяет новую область памяти, копирует туда существующие элементы и освобождает старую память. Коэффициент роста обычно составляет 1.5 или 2.0. Это означает, что частые вставки в конец вектора имеют амортизированную временную сложность O(1).

**Пример с reserve():**
```cpp
// Неэффективно - возможны множественные перераспределения памяти
vector<int> v1;
for(int i = 0; i < 1000; ++i) {
    v1.push_back(i);
}

// Эффективно - одно выделение памяти
vector<int> v2;
v2.reserve(1000);
for(int i = 0; i < 1000; ++i) {
    v2.push_back(i);
}
```

## Массив в C++

**Array** представляет собой массив фиксированной длины. Добавлять и удалять элементы из него нельзя.

Эта структура имеет ту же семантику, что и C-массивы. Размер и эффективность `array<T,N>` такие же, как у C-массива `T[N]`.

```cpp
#include <array>
array<Тип, N> v;
```

Методы `array` аналогичны методам `vector`, за исключением тех, что манипулируют размером:
- `size()`
- `max_size()`
- `empty()`
- `operator[]()`
- `at()`
- Итераторы
- `fill()` — заполнение всех элементов заданным значением
- `swap()` — обмен содержимым с другим массивом

**Дополнительная информация:** Класс `std::array` является оберткой над C-массивом, предоставляющей интерфейс контейнеров STL. Основные преимущества:
- Безопасный доступ через `at()`
- Поддержка итераторов
- Возможность передачи по значению
- Интеграция с алгоритмами STL
- Отсутствие "падения" до указателя

### Пример работы с array

```cpp
int main() {
    srand(time(0));
    const int N = 10;
    
    std::array<int, 3> a1{{1, 2, 3}}; // требуются двойные фигурные скобки
    std::array<int, 3> a2 = {1, 2, 3}; // за исключением операций присваивания
    
    std::array<int, N> arrayCPP = {0};
    
    // Вывод через for-each
    for(int el : arrayCPP) 
        cout << el << ";";
    cout << endl;
    
    // Заполнение всеми элементами одним значением
    arrayCPP.fill(1);
    
    for(int el : arrayCPP) 
        cout << el << ";";
    cout << endl;
    
    cout << "Size: " << arrayCPP.size() << endl;
    
    // Модификация через ссылки
    for(int& i : arrayCPP) 
        i = rand() % 1000;
    
    for(int el : arrayCPP) 
        cout << el << ";";
    cout << endl;
    
    // Использование итераторов
    for(auto i = arrayCPP.begin(); i != arrayCPP.end(); i++) 
        *i = rand() % 100;
    
    for(int el : arrayCPP) 
        cout << el << ";";
    cout << endl;
    
    return 0;
}
```

## Список

**Список** — контейнер, который поддерживает быструю вставку и удаление элементов из любой позиции. Быстрый произвольный доступ не поддерживается.

Типы списков:
- **Односвязный** (`forward_list`) — можно передвигаться только вперед
- **Двусвязный** (`list`) — можно передвигаться в обоих направлениях

**Дополнительная информация:** Списки реализованы как связные списки, где каждый элемент содержит данные и указатели на следующий (и предыдущий, в случае двусвязного списка) элемент. Это обеспечивает O(1) вставку и удаление в любом месте при наличии итератора, но O(n) для доступа по индексу.

### Пример работы со списком

```cpp
int main() {
    srand(time(0));
    const int N = 10;
    std::list<int> list;
    
    cout << "Empty: " << list.empty() << " Size: " << list.size() << endl;
    
    for(int i = 0; i < N; i++) 
        list.push_back(rand() % 5);
    
    cout << "Empty: " << list.empty() << " Size: " << list.size() << endl;
    
    for(int el : list) 
        cout << el << ";";
    cout << endl;
    
    // Модификация элементов
    for(int& el : list) 
        el *= 2;
    
    for(int el : list) 
        cout << el << ";";
    cout << endl;
    
    // Сортировка
    list.sort();
    
    for(int el : list) 
        cout << el << ";";
    cout << endl;
    
    // Разворот порядка
    list.reverse();
    
    for(int el : list) 
        cout << el << ";";
    cout << endl;
    
    // Удаление дубликатов (только для отсортированных)
    list.unique();
    
    for(int el : list) 
        cout << el << ";";
    cout << endl;
    
    return 0;
}
```

### Недостатки связных списков

- Сложность прямого доступа к элементу по индексу
- Дополнительная память на поля-указатели
- Некоторые операции медленнее, чем с массивами
- Элементы могут быть распределены в памяти нелокально, снижая эффективность кэширования
- Сложность параллельных векторных операций

**Дополнительная информация:** Существует компромисс между списками и векторами. Векторы обеспечивают лучшую локальность данных и кэш-эффективность, но медленную вставку/удаление в середине. Списки обеспечивают быструю вставку/удаление, но плохую локальность данных. Выбор зависит от конкретных требований к производительности.

## Стек

**Стек** (stack) — структура данных LIFO (Last In, First Out). Напоминает банку для теннисных мячей — класть и доставать мячи можно только с одной стороны.

Операции стека:
- `empty()` — проверка на отсутствие элементов
- `push(value)` — добавление элемента
- `top()` — считывание головного элемента
- `pop()` — удаление головного элемента
- `size()` — получение размера

```cpp
#include <stack>
stack<тип> название_переменной;
```

**Дополнительная информация:** `std::stack` является контейнерным адаптером — он не хранит данные самостоятельно, а использует другой контейнер (по умолчанию `std::deque`) в качестве внутреннего хранилища. Можно указать другой контейнер:

```cpp
stack<int, vector<int>> stack_with_vector;  // Использует vector
stack<int, list<int>> stack_with_list;      // Использует list
```

### Пример работы со стеком

```cpp
void print(vector<int> container) {
    for(auto element : container) {
        cout << element << (element != *container.rbegin() ? "," : "");
    }
    cout << endl;
}

void print(stack<int> container) {
    while(!container.empty()) {
        auto element = container.top();
        container.pop();
        cout << element << (!container.empty() ? "," : "");
    }
}

int main() {
    vector<int> vector_data{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    stack<int> stack_data;
    
    print(vector_data);
    
    for(auto el : vector_data) {
        stack_data.push(el);
    }
    
    print(stack_data);
    return 0;
}
```

## Очередь

**Очередь** — структура данных FIFO (First In, First Out). Первый пришел, первый вышел.

Операции очереди:
- `push()` — добавить элемент в конец
- `front()` — получить элемент из начала
- `pop()` — удалить элемент из начала
- `empty()` — проверка, пустая ли очередь
- `size()` — получить размер очереди

```cpp
#include <queue>
queue<тип> название_переменной;
```

**Дополнительная информация:** Как и стек, `std::queue` является контейнерным адаптером, использующий по умолчанию `std::deque`. Можно использовать другие контейнеры:

```cpp
queue<int, list<int>> queue_with_list;  // Использует list
queue<int, deque<int>> queue_with_deque; // Использует deque (по умолчанию)
```

### Пример работы с очередью

```cpp
void print(queue<int> container) {
    while(!container.empty()) {
        auto element = container.front();
        cout << "(" << container.front() << " " << container.back() << ")";
        container.pop();
        cout << element << (!container.empty() ? "," : "");
    }
}

int main() {
    vector<int> vector_data{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    queue<int> queue_data;
    
    print(vector_data);
    
    for(auto el : vector_data) {
        queue_data.push(el);
        cout << "(" << queue_data.front() << " " << queue_data.back() << ")" 
             << (el != *vector_data.rbegin() ? "," : "");
    }
    cout << endl;
    
    print(queue_data);
    return 0;
}
```

## Двусторонняя очередь

**Двусторонняя очередь** (deque) — элементы добавляются и удаляются с обеих сторон.

Операции deque:
- `push_back()` — добавить элемент в конец
- `push_front()` — добавить элемент в начало
- `front()` — получить элемент из начала
- `back()` — получить элемент с конца
- `pop_back()` — удалить элемент с конца
- `pop_front()` — удалить элемент из начала
- `empty()` — проверка на пустоту
- `size()` — получить размер

```cpp
#include <deque>
deque<тип> название_переменной{};
```

**Дополнительная информация:** `std::deque` реализован как массив блоков. Это позволяет обеспечить O(1) вставку и удаление с обоих концов, а также O(1) произвольный доступ. В отличие от вектора, deque не гарантирует непрерывное размещение элементов в памяти, но обеспечивает стабильность итераторов при вставке в начало или конец.

### Пример работы с deque

```cpp
void print(vector<int> container) {
    for(auto element : container) {
        cout << element << (element != *container.rbegin() ? "," : "");
    }
    cout << endl;
}

void print(deque<int> container) {
    for(auto element : container) {
        cout << element << (element != *container.rbegin() ? "," : "");
    }
    cout << endl;
}

int main() {
    vector<int> vector_data{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    deque<int> deque_data{12, 11};
    
    print(vector_data);
    
    for(auto el : vector_data) {
        if(el % 2 == 0) 
            deque_data.push_front(el);
        else 
            deque_data.push_back(el);
        
        cout << "(" << deque_data.front() << " " << deque_data.back() << ")" 
             << (el != *vector_data.rbegin() ? "," : "");
    }
    cout << endl;
    
    print(deque_data);
    return 0;
}
```

## Множество

**Множество** (set) — ассоциативный контейнер, содержащий только уникальные значения, отсортированные по возрастанию.

```cpp
#include <set>
set<тип> имя_переменной{значения_инициализации};
```

### Методы множества

- `clear()` — очищает контейнер
- `insert()` — вставляет элементы
- `erase()` — удаляет элементы
- `swap()` — обменивает содержимое
- `emplace()` — создает элементы на месте
- `merge()` — объединяет два множества
- `extract()` — изымает элемент
- `count(key)` — возвращает количество элементов с ключом
- `find(key)` — находит элемент с ключом
- `equal_range(key)` — возвращает диапазон элементов с ключом
- `lower_bound(key)` — первый элемент, не меньший ключа
- `upper_bound(key)` — первый элемент, больший ключа
- `contains(key)` — возвращает `true`, если контейнер содержит ключ (C++20)

**Дополнительная информация:** Множества реализованы как сбалансированные бинарные деревья поиска (обычно красно-черные деревья). Это обеспечивает O(log n) для всех операций. Элементы автоматически сортируются и уникальны.

### Пример работы с множеством

```cpp
#include<iostream>
#include<set>
#include<string>
using namespace std;

int main() {
    string text;
    getline(cin, text);
    cout << text << endl;
    cout << text.length() << endl;
    
    set<char> unique_letters;
    for(auto letter : text) {
        if(letter != ' ') 
            unique_letters.insert(letter);
    }
    
    cout << "Во введенном тексте, содержатся следующие уникальные буквы:" << endl;
    for(auto letter : unique_letters) {
        cout << letter;
        if(letter != *unique_letters.rbegin()) 
            cout << ",";
    }
    return 0;
}
```

## Словарь

**Словарь** (map) — ассоциативный контейнер, хранящий пары ключ-значение.

Типы словарей включают параметры:
- Тип ключа (Key)
- Тип значения (T)
- Функцию сравнения (comp)

### Конструкторы map

```cpp
// Пустой массив
map<Key, T, comp> ar;

// Конструктор копирования/перемещения
map<Key, T, comp> ar(other);

// С помощью итераторов
map<Key, T, comp> ar(first, last);

// С помощью списка инициализации
map<Key, T, comp> ar{{"a1", 10}, {"www", 17}, {"j8", 100}};
```

**Дополнительная информация:** `std::map` также реализован как сбалансированное бинарное дерево поиска. Ключи уникальны и автоматически сортируются. Для неупорядоченных ассоциативных контейнеров существуют `std::unordered_set` и `std::unordered_map`, реализованные как хеш-таблицы, обеспечивающие O(1) среднюю сложность операций.

### Пример работы со словарем

```cpp
#include<iostream>
#include<map>
#include<string>
using namespace std;

int main() {
    string text;
    getline(cin, text);
    cout << text << endl;
    cout << text.length() << endl;
    
    map<char, int> letters;
    for(auto letter : text) {
        if(letters.count(letter) == 0) 
            letters[letter] = 1;
        else 
            letters[letter]++;
    }
    
    for(auto letter : letters) {
        cout << "Букв " << letter.first << ":" << letter.second << endl;
    }
    return 0;
}
```

## Алгоритмическая сложность операций

| Контейнер | Вставка | Доступ | Удаление | Поиск |
|-----------|--------|--------|---------|-------|
| **vector/string** | В конец: O(1)<br>Остальные: O(n) | O(1) | В конце: O(1)<br>Остальные: O(n) | Сортированный: O(log n)<br>Несортированный: O(n) |
| **deque** | В начало/в конец: O(1)<br>Остальные: O(n) | O(1) | В начале/в конце: O(1)<br>Остальные: O(n) | Сортированный: O(log n)<br>Несортированный: O(n) |
| **list/forward_list** | В начало/в конец: O(1)<br>По итератору: O(1)<br>По индексу: O(n) | В начало/в конец: O(1)<br>По итератору: O(1)<br>По индексу: O(n) | В начале/в конце: O(1)<br>По итератору: O(1)<br>По индексу: O(n) | O(n) |
| **set/map** | O(log n) | - | O(log n) | O(log n) |
| **unordered_set/unordered_map** | O(1)/O(n) | O(1)/O(n) | O(1)/O(n) | O(1)/O(n) |
| **priority_queue** | O(log n) | O(1) | O(log n) | - |

*Адаптировано из http://john-ahlgren.blogspot.com/2013/10/stl-container-*

## Дополнительные контейнеры и адаптеры

Помимо основных контейнеров, STL предоставляет несколько дополнительных:

**forward_list** — односвязный список, более компактный, чем `list`, но с ограниченным функционалом.

**unordered_set/unordered_map** — хеш-таблицы, обеспечивающие среднюю O(1) сложность операций, но без упорядоченности элементов.

**priority_queue** — очередь с приоритетами, где элементы извлекаются в порядке убывания приоритета.

**multiset/multimap** — ассоциативные контейнеры, допускающие дублирование ключей.

## Практические рекомендации по выбору контейнера

1. **vector** — выбор по умолчанию для последовательных контейнеров
2. **deque** — когда нужны эффективные операции на обоих концах
3. **list/forward_list** — когда требуется частая вставка/удаление в середине
4. **array** — когда известен фиксированный размер и нужна максимальная производительность
5. **set/map** — когда нужны упорядоченные уникальные элементы или ассоциации ключ-значение
6. **unordered_set/unordered_map** — когда нужна максимальная скорость и порядок не важен

**Важное правило:** Всегда начинайте с `std::vector`, если только у вас нет конкретной причины использовать другой контейнер. Вектор обеспечивает лучшую кэш-эффективность и простоту использования.