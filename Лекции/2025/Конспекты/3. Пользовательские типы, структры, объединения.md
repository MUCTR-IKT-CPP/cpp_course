# Лекция 3: Пользовательские типы, структуры, объединения в C++

## План лекции:
- Введение в пользовательские типы данных
- Структуры (struct)
  - Объявление и определение структур
  - Инициализация структур
  - Методы в структурах
  - Структуры как типы данных
  - Сравнение структур
- Объединения (union)
  - Обычные объединения
  - Безопасные объединения (C++11 и выше)
  - Примеры использования объединений
- Перечисления (enum)
  - Обычные перечисления
  - Перечисления с областью видимости (enum class)
  - Подсчет размера перечислений
  - Использование перечислений в шаблонах
- Классы vs структуры
- Практические рекомендации
- Современные возможности C++20
- Расширенные техники работы с пользовательскими типами

## Введение в пользовательские типы данных

**Пользовательские типы данных** — это типы, определяемые программистом для представления сложных структур данных, которые не могут быть выражены с помощью встроенных типов языка. Они позволяют создавать абстракции, соответствующие предметной области задачи.

**Зачем нужны пользовательские типы?**
- Упрощают представление сложных данных
- Повышают читаемость и поддерживаемость кода
- Инкапсулируют данные и операции над ними
- Позволяют создавать более выразительные интерфейсы
- Обеспечивают типовую безопасность

**Основные виды пользовательских типов в C++:**
- Структуры (`struct`)
- Объединения (`union`)
- Перечисления (`enum`, `enum class`)
- Классы (`class`)

**Дополнительная информация:** Пользовательские типы данных являются основой объектно-ориентированного программирования в C++. Они позволяют создавать сложные системы, разбивая их на управляемые компоненты с четко определенными интерфейсами.

## Структуры (struct)

### Объявление и определение структур

Структура — это составной тип данных, который позволяет объединять переменные различных типов в единую сущность.

**Синтаксис объявления структуры:**

```cpp
struct Имя_структуры {
    // Поля структуры
    тип_данных поле1;
    тип_данных поле2;
    // ...
};
```

**Пример простой структуры:**

```cpp
struct Point {
    int x;
    int y;
};
```

**Дополнительная информация:** В C++ структуры могут содержать не только данные, но и функции (методы), операторы, конструкторы, деструкторы и т.д. Это отличает C++ от C, где структуры могут содержать только данные.

### Инициализация структур

Структуры можно инициализировать несколькими способами:

**1. Традиционная инициализация (C-style):**

```cpp
Point p1 = {10, 20};
```

**2. Инициализация в стиле C++11 и выше:**

```cpp
Point p2 = { .x = 30, .y = 40 };  // Именованная инициализация
Point p3{50, 60};                 // Инициализация списком
```

**3. Использование конструкторов:**

```cpp
struct Point {
    int x;
    int y;
    
    // Конструктор по умолчанию
    Point() : x(0), y(0) {}
    
    // Параметризованный конструктор
    Point(int x, int y) : x(x), y(y) {}
};

Point p4;          // Использует конструктор по умолчанию
Point p5(70, 80);  // Использует параметризованный конструктор
```

**Дополнительная информация:** Начиная с C++20, можно использовать designated initializers (именованные инициализаторы) для структур, даже если они имеют конструкторы:

```cpp
struct Point {
    int x;
    int y;
    
    Point(int x, int y) : x(x), y(y) {}
};

Point p = { .x = 10, .y = 20 };  // Работает в C++20
```

### Методы в структурах

В C++ структуры могут содержать методы, что делает их практически эквивалентными классам (за исключением уровня доступа по умолчанию):

```cpp
struct Rectangle {
    int width;
    int height;
    
    // Метод для вычисления площади
    int area() const {
        return width * height;
    }
    
    // Метод для проверки, является ли прямоугольник квадратом
    bool isSquare() const {
        return width == height;
    }
    
    // Перегрузка оператора вывода
    friend std::ostream& operator<<(std::ostream& os, const Rectangle& r) {
        os << "Rectangle(" << r.width << "x" << r.height << ")";
        return os;
    }
};

// Использование
Rectangle rect{5, 10};
std::cout << "Area: " << rect.area() << std::endl;  // 50
std::cout << "Is square: " << rect.isSquare() << std::endl;  // 0
std::cout << rect << std::endl;  // Rectangle(5x10)
```

**Дополнительная информация:** Структуры могут содержать все элементы, которые могут содержаться в классах:
- Конструкторы и деструкторы
- Методы (включая виртуальные)
- Операторы
- Вложенные типы
- Шаблоны
- Статические члены

### Структуры как типы данных

Структуры можно использовать как обычные типы данных:

```cpp
// Передача структуры в функцию
void printPoint(const Point& p) {
    std::cout << "Point(" << p.x << ", " << p.y << ")" << std::endl;
}

// Возврат структуры из функции
Point createPoint(int x, int y) {
    return {x, y};
}

// Структура как член другой структуры
struct Circle {
    Point center;
    int radius;
};

// Массив структур
Point points[3] = {{1, 2}, {3, 4}, {5, 6}};

// Указатель на структуру
Point* p = new Point{10, 20};
std::cout << p->x << ", " << p->y << std::endl;
delete p;
```

**Дополнительная информация:** Структуры могут быть использованы в шаблонах, что делает их очень гибкими:

```cpp
template <typename T>
struct Pair {
    T first;
    T second;
    
    Pair(const T& a, const T& b) : first(a), second(b) {}
};

Pair<int> intPair(1, 2);
Pair<std::string> stringPair("Hello", "World");
```

### Сравнение структур

По умолчанию структуры не поддерживают операторы сравнения, но их можно определить:

```cpp
struct Point {
    int x;
    int y;
    
    // Оператор равенства
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
    
    // Оператор неравенства
    bool operator!=(const Point& other) const {
        return !(*this == other);
    }
    
    // Оператор меньше
    bool operator<(const Point& other) const {
        return x < other.x || (x == other.x && y < other.y);
    }
};

// Использование
Point p1{1, 2};
Point p2{1, 2};
Point p3{3, 4};

std::cout << std::boolalpha;
std::cout << (p1 == p2) << std::endl;  // true
std::cout << (p1 != p3) << std::endl;  // true
std::cout << (p1 < p3) << std::endl;   // true
```

**Дополнительная информация:** Начиная с C++20, компилятор может автоматически генерировать операторы сравнения с помощью `default`:

```cpp
struct Point {
    int x;
    int y;
    
    // Автоматическая генерация операторов сравнения
    auto operator<=>(const Point&) const = default;
};
```

Это значительно упрощает определение операторов сравнения для структур.

## Объединения (union)

### Обычные объединения

**Объединение** — это пользовательский тип данных, все члены которого разделяют одну и ту же область памяти. В любой момент времени может быть активен только один член объединения.

**Синтаксис объявления объединения:**

```cpp
union Имя_объединения {
    // Члены объединения
    тип_данных член1;
    тип_данных член2;
    // ...
};
```

**Пример простого объединения:**

```cpp
union Data {
    int i;
    float f;
    char c;
};

// Использование
Data data;
data.i = 10;      // активируется член i
std::cout << data.i << std::endl;

data.f = 220.5;   // активируется член f, член i больше не активен
std::cout << data.f << std::endl;
```

**Дополнительная информация:** Размер объединения равен размеру его самого большого члена. Это позволяет эффективно использовать память, когда нужно хранить данные разных типов, но только одно значение в определенный момент времени.

### Безопасные объединения (C++11 и выше)

Обычные объединения не отслеживают, какой член активен в данный момент, что может привести к ошибкам. Для решения этой проблемы в C++11 был добавлен `std::variant`, а в C++17 — `std::any`.

**Пример использования `std::variant`:**

```cpp
#include <variant>
#include <string>
#include <iostream>

int main() {
    // variant может хранить одно из указанных типов
    std::variant<int, double, std::string> v;
    
    v = 123;  // хранит int
    std::cout << std::get<int>(v) << std::endl;
    
    v = 3.14;  // теперь хранит double
    std::cout << std::get<double>(v) << std::endl;
    
    v = "Hello";  // теперь хранит std::string
    std::cout << std::get<std::string>(v) << std::endl;
    
    // Проверка текущего типа
    if (std::holds_alternative<std::string>(v)) {
        std::cout << "Contains string: " << std::get<std::string>(v) << std::endl;
    }
    
    return 0;
}
```

**Пример использования `std::any`:**

```cpp
#include <any>
#include <string>
#include <iostream>

int main() {
    std::any a = 1;
    
    std::cout << std::any_cast<int>(a) << std::endl;
    
    a = 2.0;
    std::cout << std::any_cast<double>(a) << std::endl;
    
    a = std::string("Hello");
    std::cout << std::any_cast<std::string>(a) << std::endl;
    
    // Проверка типа
    if (a.type() == typeid(std::string)) {
        std::cout << "Contains string: " << std::any_cast<std::string>(a) << std::endl;
    }
    
    return 0;
}
```

**Дополнительная информация:** `std::variant` является типобезопасной альтернативой объединениям. Он автоматически отслеживает, какой тип данных хранится в данный момент, и предоставляет безопасные методы доступа к данным.

### Примеры использования объединений

**1. Представление данных в разных форматах:**

```cpp
union Color {
    uint32_t rgba;
    struct {
        uint8_t r;
        uint8_t g;
        uint8_t b;
        uint8_t a;
    };
};

Color red;
red.rgba = 0xFF0000FF;  // Красный цвет с полной непрозрачностью
std::cout << "R: " << (int)red.r << ", G: " << (int)red.g 
          << ", B: " << (int)red.b << ", A: " << (int)red.a << std::endl;
```

**2. Эффективное хранение данных:**

```cpp
// Хранение значения, которое может быть целым, вещественным или строкой
union Value {
    int i;
    double d;
    char* s;
    
    Value(int i) : i(i) {}
    Value(double d) : d(d) {}
    Value(char* s) : s(s) {}
};
```

**3. Реализация безопасного объединения вручную:**

```cpp
class SafeUnion {
private:
    enum Type { INT, DOUBLE, STRING } type;
    union {
        int i;
        double d;
        std::string* s;
    };
    
public:
    SafeUnion(int i) : type(INT), i(i) {}
    SafeUnion(double d) : type(DOUBLE), d(d) {}
    SafeUnion(const std::string& s) : type(STRING), s(new std::string(s)) {}
    
    ~SafeUnion() {
        if (type == STRING) {
            delete s;
        }
    }
    
    // Методы для безопасного доступа
    int getInt() const {
        if (type != INT) throw std::runtime_error("Not an int");
        return i;
    }
    
    double getDouble() const {
        if (type != DOUBLE) throw std::runtime_error("Not a double");
        return d;
    }
    
    std::string getString() const {
        if (type != STRING) throw std::runtime_error("Not a string");
        return *s;
    }
};
```

**Дополнительная информация:** Начиная с C++17, рекомендуется использовать `std::variant` вместо ручной реализации безопасных объединений, так как он предоставляет более безопасный и удобный интерфейс.

## Перечисления (enum)

### Обычные перечисления

**Перечисление** — это пользовательский тип данных, состоящий из набора именованных констант.

**Синтаксис объявления обычного перечисления:**

```cpp
enum Имя_перечисления {
    константа1,
    константа2,
    // ...
};
```

**Пример обычного перечисления:**

```cpp
enum Color {
    RED,
    GREEN,
    BLUE
};

// Использование
Color c = RED;
if (c == RED) {
    std::cout << "Color is red" << std::endl;
}
```

По умолчанию значения перечислителей начинаются с 0 и увеличиваются на 1 для каждого следующего элемента. Можно явно задать значения:

```cpp
enum StatusCode {
    SUCCESS = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
};
```

**Дополнительная информация:** Обычные перечисления имеют проблему "загрязнения пространства имен" — их значения становятся видимыми в области видимости, где объявлено перечисление. Это может привести к конфликтам имен.

### Перечисления с областью видимости (enum class)

Начиная с C++11, можно использовать перечисления с областью видимости, которые решают проблему загрязнения пространства имен:

**Синтаксис объявления:**

```cpp
enum class Имя_перечисления {
    константа1,
    константа2,
    // ...
};
```

**Пример перечисления с областью видимости:**

```cpp
enum class Color {
    RED,
    GREEN,
    BLUE
};

// Использование
Color c = Color::RED;
if (c == Color::RED) {
    std::cout << "Color is red" << std::endl;
}
```

**Преимущества enum class:**
- Значения перечисления находятся в области видимости перечисления (не загрязняют внешнее пространство имен)
- Типобезопасны — неявные преобразования в целочисленные типы запрещены
- Можно явно указать тип базового типа

**Явное указание базового типа:**

```cpp
enum class Color : uint8_t {
    RED,
    GREEN,
    BLUE
};
```

**Дополнительная информация:** Перечисления с областью видимости (enum class) рекомендуются для использования в новых проектах, так как они обеспечивают лучшую типовую безопасность и избегают проблем с конфликтами имен.

### Подсчет размера перечислений

В C++11 и выше можно определить количество элементов в перечислении с помощью хитрого трюка:

```cpp
enum class Direction {
    UP,
    DOWN,
    LEFT,
    RIGHT,
    COUNT  // Специальный элемент для подсчета
};

// Использование
constexpr int directionCount = static_cast<int>(Direction::COUNT);
```

Для перечислений без явного последнего элемента можно использовать шаблонную метафункцию:

```cpp
template <typename T>
constexpr size_t enum_size() {
    return static_cast<size_t>(T::COUNT);
}

// Пример использования
enum class Color {
    RED,
    GREEN,
    BLUE,
    COUNT
};

std::cout << "Number of colors: " << enum_size<Color>() << std::endl;
```

**Дополнительная информация:** В C++23 планируется добавить стандартный способ получения количества элементов в перечислении через библиотеку Reflection.

### Использование перечислений в шаблонах

Перечисления могут использоваться в шаблонах как не типовые параметры:

```cpp
template <typename T, T Value>
class ValueHolder {
    // ...
};

// Использование
enum class Status { OK, ERROR };
ValueHolder<Status, Status::OK> okStatus;
```

**Пример использования перечисления для настройки поведения шаблона:**

```cpp
enum class ContainerType { VECTOR, LIST, DEQUE };

template <ContainerType Type>
struct ContainerSelector {
    // По умолчанию не определено
};

template <>
struct ContainerSelector<ContainerType::VECTOR> {
    using type = std::vector<int>;
};

template <>
struct ContainerSelector<ContainerType::LIST> {
    using type = std::list<int>;
};

template <>
struct ContainerSelector<ContainerType::DEQUE> {
    using type = std::deque<int>;
};

// Использование
using MyContainer = ContainerSelector<ContainerType::VECTOR>::type;
MyContainer vec;
```

**Дополнительная информация:** Перечисления часто используются в шаблонах для параметризации поведения, особенно когда нужно выбрать одну из нескольких возможностей.

## Классы vs структуры

В C++ классы и структуры очень похожи, но имеют одно ключевое отличие:

- В **классах** уровень доступа по умолчанию — `private`
- В **структурах** уровень доступа по умолчанию — `public`

**Пример класса:**

```cpp
class MyClass {
    int privateData;  // private по умолчанию
    
public:
    int publicData;
};
```

**Пример структуры:**

```cpp
struct MyStruct {
    int publicData;  // public по умолчанию
    
private:
    int privateData;
};
```

**Когда использовать класс, а когда структуру?**

1. **Используйте структуру, когда:**
   - Тип является простой коллекцией данных без инкапсуляции
   - Нет необходимости в скрытии реализации
   - Тип не имеет сложного поведения
   - Тип не предназначен для наследования

2. **Используйте класс, когда:**
   - Нужно скрыть детали реализации
   - Тип имеет сложное поведение
   - Планируется наследование
   - Нужно контролировать доступ к данным

**Дополнительная информация:** Стиль кодирования может варьироваться в разных проектах. Некоторые проекты используют структуры только для простых POD (Plain Old Data) типов, в то время как другие используют структуры везде, где уровень доступа по умолчанию public соответствует их стилю.

## Практические рекомендации

### 1. Выбор между структурой и классом

- **Структуры** подходят для простых типов данных, которые в основном содержат данные и мало или не имеют поведения
- **Классы** подходят для типов с богатым поведением и инкапсуляцией

**Пример использования структуры:**
```cpp
struct Point {
    double x;
    double y;
    
    double distanceToOrigin() const {
        return std::sqrt(x*x + y*y);
    }
};
```

**Пример использования класса:**
```cpp
class BankAccount {
private:
    double balance;
    std::string accountNumber;
    
public:
    BankAccount(const std::string& number, double initialBalance);
    
    void deposit(double amount);
    bool withdraw(double amount);
    double getBalance() const;
};
```

### 2. Инициализация структур

- **Используйте список инициализации** для конструкторов
- **Рассмотрите возможность использования default-конструкторов** для POD-типов
- **Для сложных структур определите конструкторы**, чтобы гарантировать корректную инициализацию

**Пример хорошей инициализации:**
```cpp
struct Rectangle {
    int width;
    int height;
    
    // Конструктор с значениями по умолчанию
    Rectangle(int w = 0, int h = 0) : width(w), height(h) {}
    
    // Конструктор копирования
    Rectangle(const Rectangle& other) : width(other.width), height(other.height) {}
};
```

### 3. Использование перечислений

- **Предпочитайте enum class обычным enum**
- **Указывайте базовый тип для enum class**, если это важно для вашей задачи
- **Используйте перечисления вместо магических чисел или строк**

**Пример хорошего использования enum class:**
```cpp
enum class FileMode : uint8_t {
    READ = 1 << 0,
    WRITE = 1 << 1,
    APPEND = 1 << 2,
    BINARY = 1 << 3
};

// Оператор для комбинирования флагов
FileMode operator|(FileMode a, FileMode b) {
    return static_cast<FileMode>(
        static_cast<uint8_t>(a) | static_cast<uint8_t>(b)
    );
}

// Проверка флага
bool hasFlag(FileMode flags, FileMode flag) {
    return (static_cast<uint8_t>(flags) & static_cast<uint8_t>(flag)) != 0;
}

// Использование
FileMode mode = FileMode::READ | FileMode::BINARY;
if (hasFlag(mode, FileMode::READ)) {
    // Открыть файл для чтения
}
```

### 4. Использование объединений

- **Избегайте обычных объединений**, если только это не необходимо для взаимодействия с C или низкоуровневым кодом
- **Предпочитайте std::variant безопасным объединениям**
- **Если используете обычные объединения, всегда отслеживайте активный член**

**Пример использования std::variant:**
```cpp
using JsonValue = std::variant<std::nullptr_t, bool, int, double, std::string, 
                              std::vector<JsonValue>, std::map<std::string, JsonValue>>;

class JsonObject {
private:
    std::map<std::string, JsonValue> data;
    
public:
    void set(const std::string& key, JsonValue value) {
        data[key] = std::move(value);
    }
    
    JsonValue get(const std::string& key) const {
        auto it = data.find(key);
        if (it != data.end()) {
            return it->second;
        }
        return nullptr;
    }
};
```

## Современные возможности C++20

### 1. designated initializers

C++20 добавляет поддержку designated initializers (именованных инициализаторов), которые были доступны в C99:

```cpp
struct Point {
    int x;
    int y;
};

Point p = { .x = 10, .y = 20 };  // Именованная инициализация

// Можно инициализировать только часть полей
struct Options {
    int timeout = 5000;
    bool verbose = false;
    std::string logFile = "app.log";
};

Options opts = { .verbose = true };  // timeout=5000, verbose=true, logFile="app.log"
```

**Преимущества:**
- Повышает читаемость кода
- Позволяет инициализировать поля в любом порядке
- Позволяет инициализировать только часть полей

### 2. Перечисления с операторами сравнения по умолчанию

В C++20 можно автоматически генерировать операторы сравнения для перечислений:

```cpp
enum class Color {
    RED,
    GREEN,
    BLUE
};

// Автоматическая генерация операторов сравнения
constexpr bool operator==(Color, Color) = default;
constexpr bool operator!=(Color, Color) = default;
```

### 3. Using enum

C++20 добавляет возможность импортировать все перечислители в текущую область видимости:

```cpp
enum class Color {
    RED,
    GREEN,
    BLUE
};

void printColor() {
    using enum Color;  // Импортирует все перечислители в текущую область видимости
    
    Color c = RED;  // Теперь можно использовать RED без Color::
    if (c == GREEN) {
        // ...
    }
}
```

### 4. Лямбда-выражения в не типовых шаблонах

C++20 позволяет использовать лямбда-выражения как аргументы шаблонов:

```cpp
template <auto F>
struct FunctionWrapper {
    void operator()() {
        F();
    }
};

FunctionWrapper([]{ std::cout << "Hello from lambda!" << std::endl; }) wrapper;
wrapper();  // Выводит "Hello from lambda!"
```

## Расширенные техники работы с пользовательскими типами

### 1. Структуры как интерфейсы

Структуры могут использоваться для создания интерфейсов, особенно в шаблонном коде:

```cpp
struct Drawable {
    virtual void draw() const = 0;
    virtual ~Drawable() = default;
};

struct Circle : public Drawable {
    void draw() const override {
        std::cout << "Drawing circle" << std::endl;
    }
};

struct Square : public Drawable {
    void draw() const override {
        std::cout << "Drawing square" << std::endl;
    }
};

// Использование
std::vector<std::unique_ptr<Drawable>> shapes;
shapes.push_back(std::make_unique<Circle>());
shapes.push_back(std::make_unique<Square>());

for (const auto& shape : shapes) {
    shape->draw();
}
```

### 2. CRTP (Curiously Recurring Template Pattern)

CRTP — это шаблон проектирования, который позволяет реализовать статический полиморфизм:

```cpp
template <typename Derived>
struct Base {
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
    
    int value() {
        return static_cast<Derived*>(this)->valueImpl();
    }
};

struct Derived1 : Base<Derived1> {
    void implementation() {
        std::cout << "Derived1 implementation" << std::endl;
    }
    
    int valueImpl() {
        return 1;
    }
};

struct Derived2 : Base<Derived2> {
    void implementation() {
        std::cout << "Derived2 implementation" << std::endl;
    }
    
    int valueImpl() {
        return 2;
    }
};

// Использование
Derived1 d1;
d1.interface();  // Выводит "Derived1 implementation"
std::cout << d1.value() << std::endl;  // Выводит 1
```

**Преимущества CRTP:**
- Статический полиморфизм без накладных расходов виртуальных вызовов
- Возможность доступа к типу Derived в базовом классе
- Широко используется в STL (например, в std::iterator)

### 3. Структуры с переменным числом полей

С помощью шаблонов и рекурсии можно создать структуры с переменным числом полей:

```cpp
template <typename... Fields>
struct Record;

template <typename Field, typename... Rest>
struct Record<Field, Rest...> : Record<Rest...> {
    Field value;
    
    Record(const Field& f, const Rest&... rest) 
        : Record<Rest...>(rest...), value(f) {}
};

template <>
struct Record<> {
    Record() {}
};

// Использование
Record<int, std::string, double> record(42, "Hello", 3.14);
std::cout << record.value << std::endl;  // 42
std::cout << static_cast<Record<std::string, double>&>(record).value << std::endl;  // Hello
std::cout << static_cast<Record<double>&>(record).value << std::endl;  // 3.14
```

### 4. Сериализация пользовательских типов

Можно создать универсальный механизм сериализации для пользовательских типов:

```cpp
#include <iostream>
#include <string>
#include <type_traits>

// Трейт для проверки наличия метода serialize
template <typename T, typename = void>
struct is_serializable : std::false_type {};

template <typename T>
struct is_serializable<T, std::void_t<decltype(std::declval<T>().serialize(std::declval<std::ostream&>()))>> 
    : std::true_type {};

// Сериализация для встроенных типов
template <typename T>
typename std::enable_if<std::is_arithmetic<T>::value>::type
serialize(const T& value, std::ostream& os) {
    os << value;
}

// Сериализация для строк
void serialize(const std::string& str, std::ostream& os) {
    os << "\"" << str << "\"";
}

// Общая функция сериализации
template <typename T>
void serialize(const T& obj, std::ostream& os) {
    if constexpr (is_serializable<T>::value) {
        obj.serialize(os);
    } else {
        static_assert(std::is_arithmetic<T>::value || std::is_same<T, std::string>::value,
                      "Type is not serializable");
    }
}

// Пример использования
struct Point {
    int x;
    int y;
    
    void serialize(std::ostream& os) const {
        os << "{x:" << x << ",y:" << y << "}";
    }
};

int main() {
    Point p{10, 20};
    serialize(p, std::cout);  // {x:10,y:20}
    std::cout << std::endl;
    
    serialize(42, std::cout);  // 42
    std::cout << std::endl;
    
    serialize(std::string("Hello"), std::cout);  // "Hello"
    std::cout << std::endl;
    
    return 0;
}
```

## Заключение

Пользовательские типы данных — это мощный инструмент в C++, который позволяет создавать выразительные и типобезопасные программы. Понимание и правильное использование структур, объединений и перечислений является ключевым навыком для любого C++ разработчика.

**Основные выводы:**
1. **Структуры** — это гибкий способ создания составных типов данных с возможностью добавления методов и операторов
2. **Объединения** следует использовать осторожно; в новых проектах предпочтительнее `std::variant`
3. **Перечисления с областью видимости (enum class)** обеспечивают лучшую типовую безопасность и должны использоваться в новых проектах
4. **Классы и структуры** отличаются только уровнем доступа по умолчанию; выбор между ними зависит от стиля кодирования и требований к инкапсуляции
5. **Современные версии C++** (C++11, C++14, C++17, C++20) предоставляют множество улучшений для работы с пользовательскими типами

Помните, что хороший дизайн пользовательских типов требует баланса между абстракцией и простотой. Не создавайте сложные иерархии типов без необходимости, но и не упускайте возможности использовать типы для повышения выразительности и безопасности вашего кода.


-----------
Альтернатива
-----------

### **Конспект лекции: Пользовательские типы данных в C++ (Структуры, объединения, перечисления)**

#### **1. Организация кода: файлы и компиляция**

*   **Заголовочные файлы (.h/.hpp):** Содержат объявления (интерфейсы) — прототипы функций, определения классов, структур, перечислений, констант. Предназначены для включения (`#include`) в другие файлы.
*   **Файлы реализации (.cpp):** Содержат определения (реализации) функций, объявленных в заголовочных файлах.
*   **Структура проекта:** Четкое разделение на модули (папки `src/`, `include/`, `tests/`) упрощает навигацию и сборку.
*   **Сборка проекта:** Компиляция каждого `.cpp` файла в объектный файл и последующая линковка их в единый исполняемый файл.
    *   **Команда:** `g++ main.cpp utils.cpp -o main.exe`
*   **Защита от повторного включения:** Директивы препроцессора `#ifndef`, `#define`, `#endif` предотвращают ошибки компиляции, если заголовочный файл был включен несколько раз.

#### **2. Пространства имен (Namespace)**

*   **Назначение:** Логическая группировка кода и предотвращение конфликтов имен.
*   **Синтаксис:**
    ```cpp
    namespace my_namespace {
        void my_function();
        int my_variable;
    }
    ```
*   **Обращение:** Через оператор разрешения области видимости `::`
    *   `my_namespace::my_function();`
*   **Директива `using`:**
    *   `using namespace my_namespace;` — делает все имена из пространства видимыми в текущей области.
    *   `using my_namespace::my_function;` — делает конкретное имя видимым в текущей области.
*   **Важно:** Избегайте `using namespace std;` в заголовочных файлах, чтобы не засорять глобальное пространство имен во всех файлах, которые его подключат.

#### **3. Указатели и нулевой указатель**

*   **Нулевой указатель:** Указатель, который ни на что не указывает.
*   **Обозначение:** В современном C++ используйте `nullptr`. Избегайте устаревшего `NULL` (который является просто числом 0) или прямого присваивания `0`.
*   **Проверка:** `if (ptr == nullptr) { /* обработка случая "нет данных" */ }`
*   **Важность:** Предотвращает ошибки доступа к памяти (Segmentation fault) и явно обозначает опциональность данных.

#### **4. Пользовательские типы данных**

Это типы, определяемые программистом для более точного моделирования предметной области.

##### **4.1. Перечисления (enum)**

*   **Назначение:** Создание типа с ограниченным набором именованных целочисленных значений.
*   **"Обычное" перечисление (C++03):**
    ```cpp
    enum Status { SUCCESS, FAIL, WARNING }; // SUCCESS=0, FAIL=1, WARNING=2
    enum Month { JAN=1, FEB, MAR }; // Явное задание значения (JAN=1, FEB=2, MAR=3)
    ```
    *   **Недостаток:** Неявное преобразование к `int`, отсутствие собственной области видимости (имена констант "просачиваются" наружу).
*   **Перечисление с областью видимости (enum class, C++11):**
    ```cpp
    enum class Status { SUCCESS, FAIL, WARNING };
    Status s = Status::SUCCESS;
    // int x = s; // Ошибка! Нет неявного преобразования.
    int x = static_cast<int>(s); // Явное преобразование - OK.
    ```
    *   **Преимущества:** Типобезопасность, собственное пространство имен для констант.

##### **4.2. Структуры (struct)**

*   **Назначение:** Композитный тип данных, объединяющий несколько переменных (полей) разных типов под одним именем.
*   **Синтаксис:**
    ```cpp
    struct Person {
        std::string name;
        int birth_year;
    };
    ```
*   **Инициализация:**
    ```cpp
    // Uniform initialization (C++11) - предпочтительный способ
    Person p1 {"Alice", 1990};

    // По умолчанию (поля могут содержать "мусор")
    Person p2;

    // Присваивание полям
    p2.name = "Bob";
    p2.birth_year = 1985;
    ```
*   **Доступ к полям:** Через оператор `.` для объектов и `->` для указателей.
    ```cpp
    Person person;
    Person* ptr = &person;
    std::cout << person.name;
    std::cout << ptr->birth_year;
    std::cout << (*ptr).name; // Эквивалентно ptr->name
    ```
*   **Размер в памяти:** Сумма размеров всех полей + возможное выравнивание (padding) для эффективного доступа процессора к данным. Компилятор может добавлять "пустые" байты между полями.

##### **4.3. Объединения (union)**

*   **Назначение:** Тип, позволяющий хранить в одной области памяти данные разных типов, но только один из них в каждый момент времени. Экономия памяти.
*   **Синтаксис:**
    ```cpp
    union Value {
        int i;
        double d;
        char c;
    };
    ```
*   **Размер:** Размер равен размеру самого большого поля.
*   **Особенности:** Изменение одного поля перезаписывает другие. Читать можно только то поле, в которое было записано. Отсутствие type safety.
*   **Практическое применение:** Часто используется в паре с `enum` ("tagged union"), который указывает, какое поле активно в данный момент.
    ```cpp
    struct TaggedValue {
        enum { INT, DOUBLE, CHAR } tag;
        union {
            int i;
            double d;
            char c;
        };
    };
    ```

#### **5. Дополнительные возможности функций**

*   **Псевдонимы типов (typedef / using):**
    *   **`typedef`:** `typedef std::vector<int> IntVec;` (устаревший, но рабочий).
    *   **`using` (C++11):** `using IntVec = std::vector<int>;` — более современный и гибкий синтаксис.
*   **Аргументы по умолчанию:**
    ```cpp
    void print(std::string message, std::string end = "\n") {
        std::cout << message << end;
    }
    print("Hello"); // Использует "\n"
    print("Hello", "!"); // Использует "!"
    ```
    *   **Важно:** Параметры по умолчанию должны идти последними в списке.
*   **Перегрузка функций (Function Overloading):**
    *   Определение нескольких функций с одним именем, но разными типами или количеством параметров.
    *   Компилятор выбирает нужную версию на основе переданных аргументов.
    ```cpp
    void print(int x) { ... }
    void print(double x) { ... }
    void print(const std::string& s) { ... }
    ```
*   **Указатели на функции:**
    *   Позволяют передавать функции как аргументы другим функциям (callback-и).
    *   **Синтаксис:**
        ```cpp
        // Тип: функция, принимающая double и возвращающая double
        double (*func_ptr)(double) = &square;
        double result = func_ptr(5.0);
        ```
    *   **Псевдоним для удобства:**
        ```cpp
        using MathFunc = double (*)(double);
        void apply_function(double* arr, int size, MathFunc func) { ... }
        ```
    *   **Современная альтернатива:** `std::function` (более гибкий) и лямбда-выражения.

#### **6. Устаревшие/редкие особенности (Знать, но использовать с осторожностью)**

*   **Неопределенное количество аргументов (C-style variadic functions):**
    *   Используется `...`. Крайне небезопасно, нет информации о типах и количестве аргументов.
    *   **Современная альтернатива:** Шаблоны с variadic templates (`template<typename... Args>`) и `std::initializer_list`.
*   **Inline-функции:**
    *   `inline` — это *просьба* к компилятору вставить код функции вместо вызова. ЭтоHint для оптимизации.
    *   Современные компиляторы часто сами принимают решение о встраивании, независимо от этого ключевого слова.
    *   Основное современное применение — определение функций в заголовочных файлах (чavoid multiple definition errors).

#### **7. Итог и рекомендации**

*   Используйте `struct` для группировки логически связанных данных.
*   Для ограниченного набора значений используйте `enum class` вместо "простого" `enum`.
*   `union` — мощный, но опасный инструмент. Применяйте его в крайних случаях, обычно в низкоуровневом программировании или для оптимизации памяти в очень специфичных scenarios. Всегда используйте с "tag"-ом.
*   Для создания понятных и кратких имен типов используйте `using`.
*   Предпочитайте современные конструкции (`nullptr`, `enum class`, uniform initialization `{}`) устаревшим.
*   Указатели на функции — важная концепция, но в современном C++ часто заменяются лямбдами и `std::function`.