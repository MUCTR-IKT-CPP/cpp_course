# Лекция 8: Шаблоны в C++

## План лекции:
- Введение в шаблоны
- Пример перегрузки функций
- Шаблонные функции
- Использование auto для шаблонов
- Шаблонные функции с собственными классами
- Специализация шаблонов
- Шаблонные классы
- Разделение шаблонов на файлы
- Дополнительные аргументы шаблонов
- Ограничения шаблонов
- Критика шаблонов
- Практические рекомендации по использованию шаблонов

## Введение в шаблоны

**Шаблоны** (templates) — это мощный механизм языка C++, позволяющий писать код, который работает с различными типами данных без дублирования кода. Шаблоны являются основой обобщенного программирования в C++.

**Матерь Божья, ну зачем вот это все?** — задаете вы справедливый вопрос. Шаблоны решают проблему повторяющегося кода при работе с разными типами данных. Вместо того чтобы писать отдельные функции или классы для каждого типа данных, мы можем написать один шаблон, который будет работать со всеми подходящими типами.

## Пример перегрузки

Рассмотрим простую задачу: найти максимальное значение из двух аргументов. Без шаблонов пришлось бы писать множество перегрузок для каждого типа данных:

```cpp
const int& maximum(const int& a, const int& b) {
    return a > b ? a : b;
}

const double& maximum(const double& a, const double& b) {
    return a > b ? a : b;
}

const char& maximum(const char& a, char& b) {
    return a > b ? a : b;
}

int main() {
    int i = maximum(13, 10);
    cout << i << endl; // 13
    double d = maximum(0.97, 1.76);
    cout << d << endl; // 1.76
    char s = maximum('a', '1');
    cout << s << endl; // a
}
```

Как видно, мы повторяем один и тот же код для разных типов. Это неэффективно и увеличивает вероятность ошибок.

## Шаблонные функции

Шаблонные функции позволяют определить функцию один раз для нескольких типов данных. Синтаксис шаблонной функции:

```cpp
template<typename T>
const T& maximum(const T& a, const T& b) {
    return a > b ? a : b;
}

int main() {
    int i = maximum(13, 10);
    cout << i << endl; // 13
    double d = maximum(0.97, 1.76);
    cout << d << endl; // 1.76
    char s = maximum('a', '1');
    cout << s << endl; // a
}
```

Ключевое слово `template` объявляет шаблон, а параметр `typename T` определяет шаблонный параметр. Компилятор автоматически подставит нужный тип при вызове функции.

**Важно:** Компилятор генерирует специфическую версию функции для каждого типа, с которым она вызывается. Это происходит во время компиляции, поэтому шаблоны не влияют на производительность во время выполнения.

**Дополнительная информация:** Существует альтернативный синтаксис `template<class T>`, который работает точно так же, как `template<typename T>`. Слово `class` здесь не означает, что шаблон работает только с классами — он работает с любыми типами данных.

## Использование auto для шаблонов

Начиная с C++14, можно использовать ключевое слово `auto` в параметрах шаблона, что упрощает синтаксис:

```cpp
const auto& maximum(const auto& a, const auto& b) {
    return a > b ? a : b;
}

int main() {
    int i = maximum(13, 10);
    cout << i << endl; // 13
    double d = maximum(0.97, 1.76);
    cout << d << endl; // 1.76
    char s = maximum('a', '1');
    cout << s << endl; // a
}
```

Такой подход появился после стандарта C++11. По сути, вся задача по перегрузке функции ложится на компилятор, и функция может быть перегружена только в том случае, если тип имеет соответствующие операции сравнения.

**Важное отличие:** Отличие шаблонов от функций с `auto` в том, что в шаблоне мы требуем, чтобы аргументы функции были одного типа, и возвращаемое значение было этого же типа. Тогда как `auto` не предполагает никакого требования к вызову такой функции, почему и считается менее строгим в некоторых случаях.

## Шаблонные функции с собственными классами

Шаблоны работают не только с фундаментальными типами, но и с пользовательскими классами. Однако для этого класс должен поддерживать необходимые операции (в нашем случае оператор `>`):

```cpp
class MyCombinedString {
private:
    string s;
public:
    MyCombinedString(string s) : s(s) {}
    friend bool operator>(const MyCombinedString& msa, const MyCombinedString& msb);
    friend ostream& operator<<(ostream& out, const MyCombinedString& ms);
};

bool operator>(const MyCombinedString& msa, const MyCombinedString& msb) {
    return msa.s.length() > msb.s.length();
}

ostream& operator<<(ostream& out, const MyCombinedString& ms) {
    return out << ms.s;
}

int main() {
    MyCombinedString ms1("Hello");
    MyCombinedString ms2("World!");
    MyCombinedString ms = maximum(ms1, ms2);
    cout << ms << endl; // World!
}
```

В этом примере мы определили оператор `>` для сравнения строк по длине, что позволяет использовать наш класс с шаблонной функцией `maximum`.

## Специализация шаблонов

В некоторых случаях шаблон функции может быть неэффективным или неправильным для определенного типа. В этом случае можно специализировать шаблон — написать отдельную реализацию для данного типа:

```cpp
template<typename T>
const T& maximum(const T& a, const T& b) {
    return a > b ? a : b;
}

// Специализация для строк
template<>
const string& maximum(const string& a, const string& b) {
    return a.length() > b.length() ? a : b;
}

int main() {
    int i = maximum(13, 10);
    cout << i << endl; // 13
    double d = maximum(0.97, 1.76);
    cout << d << endl; // 1.76
    char s = maximum('a', '1');
    cout << s << endl; // a
    string ms = maximum(string("11.1234"), string("12"));
    cout << ms << endl; // 11.1234
}
```

Здесь мы переопределили поведение функции `maximum` для строк, сравнивая их по длине, а не лексикографически.

## Шаблонные классы

Шаблоны не ограничиваются функциями — можно создавать шаблонные классы, которые работают с разными типами данных:

```cpp
template<typename T, int SIZE>
class Array {
private:
    T* container = nullptr;
public:
    Array(T nuller = 0) : container(new T[SIZE]) {
        for(int i = 0; i < SIZE; i++)
            container[i] = nuller;
    }
    
    T& operator[](int i) {
        return container[i];
    }
    
    int getLen() {
        return SIZE;
    }
    
    ~Array() {
        delete[] container;
    }
    
    friend ostream& operator<<(ostream& out, const Array<T>& arr) {
        out << "[ ";
        for(int i = 0; i < SIZE; i++)
            out << arr.container[i] << " ";
        out << "]";
        return out;
    }
};

int main() {
    srand(time(0));
    Array<int, 10> first;
    Array<int, 5> second;
    Array<double, 6> third(0.5);
    
    for(int i = 0; i < second.getLen(); i++)
        second[i] = rand() % 100;
    
    cout << first << endl; // [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    cout << second << endl; // [ 45, 78, 71, 67, 30]
    cout << third << endl; // [ 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
}
```

Этот пример демонстрирует шаблонный класс `Array`, который может работать с любым типом данных и имеет фиксированный размер, заданный как шаблонный параметр.

**Важное замечание:** Шаблонные классы объявляются при помощи ключевого слова `template`. Далее следуют угловые скобки `<>`, между которыми через запятую указываются параметры шаблона. После идет стандартное описание класса, в котором для каких-либо целей могут использоваться параметры шаблона.

## Разделение шаблонов на файлы

Для организации больших программ со значительным количеством классов и большими размерами этих классов, является логичным желание разбить программу на несколько файлов. Шаблоны так же можно выносить в отдельные от основной функции файлы, но у них существует ряд ограничений.

**Первый способ:** Шаблон можно вынести в h-файл из файла с функцией main или с тем местом, где он используется, ничего не меняя в этом классе. Это является стандартным способом отделения шаблона от кода.

**Второй способ:** Можно пойти дальше и выразить желание разбить шаблон на файлы h и cpp. Это желание столкнется с рядом проблем:

1. Сначала, требуется в каждом вынесенном методе использовать приставку `template<typename T>`.

```cpp
// Array.h
template<typename T>
class Array {
private:
    T* container = nullptr;
    int length;
public:
    Array(int len = 10, T nuller = 0);
    int getLen();
    T& operator[](int i);
    ~Array();
    friend ostream& operator<<(ostream& out, const Array<T>& arr);
};

// Array.cpp
#include "Array.h"

template<typename T>
Array<T>::Array(int len, T nuller) : length(len), container(new T[length]) {
    for(int i = 0; i < length; i++)
        container[i] = nuller;
}

template<typename T>
int Array<T>::getLen() {
    return length;
}

// ... остальные методы
```

2. При таком разделении на этапе линковки возникнут проблемы, так как компилятор не сгенерирует конкретные реализации шаблона.

**Решение проблемы:** Для решения этой проблемы потребуется в конце cpp-файла с реализацией указать компилятору, какие варианты шаблонов под какие типы нужно сгенерировать.

```cpp
// В конце Array.cpp
template class Array<int>;
template class Array<double>;
template ostream& operator<<(ostream& out, const Array<int>& arr);
template ostream& operator<<(ostream& out, const Array<double>& arr);
```

**Причина происходящего:** При разбиении на 2 cpp-файла, компилятор при компиляции файла с реализацией шаблонного класса не генерирует все варианты шаблонов. Тогда как к моменту компиляции файла с main-функцией нет ни одного варианта скомпилированного шаблона, и при этом нет самого шаблона. Поэтому возникает ошибка связывания при вызове любой функции шаблонного класса.

## Дополнительные аргументы шаблонов

Аргументы шаблонов могут быть не только типами, но и конкретными значениями какого-либо типа. Однако есть существенные ограничения:

- В роли параметров шаблонов могут выступать целочисленные константы (включая перечисления) или указатели на объекты с внешним связыванием.
- Использование чисел с плавающей точкой и объектов с типом класса в качестве параметров шаблона недопускается.

Пример шаблона с целочисленным параметром:

```cpp
template<typename T, int SIZE>
class Array {
private:
    T* container = nullptr;
public:
    Array(T nuller = 0) : container(new T[SIZE]) {
        for(int i = 0; i < SIZE; i++)
            container[i] = nuller;
    }
    
    T& operator[](int i) {
        return container[i];
    }
    
    ~Array() {
        delete[] container;
    }
};

int main() {
    Array<int, 10> intArray;
    intArray[0] = 5;
    cout << intArray[0] << endl; // 5
    
    Array<double, 5> doubleArray(1.5);
    cout << doubleArray[2] << endl; // 1.5
}
```

Это позволяет создавать контейнеры с фиксированным размером, известным на этапе компиляции.

## Ограничения шаблонов

Шаблоны имеют некоторые ограничения:

1. **Типы шаблонных параметров**:
   - Можно использовать типы данных (class, typename)
   - Можно использовать целочисленные константы
   - Нельзя использовать числа с плавающей точкой в качестве параметров шаблона
   - Нельзя использовать объекты с типом класса в качестве параметров шаблона

2. **Реализация шаблонов**:
   - Обычно шаблоны реализуются в заголовочных файлах (.h, .hpp), так как компилятору нужно видеть полное определение шаблона для генерации кода
   - Вынос шаблонов в отдельные .cpp файлы требует дополнительных действий для правильной компиляции

Пример ограничения:

```cpp
// Это допустимо
template<typename T, int SIZE> class Array { /* ... */ };

// Это НЕ допустимо
template<typename T, double FACTOR> class Array { /* ... */ };
```

## Критика шаблонов

Было бы глупо отрицать проблемы шаблонов, которые существуют. Вот основные из них:

1. **Проблема переноса на другие платформы**:
   - Разные компиляторы могут по-разному обрабатывать сложные шаблоны
   - Некоторые компиляторы могут не поддерживать последние стандарты C++

2. **Проблема поддержки и отладки**:
   - Ошибки в шаблонах часто приводят к длинным и сложным сообщениям об ошибках
   - Отладка шаблонного кода может быть сложной, особенно при глубокой вложенности

3. **Проблема ввода/вывода в процессе спецификации шаблона**:
   - Трудности с отладочной информацией и выводом промежуточных результатов

4. **Увеличение времени компиляции**:
   - Большое количество шаблонов может значительно увеличить время компиляции
   - Каждая специализация шаблона генерирует новый код

5. **Снижение читабельности кода**:
   - Сложные шаблоны могут сделать код менее понятным для новых разработчиков

6. **Проблемы диагностики ошибок**:
   - Сообщения об ошибках в шаблонах часто имеют сомнительный формат и трудны для понимания

7. **Проблема проверки аргументов шаблона**:
   - До C++20 отсутствовали удобные механизмы для проверки корректности аргументов шаблона
   - Эта проблема была решена при помощи концептов в C++20

## Практические рекомендации по использованию шаблонов

1. **Используйте шаблоны, когда это действительно необходимо**:
   - Не применяйте шаблоны "просто так" — они добавляют сложность
   - Используйте шаблоны, когда есть повторяющийся код для разных типов

2. **Документируйте шаблоны**:
   - Шаблоны могут быть сложны для понимания
   - Хорошая документация помогает другим разработчикам

3. **Тестируйте шаблоны с разными типами**:
   - Убедитесь, что ваш шаблон работает со всеми предполагаемыми типами
   - Проверьте крайние случаи

4. **Используйте concepts (начиная с C++20)**:
   - Concepts позволяют явно указать требования к типам шаблона
   - Это упрощает отладку и делает код более понятным

Пример использования concepts:

```cpp
template<typename T>
concept Comparable = requires(T a, T b) {
    { a > b } -> std::convertible_to<bool>;
};

template<Comparable T>
const T& maximum(const T& a, const T& b) {
    return a > b ? a : b;
}
```

5. **Разделяйте интерфейс и реализацию**:
   - Для сложных шаблонов используйте разделение на объявление и определение
   - Помещайте сложные реализации в отдельные файлы с расширением .tpp

6. **Рассмотрите возможность использования явной специализации**:
   - Для критически важных типов создайте специализированные версии шаблона
   - Это может улучшить производительность для конкретных случаев

## Заключение

Шаблоны — мощный инструмент обобщенного программирования в C++. Они позволяют писать гибкий и многократно используемый код, но требуют осторожного применения из-за своей сложности.

Основные преимущества шаблонов:
- Устранение дублирования кода
- Типовая безопасность
- Возможность создания универсальных алгоритмов и структур данных

Помните, что шаблоны — это инструмент, и как любой инструмент, они должны применяться правильно и в подходящих ситуациях. Не пытайтесь решить все проблемы с помощью шаблонов — иногда проще и эффективнее написать специфический код для конкретной задачи.

### Дополнительные материалы
# Дополнения к Лекции 8: Шаблоны в C++

## Расширенный пример шаблонного класса

### Реализация метода объединения массивов

В шаблонном классе можно реализовать метод для объединения двух массивов, что демонстрирует работу с несколькими экземплярами шаблонного класса:

```cpp
template<typename T>
class Array {
private:
    T* container = nullptr;
    int length;
public:
    Array(int len = 10, T nuller = 0) : length(len), container(new T[length]) {
        for(int i = 0; i < length; i++)
            container[i] = nuller;
    }
    
    void unite(Array& second) {
        T* result = new T[length + second.length];
        int k = 0;
        for(int i = 0; i < length; i++) {
            result[k++] = container[i];
        }
        for(int i = 0; i < second.length; i++)
            result[k++] = second[i];
        delete[] container;
        container = result;
        length += second.length;
    }
    
    // Остальные методы...
};
```

Этот метод создает новый массив, копирует в него элементы текущего массива и второго массива, затем освобождает память текущего массива и обновляет указатель и длину.

### Итераторы в шаблонных классах

Шаблонные классы могут содержать собственные шаблонные итераторы, что позволяет использовать их с алгоритмами STL:

```cpp
template<typename T>
class Array {
private:
    T* container = nullptr;
    int length;
public:
    // Вложенный класс-итератор
    class Iterator {
    private:
        Array<T>* container;
        int index;
    public:
        Iterator(int index, Array<T>* container) 
            : container(container), index(index > container->length ? -1 : index) {}
        
        Iterator& operator++() {
            if(index != container->length)
                index++;
            else
                index = -1;
            return *this;
        }
        
        T& operator*() {
            return (*container)[index];
        }
        
        bool operator!=(const Iterator& it) {
            return it.index != index;
        }
    };
    
    Iterator begin() {
        return Iterator(0, this);
    }
    
    Iterator end() {
        return Iterator(length, this);
    }
    
    // Остальные методы...
};
```

Этот итератор позволяет использовать цикл range-based for с нашим шаблонным классом:

```cpp
Array<int, 5> arr;
for(int i = 0; i < 5; i++) {
    arr[i] = i * 10;
}

for(auto& value : arr) {
    cout << value << " "; // 0 10 20 30 40
}
```

### Перегрузка операторов для шаблонных классов

Важно правильно перегружать операторы для шаблонных классов, особенно оператор вывода:

```cpp
template<typename T>
ostream& operator<<(ostream& out, const Array<T>& arr) {
    out << "[";
    for(int i = 0; i < arr.length; i++) {
        if(i != arr.length - 1)
            out << arr.container[i] << ", ";
        else
            out << arr.container[i];
    }
    out << "]";
    return out;
}
```

**Важное замечание:** При перегрузке операторов для шаблонных классов часто требуется сделать оператор дружественной функцией шаблонного класса. Также важно отметить, что для константных объектов необходимо принимать константную ссылку.

## Метапрограммирование с шаблонами

**Метапрограммирование** — это вид программирования, связанный с созданием программ, которые порождают другие программы как результат своей работы. При этом подходе код программы не пишется вручную, а создаётся автоматически программой-генератором на основе другой программы.

Шаблоны C++ позволяют реализовать метапрограммирование на этапе компиляции. Например, вычисление факториала на этапе компиляции:

```cpp
template<int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

int main() {
    cout << Factorial<5>::value << endl; // 120
    cout << Factorial<10>::value << endl; // 3628800
}
```

Компилятор генерирует специфические версии шаблона для каждого значения N, что позволяет выполнять вычисления во время компиляции, а не во время выполнения программы.

## Расширенная критика шаблонов

### Проблема ввода/вывода в процессе спецификации шаблона

При работе со сложными шаблонами возникают трудности с отладочной информацией и выводом промежуточных результатов. Поскольку большая часть обработки шаблонов происходит на этапе компиляции, стандартные методы отладки (точки останова, пошаговое выполнение) часто не работают.

### Снижение читабельности кода

Сложные шаблоны, особенно с использованием продвинутых техник (SFINAE, шаблоны шаблонов, рекурсивные шаблоны), могут значительно снизить читабельность кода. Например:

```cpp
template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
void process(T value) {
    // Обработка целочисленных значений
}

template<typename T, typename = std::enable_if_t<std::is_floating_point_v<T>>>
void process(T value) {
    // Обработка чисел с плавающей точкой
}
```

### Проблемы диагностики ошибок

Сообщения об ошибках в шаблонах часто имеют сомнительный формат и трудны для понимания. Например, ошибка в глубоко вложенном шаблоне может привести к длинному сообщению, где сложно определить источник проблемы:

```
error: no matching function for call to 'maximum(std::string, std::string)'
note: candidate template ignored: substitution failure [with T = std::string]: 
      no viable conversion from 'const char [2]' to 'std::string'
```

### Проблема проверки аргументов шаблона

До появления концептов в C++20 не было простого способа проверить, удовлетворяет ли тип требованиям шаблона. Это приводило к запутанным сообщениям об ошибках и сложной отладке. Концепты решают эту проблему, но не все компиляторы полностью их поддерживают.

## Рекомендации по отладке шаблонного кода

1. **Используйте ступенчатый подход**:
   - Сначала реализуйте функционал для конкретного типа
   - Затем обобщите его до шаблона
   - Постепенно добавляйте сложность

2. **Создавайте тестовые специализации**:
   ```cpp
   // Сначала проверяем с конкретным типом
   template class Array<int>;
   template class Array<std::string>;
   ```

3. **Используйте статические утверждения**:
   ```cpp
   template<typename T>
   void process(T value) {
       static_assert(std::is_integral<T>::value, "T must be an integral type");
       // ...
   }
   ```

4. **Разделяйте сложные шаблоны на более простые части**:
   - Используйте вспомогательные шаблоны
   - Выносите часть логики в обычные функции

5. **Используйте современные инструменты**:
   - Компиляторы с улучшенной диагностикой (Clang часто предоставляет более понятные сообщения, чем GCC)
   - Специализированные инструменты для анализа шаблонов

## Взаимодействие шаблонов с указателями и ссылками

Шаблоны прекрасно работают с указателями и ссылками, что позволяет создавать универсальные функции для работы с различными типами данных:

```cpp
template<typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int a = 5, b = 10;
    swap(a, b); // Работает с обычными переменными
    
    int* pa = &a;
    int* pb = &b;
    swap(pa, pb); // Работает с указателями
    
    int& ra = a;
    int& rb = b;
    swap(ra, rb); // Работает со ссылками
}
```

Однако при работе с указателями на шаблонные типы могут возникнуть сложности:

```cpp
template<typename T>
class Container {
    // ...
};

// Как объявить указатель на шаблонный класс?
Container<int>* ptr; // Правильно
Container* ptr2;    // Ошибка - не указан параметр шаблона
```

## Продвинутые техники шаблонного метапрограммирования

### Условная компиляция с enable_if

```cpp
#include <type_traits>

// Функция работает только с целочисленными типами
template<typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
process(T value) {
    return value * 2;
}

// Функция работает только с плавающей точкой
template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, T>::type
process(T value) {
    return value / 2.0;
}
```

### Шаблоны шаблонов

```cpp
template<template<typename> class Container, typename T>
void printContainer(const Container<T>& container) {
    for(const auto& item : container) {
        cout << item << " ";
    }
    cout << endl;
}

int main() {
    vector<int> vec = {1, 2, 3};
    list<double> lst = {1.1, 2.2, 3.3};
    
    printContainer(vec); // Работает с vector
    printContainer(lst); // Работает с list
}
```

### Рекурсивные шаблоны

```cpp
// Вычисление суммы элементов кортежа
template<size_t Index = 0, typename... Args>
typename std::enable_if<Index == sizeof...(Args), void>::type
sumTuple(const std::tuple<Args...>& t, int& result) {
    // Базовый случай рекурсии
}

template<size_t Index = 0, typename... Args>
typename std::enable_if<Index < sizeof...(Args), void>::type
sumTuple(const std::tuple<Args...>& t, int& result) {
    result += std::get<Index>(t);
    sumTuple<Index + 1, Args...>(t, result);
}

int main() {
    auto t = std::make_tuple(1, 2, 3, 4, 5);
    int sum = 0;
    sumTuple(t, sum);
    cout << sum << endl; // 15
}
```

## Шаблоны в стандартной библиотеке C++

Шаблоны широко используются в стандартной библиотеке C++:

1. **Контейнеры**: vector, list, map, set и т.д.
2. **Алгоритмы**: sort, find, transform и т.д.
3. **Итераторы**: различные категории итераторов
4. **Функторы и адаптеры**: bind, function, mem_fn и т.д.
5. **Умные указатели**: unique_ptr, shared_ptr

Пример использования алгоритмов STL с пользовательскими типами:

```cpp
class Person {
    string name;
    int age;
public:
    Person(string n, int a) : name(n), age(a) {}
    string getName() const { return name; }
    int getAge() const { return age; }
    
    friend bool operator<(const Person& p1, const Person& p2) {
        return p1.age < p2.age;
    }
};

int main() {
    vector<Person> people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35}
    };
    
    // Сортировка с использованием шаблонного алгоритма
    sort(people.begin(), people.end());
    
    // Использование шаблонного алгоритма transform
    vector<string> names(people.size());
    transform(people.begin(), people.end(), names.begin(),
        [](const Person& p) { return p.getName(); });
}
```

## Влияние шаблонов на производительность

Шаблоны могут как улучшить, так и ухудшить производительность:

**Плюсы:**
- Устранение накладных расходов при вызове функций (инлайнинг)
- Оптимизация на этапе компиляции
- Возможность создания специализированных реализаций для конкретных типов

**Минусы:**
- Увеличение размера исполняемого файла из-за генерации кода для каждого типа
- Возможное увеличение времени компиляции
- Сложность оптимизации компилятором в случае очень сложных шаблонов

Пример сравнения шаблонной и обычной функции:

```cpp
// Шаблонная функция
template<typename T>
T add(T a, T b) {
    return a + b;
}

// Обычная функция
int add_int(int a, int b) {
    return a + b;
}

int main() {
    // Компилятор может инлайнить шаблонную функцию
    int result1 = add(5, 10);
    
    // Вызов обычной функции требует перехода
    int result2 = add_int(5, 10);
}
```

В этом случае шаблонная функция может работать быстрее, так как компилятор может инлайнить ее вызовы, устраняя накладные расходы на вызов функции.

## Заключение по дополнениям

Шаблоны в C++ — это мощный инструмент, который позволяет создавать гибкий и эффективный код. Однако, как и любой мощный инструмент, они требуют понимания их особенностей и ограничений. Следуя лучшим практикам и понимая потенциальные проблемы, можно эффективно использовать шаблоны для создания качественного и поддерживаемого кода.

Помните: "С great power comes great responsibility" — с великой силой приходит великая ответственность. Используйте шаблоны разумно и только там, где они действительно необходимы.


Отличный вопрос! Лекция получилась хорошей и покрывает основы. Я бы дополнил её следующими разделами и концепциями, которые критически важны для понимания и эффективного использования шаблонов в современном C++.

Вот план дополнений, оформленный в том же стиле:

---

### План дополнений к лекции:

12. Параметры шаблона по умолчанию
13. Шаблонные методы внутри нетemplate-классов
14. Передача шаблонных функций в алгоритмы (указатели на функции, std::function)
15. Перегрузка шаблонных функций
16. Вариативные шаблоны (C++11)
17. Спецификаторы `decltype` и `auto` для возвращаемого значения
18. trailing return type (C++11)
19. Концепты (Concepts) (C++20)
20. Практические рекомендации и идиомы (CRTP, Type Traits)

---

### 12. Параметры шаблона по умолчанию

Как и у функций, у параметров шаблона могут быть значения по умолчанию. Это работает как для типов, так и для нетиповых параметров.

```cpp
// Тип по умолчанию - int, значение по умолчанию - 100
template <typename T = int, int SIZE = 100>
class Buffer {
private:
    T data[SIZE];
public:
    // ...
};

int main() {
    Buffer<> buffer1;          // Buffer<int, 100>
    Buffer<float> buffer2;     // Buffer<float, 100>
    Buffer<double, 500> buffer3; // Buffer<double, 500>
}
```

Это особенно полезно в шаблонах классов, где можно задавать стратегии управления памятью, компараторы и т.д. по умолчанию.

---

### 13. Шаблонные методы внутри нетemplate-классов

Отдельные методы обычного класса можно делать шаблонными. Это позволяет сохранить общность метода, не делая шаблонным весь класс.

```cpp
class Printer {
public:
    // Шаблонный метод внутри обычного класса
    template <typename T>
    void print(const T& value) {
        std::cout << "Value: " << value << std::endl;
    }
};

int main() {
    Printer p;
    p.print(42);        // Вызов print<int>
    p.print(3.14);      // Вызов print<double>
    p.print("hello");   // Вызов print<const char*>
}
```

---

### 14. Передача шаблонных функций в алгоритмы

Шаблонные функции можно передавать в алгоритмы STL. Для этого часто используют указатели на функции или лямбды.

```cpp
template <typename T>
bool greaterThan(const T& a, const T& b) {
    return a > b;
}

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 9};
    
    // Явное указание типа шаблона
    std::sort(vec.begin(), vec.end(), greaterThan<int>);
    
    // Использование лямбды (чаще более удобно)
    std::sort(vec.begin(), vec.end(), [](auto a, auto b) {
        return a > b;
    });
}
```

---

### 15. Перегрузка шаблонных функций

Шаблонные функции можно перегружать, как и обычные. Компилятор выбирает наиболее специализированную версию.

```cpp
template <typename T>
void process(T value) {
    std::cout << "Generic template: " << value << std::endl;
}

template <typename T>
void process(T* pointer) { // Перегрузка для указателей
    std::cout << "Pointer template: " << *pointer << std::endl;
}

void process(int value) { // Обычная функция (не шаблон)
    std::cout << "Non-template int: " << value << std::endl;
}

int main() {
    int x = 10;
    process(x);    // Вызовет non-template версию
    process(&x);   // Вызовет pointer template версию
    process(3.14); // Вызовет generic template версию
}
```

---

### 16. Вариативные шаблоны (C++11)

Вариативные шаблоны позволяют работать с произвольным количеством параметров. Это основа современного метапрограммирования в C++.

```cpp
#include <iostream>

// Базовый случай рекурсии
void print() {
    std::cout << std::endl;
}

// Рекурсивный шаблон
template <typename First, typename... Rest>
void print(First first, Rest... rest) {
    std::cout << first << " ";
    print(rest...); // Рекурсивный вызов
}

int main() {
    print(1, 2.5, "hello", 'a'); // 1 2.5 hello a 
}
```

---

### 17. Спецификаторы `decltype` и `auto` для возвращаемого значения

`decltype` позволяет определить тип выражения на этапе компиляции. Полезно, когда тип возвращаемого значения сложно указать явно.

```cpp
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    auto result1 = add(1, 2.5);    // decltype(1 + 2.5) → double
    auto result2 = add(1, 2);       // decltype(1 + 2) → int
}
```

---

### 18. Trailing return type (C++11)

Синтаксис с указанием возвращаемого типа после списка параметров. Особенно полезен в шаблонах.

```cpp
template <typename Container>
auto getFirstElement(Container& cont) -> decltype(cont[0]) {
    return cont[0];
}

int main() {
    std::vector<int> vec = {1, 2, 3};
    auto& first = getFirstElement(vec); // int&
}
```

---

### 19. Концепты (Concepts) (C++20)

**Концепты** — это революционное нововведение C++20, которое решает главные проблемы шаблонов: непонятные ошибки и требования к типам.

```cpp
#include <concepts>

// Концепт, проверяющий, что тип имеет метод size()
template <typename T>
concept HasSize = requires(T t) {
    t.size();
};

// Функция работает только с типами, удовлетворяющими концепту HasSize
template <HasSize Container>
void printSize(const Container& cont) {
    std::cout << "Size: " << cont.size() << std::endl;
}

// Альтернативный синтаксис
template <typename Container>
requires HasSize<Container>
void printSize2(const Container& cont) {
    std::cout << "Size: " << cont.size() << std::endl;
}

// Ещё один синтаксис
template <typename Container>
void printSize3(const Container& cont) requires HasSize<Container> {
    std::cout << "Size: " << cont.size() << std::endl;
}
```

**Преимущества концептов:**
- Читаемые ошибки компиляции
- Явные требования к типам
- Более clean code

---

### 20. Практические рекомендации и идиомы

#### Type Traits (Черты типа)
Позволяют получать информацию о типах на этапе компиляции.

```cpp
#include <type_traits>

template <typename T>
void process(T value) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Integer type: " << value << std::endl;
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "Floating type: " << value << std::endl;
    } else {
        std::cout << "Other type: " << value << std::endl;
    }
}
```

#### CRTP (Curiously Recurring Template Pattern)
Идиома, когда класс наследуется от шаблонной базы, параметризованной самим классом-наследником.

```cpp
template <typename Derived>
class Base {
public:
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
};

class Derived : public Base<Derived> {
public:
    void implementation() {
        std::cout << "Derived implementation" << std::endl;
    }
};
```

---

### Заключение

Шаблоны в C++ — это мощнейший инструмент метапрограммирования, который эволюционировал от простых обобщённых функций до сложных систем compile-time вычислений. Современный C++ (особенно с стандартами 11/14/17/20) делает работу с шаблонами всё более безопасной и удобной.

**Ключевые тренды:**
- Использование `auto` и `decltype` для вывода типов
- Концепты для явных ограничений
- Вариативные шаблоны для работы с произвольными наборами параметров
- Компиляционные вычисления (constexpr)

Освоение этих инструментов открывает путь к написанию эффективного, обобщённого и безопасного кода на C++.

Спасибо за внимание!
```