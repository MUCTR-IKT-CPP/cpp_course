# Лекция 9: Лямбда функции и алгоритмы в C++

## План лекции:
- Введение в стандартную библиотеку C++
- Пять основных компонентов STL
- Библиотека алгоритмов
  - Методы сортировки коллекции
  - Работа с отсортированными коллекциями
  - Методы перебора всех элементов
  - Методы манипуляции элементами
- Лямбда-функции
- Использование лямбда-функций с алгоритмами
- Практические примеры
- Рекомендации по использованию алгоритмов
- Сравнение с традиционными циклами
- Дополнительные возможности C++20

## Введение в стандартную библиотеку C++

**Стандартная библиотека C++** — это набор классов и функций, написанных на языке C++, которые поставляются вместе с компилятором. Она предоставляет широкий спектр возможностей для разработки программ:

- Работу со строками
- Ввод-вывод данных
- Управление памятью
- Многопоточность
- Контейнеры и алгоритмы
- И многое другое

**Стандартная библиотека шаблонов (STL)** — это подмножество стандартной библиотеки C++, которое предоставляет шаблонные классы и функции для работы с данными. STL является одной из самых мощных и часто используемых частей стандартной библиотеки.

**Дополнительная информация:** Стандартная библиотека C++ продолжает развиваться с каждым новым стандартом языка (C++11, C++14, C++17, C++20 и т.д.). Каждый новый стандарт добавляет новые функции и улучшает существующие, делая библиотеку более мощной и удобной в использовании.

## Пять основных компонентов STL

В стандартной библиотеке шаблонов выделяют пять основных компонентов:

1. **Контейнер (container)** — структура данных, хранящая коллекцию объектов определенного типа (например, `vector`, `list`, `map`).

2. **Итератор (iterator)** — объект, предоставляющий доступ к элементам контейнера и позволяющий перемещаться по ним.

3. **Алгоритмы (algorithm)** — набор функций для обработки данных в контейнерах (например, сортировка, поиск, преобразование).

4. **Адаптеры (adaptor)** — компоненты, изменяющие интерфейс существующих контейнеров или итераторов (например, `stack`, `queue`).

5. **Функциональные объекты (functor)** — объекты, которые могут быть вызваны как функции (включая лямбда-выражения).

**Дополнительная информация:** Эти компоненты тесно связаны между собой и предназначены для совместного использования. Алгоритмы STL работают с контейнерами через итераторы, используя функциональные объекты для выполнения конкретных операций. Эта модульная структура позволяет легко комбинировать различные компоненты для решения сложных задач.

## Библиотека алгоритмов

Библиотека алгоритмов STL предоставляет широкий набор функций для работы с контейнерами и другими последовательностями данных. Все алгоритмы работают через итераторы, что делает их независимыми от конкретного типа контейнера.

### Методы сортировки коллекции

- `sort` — сортировка последовательности
- `stable_sort` — стабильная сортировка (сохраняет относительный порядок эквивалентных элементов)
- `partial_sort` — частичная сортировка (сортирует первые N элементов)
- `partial_sort_copy` — частичная сортировка с копированием
- `nth_element` — размещает N-ый элемент на его окончательной позиции, все элементы перед ним меньше, а после — больше

**Пример использования:**
```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 9, 3};
    
    // Полная сортировка
    std::sort(vec.begin(), vec.end());
    // vec = {1, 2, 3, 5, 8, 9}
    
    // Частичная сортировка первых 3 элементов
    std::partial_sort(vec.begin(), vec.begin() + 3, vec.end());
    // vec = {1, 2, 3, 5, 8, 9}
    
    // Стабильная сортировка
    std::stable_sort(vec.begin(), vec.end());
    
    return 0;
}
```

### Работа с отсортированными коллекциями

- `binary_search` — бинарный поиск элемента
- `lower_bound` — поиск первого не меньшего элемента
- `upper_bound` — поиск первого большего элемента
- `merge` — объединение отсортированных последовательностей
- `inplace_merge` — объединение последовательностей на месте
- `includes` — проверка, включает ли одна последовательность другую
- `min` — минимальное значение
- `max` — максимальное значение
- `min_element` — минимальный элемент
- `max_element` — максимальный элемент

**Пример использования:**
```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // Бинарный поиск
    bool found = std::binary_search(vec.begin(), vec.end(), 5);
    
    // Поиск границ
    auto lower = std::lower_bound(vec.begin(), vec.end(), 5);
    auto upper = std::upper_bound(vec.begin(), vec.end(), 5);
    
    // Минимальный и максимальный элементы
    auto min_el = std::min_element(vec.begin(), vec.end());
    auto max_el = std::max_element(vec.begin(), vec.end());
    
    std::cout << "Min: " << *min_el << ", Max: " << *max_el << std::endl;
    
    return 0;
}
```

### Методы перебора всех элементов коллекции и их обработки

- `count` — подсчет элементов по значению
- `count_if` — подсчет по условию
- `find` — поиск по значению
- `find_if` — поиск по условию
- `adjacent_find` — поиск одинаковых соседних пар
- `for_each` — перебор всех элементов и применение функции
- `mismatch` — поиск первого различающегося элемента
- `equal` — сравнение на равенство последовательностей

**Пример использования:**
```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 2, 3, 4};
    
    // Подсчет элементов
    int count_two = std::count(vec.begin(), vec.end(), 2);
    
    // Подсчет по условию
    int count_even = std::count_if(vec.begin(), vec.end(), 
        [](int x) { return x % 2 == 0; });
    
    // Поиск элемента
    auto pos = std::find(vec.begin(), vec.end(), 3);
    
    // Поиск по условию
    auto pos_odd = std::find_if(vec.begin(), vec.end(), 
        [](int x) { return x % 2 != 0; });
    
    // Применение функции ко всем элементам
    std::for_each(vec.begin(), vec.end(), 
        [](int& x) { x *= 2; });
    
    return 0;
}
```

### Методы манипуляции элементами коллекции

- `replace` — замена одного значения на другое
- `replace_if` — замена по условию
- `transform` — преобразование каждого элемента
- `remove` — удаление элемента по значению
- `remove_if` — удаление элементов по условию
- `remove_copy` — копирование элементов с игнорированием по значению
- `remove_copy_if` — копирование с игнорированием по условию
- `unique` — получение уникальной последовательности
- `unique_copy` — копирование только уникальных значений
- `reverse` — инверсия последовательности
- `reverse_copy` — копирование обратной последовательности
- `rotate` — поворот последовательности
- `rotate_copy` — поворот последовательности с копированием
- `random_shuffle` — перемешивание последовательности
- `partition` — разбиение на диапазоны по условию

**Пример использования:**
```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    std::vector<int> result(vec.size());
    
    // Замена значений
    std::replace(vec.begin(), vec.end(), 3, 30);
    
    // Замена по условию
    std::replace_if(vec.begin(), vec.end(), 
        [](int x) { return x % 2 == 0; }, 0);
    
    // Преобразование элементов
    std::transform(vec.begin(), vec.end(), result.begin(), 
        [](int x) { return x * 2; });
    
    // Удаление элементов
    auto new_end = std::remove(vec.begin(), vec.end(), 5);
    vec.erase(new_end, vec.end());
    
    // Удаление по условию
    new_end = std::remove_if(vec.begin(), vec.end(), 
        [](int x) { return x > 7; });
    vec.erase(new_end, vec.end());
    
    // Получение уникальных элементов
    std::sort(vec.begin(), vec.end());
    new_end = std::unique(vec.begin(), vec.end());
    vec.erase(new_end, vec.end());
    
    // Перемешивание
    std::random_shuffle(vec.begin(), vec.end());
    
    return 0;
}
```

**Важное замечание:** Многие алгоритмы, такие как `remove`, `unique` и другие, не уменьшают размер контейнера, а просто перемещают элементы. Для фактического удаления элементов необходимо вызвать метод `erase` контейнера.

## Лямбда-функции

**Лямбда-функция** (или лямбда-выражение) — это анонимная функция, которая может быть определена прямо в месте использования. Лямбда-функции были добавлены в C++11 и значительно упростили использование алгоритмов STL.

Синтаксис лямбда-выражения:
```
[capture](parameters) -> return_type { function_body }
```

- **Захват (capture)** — определяет, какие переменные из окружающей области видимости будут доступны внутри лямбды
- **Параметры (parameters)** — список параметров, аналогичный функции
- **Возвращаемый тип (return_type)** — необязательный, компилятор может вывести его автоматически
- **Тело функции (function_body)** — код, который будет выполнен при вызове лямбды

**Примеры лямбда-выражений:**

```cpp
// Простая лямбда без параметров
auto hello = []() { std::cout << "Hello, world!" << std::endl; };
hello();

// Лямбда с параметрами
auto sum = [](int a, int b) { return a + b; };
std::cout << sum(3, 4) << std::endl; // 7

// Лямбда с захватом переменных по значению
int x = 10;
auto add_x = [x](int y) { return x + y; };
std::cout << add_x(5) << std::endl; // 15

// Лямбда с захватом переменных по ссылке
int z = 20;
auto add_to_z = [&z](int y) { z += y; };
add_to_z(5);
std::cout << z << std::endl; // 25

// Лямбда с явным указанием возвращаемого типа
auto divide = [](double a, double b) -> double {
    if (b == 0) return 0;
    return a / b;
};
```

### Захват переменных

Лямбда-выражения могут захватывать переменные из окружающей области видимости:

- `[x]` — захват переменной `x` по значению
- `[&x]` — захват переменной `x` по ссылке
- `[=]` — захват всех используемых переменных по значению
- `[&]` — захват всех используемых переменных по ссылке
- `[this]` — захват текущего объекта (внутри методов класса)
- `[=, &x]` — захват всех переменных по значению, кроме `x`, которая захватывается по ссылке
- `[&, x]` — захват всех переменных по ссылке, кроме `x`, которая захватывается по значению

**Пример захвата:**

```cpp
int a = 10;
int b = 20;

// Захват a по значению, b по ссылке
auto lambda = [a, &b]() {
    std::cout << "a = " << a << ", b = " << b << std::endl;
    b = 30; // Изменение b повлияет на исходную переменную
};

a = 15; // Не повлияет на значение a внутри лямбды
b = 25; // Повлияет на значение b внутри лямбды

lambda(); // a = 10, b = 25
std::cout << "b = " << b << std::endl; // b = 30
```

### Мутабельные лямбды

По умолчанию переменные, захваченные по значению, являются константными внутри лямбды. Чтобы изменить их, нужно использовать ключевое слово `mutable`:

```cpp
int x = 10;
auto lambda = [x]() mutable {
    x = 20; // Теперь это допустимо
    std::cout << "x = " << x << std::endl;
};

lambda(); // x = 20
std::cout << "Original x = " << x << std::endl; // Original x = 10
```

**Важное замечание:** Даже с `mutable` исходная переменная `x` не изменяется — внутри лямбды создается ее копия, которую можно изменять.

## Использование лямбда-функций с алгоритмами

Лямбда-функции идеально подходят для использования с алгоритмами STL, так как позволяют определять поведение прямо в месте вызова алгоритма.

### Примеры использования лямбд с алгоритмами

**Сортировка с пользовательским компаратором:**

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

struct Person {
    std::string name;
    int age;
};

int main() {
    std::vector<Person> people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
        {"Diana", 28}
    };
    
    // Сортировка по возрасту
    std::sort(people.begin(), people.end(), 
        [](const Person& a, const Person& b) {
            return a.age < b.age;
        });
    
    // Сортировка по имени в обратном порядке
    std::sort(people.begin(), people.end(), 
        [](const Person& a, const Person& b) {
            return a.name > b.name;
        });
    
    return 0;
}
```

**Фильтрация с использованием `remove_if` и лямбды:**

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Удаление четных чисел
    auto new_end = std::remove_if(numbers.begin(), numbers.end(),
        [](int x) { return x % 2 == 0; });
    
    numbers.erase(new_end, numbers.end());
    
    // numbers = {1, 3, 5, 7, 9}
    
    return 0;
}
```

**Преобразование с использованием `transform`:**

```cpp
#include <algorithm>
#include <vector>
#include <iostream>
#include <string>

int main() {
    std::vector<std::string> words = {"hello", "world", "cpp", "lambda"};
    std::vector<int> lengths(words.size());
    
    // Получение длины каждой строки
    std::transform(words.begin(), words.end(), lengths.begin(),
        [](const std::string& s) { return s.length(); });
    
    // lengths = {5, 5, 3, 6}
    
    return 0;
}
```

**Поиск с использованием `find_if`:**

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

struct Person {
    std::string name;
    int age;
};

int main() {
    std::vector<Person> people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
        {"Diana", 28}
    };
    
    // Поиск первого человека старше 30
    auto it = std::find_if(people.begin(), people.end(),
        [](const Person& p) { return p.age > 30; });
    
    if (it != people.end()) {
        std::cout << "Found: " << it->name << ", " << it->age << std::endl;
    }
    
    return 0;
}
```

**Подсчет с использованием `count_if`:**

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Подсчет четных чисел
    int even_count = std::count_if(numbers.begin(), numbers.end(),
        [](int x) { return x % 2 == 0; });
    
    std::cout << "Even numbers: " << even_count << std::endl; // 5
    
    return 0;
}
```

**Применение действий ко всем элементам с использованием `for_each`:**

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // Удвоение каждого элемента
    std::for_each(numbers.begin(), numbers.end(),
        [](int& x) { x *= 2; });
    
    // numbers = {2, 4, 6, 8, 10}
    
    // Вывод элементов
    std::for_each(numbers.begin(), numbers.end(),
        [](int x) { std::cout << x << " "; });
    std::cout << std::endl;
    
    return 0;
}
```

## Практические рекомендации по использованию алгоритмов

1. **Используйте алгоритмы вместо циклов `for`**:
   - Алгоритмы STL более выразительны и понятны
   - Они оптимизированы и часто работают быстрее, чем написанные вручную циклы
   - Они уменьшают вероятность ошибок (например, выход за границы массива)

2. **Избегайте ручной реализации стандартных алгоритмов**:
   - Не пишите свою сортировку, если можно использовать `std::sort`
   - Не реализуйте поиск, если можно использовать `std::find` или `std::binary_search`

3. **Используйте лямбда-выражения для краткости и ясности**:
   - Лямбды позволяют определить поведение прямо в месте использования
   - Они делают код более компактным и понятным

4. **Помните о сложности алгоритмов**:
   - `std::sort` имеет сложность O(n log n)
   - `std::binary_search` имеет сложность O(log n)
   - `std::find` имеет сложность O(n)

5. **Используйте правильные алгоритмы для конкретной задачи**:
   - Для поиска в отсортированном контейнере используйте `std::binary_search`, а не `std::find`
   - Для подсчета элементов используйте `std::count` или `std::count_if`, а не цикл с подсчетом

## Сравнение с традиционными циклами

**Пример 1: Поиск элемента**

*Традиционный цикл:*
```cpp
int find_value(const std::vector<int>& vec, int value) {
    for (size_t i = 0; i < vec.size(); ++i) {
        if (vec[i] == value) {
            return i;
        }
    }
    return -1;
}
```

*С использованием алгоритма:*
```cpp
auto it = std::find(vec.begin(), vec.end(), value);
if (it != vec.end()) {
    return std::distance(vec.begin(), it);
}
return -1;
```

**Пример 2: Фильтрация элементов**

*Традиционный цикл:*
```cpp
std::vector<int> filter_even(const std::vector<int>& vec) {
    std::vector<int> result;
    for (size_t i = 0; i < vec.size(); ++i) {
        if (vec[i] % 2 == 0) {
            result.push_back(vec[i]);
        }
    }
    return result;
}
```

*С использованием алгоритмов:*
```cpp
std::vector<int> filter_even(const std::vector<int>& vec) {
    std::vector<int> result;
    std::copy_if(vec.begin(), vec.end(), std::back_inserter(result),
        [](int x) { return x % 2 == 0; });
    return result;
}
```

**Пример 3: Преобразование элементов**

*Традиционный цикл:*
```cpp
std::vector<int> double_elements(const std::vector<int>& vec) {
    std::vector<int> result(vec.size());
    for (size_t i = 0; i < vec.size(); ++i) {
        result[i] = vec[i] * 2;
    }
    return result;
}
```

*С использованием алгоритма:*
```cpp
std::vector<int> double_elements(const std::vector<int>& vec) {
    std::vector<int> result(vec.size());
    std::transform(vec.begin(), vec.end(), result.begin(),
        [](int x) { return x * 2; });
    return result;
}
```

**Преимущества использования алгоритмов:**
- Более высокий уровень абстракции
- Меньше вероятность ошибок
- Лучшая читаемость кода
- Возможность оптимизации компилятором
- Единообразный стиль кода

## Дополнительные возможности C++20

Начиная с C++20, библиотека алгоритмов получила ряд улучшений:

### Диапазоны (Ranges)

C++20 вводит концепцию диапазонов, которые упрощают работу с алгоритмами:

```cpp
#include <algorithm>
#include <vector>
#include <iostream>
#include <ranges>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 9, 3};
    
    // Сортировка с использованием диапазонов
    std::ranges::sort(vec);
    
    // Фильтрация и преобразование
    auto result = vec 
        | std::views::filter([](int x) { return x % 2 == 0; })
        | std::views::transform([](int x) { return x * 2; });
    
    for (int x : result) {
        std::cout << x << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### Параллельные алгоритмы

C++17 добавил поддержку параллельных версий алгоритмов:

```cpp
#include <algorithm>
#include <vector>
#include <execution>

int main() {
    std::vector<int> vec(1000000);
    // Заполнение вектора
    
    // Параллельная сортировка
    std::sort(std::execution::par, vec.begin(), vec.end());
    
    // Параллельный подсчет
    int even_count = std::count_if(std::execution::par, 
        vec.begin(), vec.end(), 
        [](int x) { return x % 2 == 0; });
    
    return 0;
}
```

### Улучшенные лямбда-выражения

C++20 добавил несколько улучшений для лямбда-выражений:

```cpp
// Лямбда с шаблонными параметрами (C++20)
auto print = []<typename T>(const T& value) {
    std::cout << value << std::endl;
};

print(42);      // Выведет 42
print(3.14);    // Выведет 3.14
print("Hello"); // Выведет Hello

// Лямбда с концептами (C++20)
auto add = []<std::integral T>(T a, T b) {
    return a + b;
};
```

## Рекомендации по использованию ресурсов

Для изучения и использования алгоритмов STL рекомендуется использовать следующие ресурсы:

1. **cppreference.com** — подробная документация по всем элементам стандартной библиотеки C++ с примерами кода.

2. **En.cppreference.com** — английская версия того же ресурса, которая обычно более полная и актуальная.

3. **Стандартные учебники по C++** — книги Бjarne Stroustrup, Скотта Майерса и других авторитетных экспертов.

4. **Онлайн-курсы и видео** — множество качественных материалов по STL и современным возможностям C++.

**Важно:** При использовании алгоритмов STL всегда проверяйте документацию, чтобы понимать их сложность, требования к итераторам и возможные побочные эффекты.

## Заключение

Лямбда-функции и алгоритмы STL являются мощными инструментами, которые значительно упрощают написание кода на C++. Они позволяют писать более выразительный, безопасный и эффективный код, избегая распространенных ошибок, связанных с ручной реализацией базовых операций.

Основные преимущества использования алгоритмов STL и лямбда-функций:
- Повышение читаемости кода
- Снижение вероятности ошибок
- Улучшение производительности (благодаря оптимизациям в стандартной библиотеке)
- Возможность использования современных возможностей C++ (параллельные алгоритмы, диапазоны и т.д.)

Помните, что эффективное использование этих инструментов требует понимания их работы и особенностей. Всегда проверяйте документацию и учитывайте сложность алгоритмов при выборе подходящего решения для вашей задачи.

Альтернатива:
Отлично! Я изучил предоставленную презентацию по лямбда-функциям и алгоритмам в C++. На её основе я создал развернутый Markdown-файл, дополнив его новым и уточняющим материалом.

```markdown
# Лекция 9: Лямбда-функции и алгоритмы STL

### План лекции:

1.  Стандартная библиотека C++ (обзор)
2.  Библиотека алгоритмов STL
3.  Предикаты и функциональные объекты (функторы)
4.  Лямбда-выражения
    4.1. Синтаксис и части лямбда-выражения
    4.2. Захват переменных
    4.3. Список параметров и возвращаемый тип
    4.4. Ключевое слово `mutable`
5.  Примеры использования алгоритмов с лямбдами
6.  Генерация случайных чисел в современном C++ (`<random>`)
7.  Создание универсальных функций с помощью шаблонов и лямбд
8.  Примеры с сортировками: `sort` vs `stable_sort`
9.  Дополнительные алгоритмы и практические примеры
10. Рекомендации по использованию

---

### 1. Стандартная библиотека C++ (обзор)

**Стандартная библиотека C++** — это коллекция классов и функций, написанных на самом языке C++, которые предоставляют базовую функциональность для выполнения различных задач.

**Основные компоненты:**
- **Containers library** — контейнеры данных (`vector`, `list`, `map`, etc.)
- **Iterators library** — итераторы для работы с контейнерами
- **Algorithms library** — алгоритмы для работы с данными (`sort`, `find`, `transform`, etc.)
- **Input/output library** — ввод/вывод (`iostream`, `fstream`)
- **Strings library** — работа со строками (`string`)
- **Numerics library** — математические операции (`cmath`, `complex`)
- **Thread support library** — многопоточность (`thread`, `mutex`)
- **Regular expressions library** — регулярные выражения (`regex`)
- **Atomic operations library** — атомарные операции (`atomic`)
- **и многие другие...**

**STL (Standard Template Library)** — это подмножество стандартной библиотеки, включающее контейнеры, алгоритмы, итераторы и функциональные объекты.

---

### 2. Библиотека алгоритмов STL

Алгоритмы STL — это обобщенные функции, работающие с диапазонами элементов через итераторы. Они не зависят от конкретного типа контейнера.

**Категории алгоритмов:**
- **Немодифицирующие:** `find`, `count`, `equal`, `for_each`
- **Модифицирующие:** `copy`, `transform`, `replace`, `fill`
- **Сортировки и related:** `sort`, `stable_sort`, `partial_sort`, `nth_element`
- **Бинарный поиск:** `binary_search`, `lower_bound`, `upper_bound`
- **Операции с множествами:** `set_union`, `set_intersection`, `set_difference`
- **Куча:** `make_heap`, `push_heap`, `pop_heap`
- **Перестановки:** `next_permutation`, `prev_permutation`

> **Важно:** Все алгоритмы объявлены в заголовочном файле `<algorithm>`. Для использования бинарного поиска и операций с множествами последовательность должна быть отсортирована.

---

### 3. Предикаты и функциональные объекты (функторы)

**Предикат** — это функция, возвращающая `bool`. Часто используется в алгоритмах для задания условий поиска, сортировки и т.д.
- **Унарный предикат** — принимает один аргумент (например, `is_positive(int x)`)
- **Бинарный предикат** — принимает два аргумента (например, `compare(int a, int b)`)

**Функтор (Functional Object)** — это объект класса, у которого перегружен оператор `()`. Позволяет хранить состояние между вызовами.

```cpp
// Бинарный предикат как функция
bool compareMyInt(MyInt& a, MyInt& b) {
    return a.getValue() > b.getValue();
}

// Функтор (объект с состоянием)
class CompareMyIntFunctor {
    int calls = 0;
public:
    bool operator()(MyInt& a, MyInt& b) {
        calls++;
        return a.getValue() > b.getValue();
    }
    int getCalls() const { return calls; }
};

int main() {
    vector<MyInt> v = {...};
    CompareMyIntFunctor functor;
    sort(v.begin(), v.end(), functor); // Используем функтор
    cout << "Comparisons made: " << functor.getCalls() << endl;
}
```

---

### 4. Лямбда-выражения

**Лямбда-выражение** — это краткая форма записи анонимного функционального объекта. Позволяет определить функцию прямо в месте её использования.

#### 4.1. Общий синтаксис

```cpp
[ capture ] ( params ) mutable exception attr -> ret { body }
```

Упрощенные формы:
```cpp
[ capture ] ( params ) -> ret { body }
[ capture ] ( params ) { body }
[ capture ] { body }
```

#### 4.2. Захват переменных (Capture clause)

Лямбда может "захватывать" переменные из окружающей области видимости для использования внутри тела.

- `[]` — ничего не захватывает.
- `[=]` — захватывает все переменные по значению.
- `[&]` — захватывает все переменные по ссылке.
- `[x, &y]` — захватывает `x` по значению, `y` по ссылке.
- `[this]` — захватывает указатель `this` текущего объекта.
- `[=, &x]` — захватывает все по значению, но `x` по ссылке.
- `[&, x]` — захватывает все по ссылке, но `x` по значению.

> **Важно в C++14+:** Можно использовать инициализирующий захват: `[x = expr]` или `[&ref = expr]`, что позволяет создавать и захватывать новые переменные.

#### 4.3. Список параметров и возвращаемый тип

Список параметров как у обычной функции. Возвращаемый тип можно указать явно с помощью `-> type`. Если тип не указан, он выводится автоматически из `return`-выражений (если они есть и согласованы по типу).

```cpp
// Явное указание возвращаемого типа
auto lambda = [](int a, int b) -> double {
    return (a + b) / 2.0;
};

// Возвращаемый тип выводится как int
auto lambda2 = [](int a) { return a * 2; };
```

#### 4.4. Ключевое слово `mutable`

По умолчанию оператор `()` лямбды, захватившей переменные по значению, является `const`. Это значит, что нельзя изменять захваченные по значению переменные. Ключевое слово `mutable` убирает `const`-квалификатор.

```cpp
int counter = 0;
// Без mutable: ошибка компиляции при попытке изменить counter
auto lambda = [counter]() mutable {
    counter++; // Теперь можно, но изменяется копия
    std::cout << counter << std::endl;
};
lambda(); // 1
lambda(); // 2
std::cout << counter << std::endl; // 0 (оригинал не изменился)
```

---

### 5. Примеры использования алгоритмов с лямбдами

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {5, -2, 13, -7, 0, 4, -1, 8};

    // 1. Подсчет положительных чисел
    int positives = std::count_if(vec.begin(), vec.end(),
        [](int x) { return x > 0; });
    std::cout << "Positives: " << positives << std::endl;

    // 2. Преобразование всех отрицательных чисел в положительные
    std::for_each(vec.begin(), vec.end(),
        [](int &x) { if (x < 0) x = -x; });

    // 3. Сортировка по убыванию с помощью лямбды
    std::sort(vec.begin(), vec.end(),
        [](int a, int b) { return a > b; });

    // 4. Вывод вектора
    std::for_each(vec.begin(), vec.end(),
        [](int x) { std::cout << x << " "; });
    std::cout << std::endl;

    return 0;
}
// Вывод:
// Positives: 4
// 13 8 5 4 2 1 0 0
```

---

### 6. Генерация случайных чисел в современном C++ (`<random>`)

Вместо устаревшего `rand()` и `srand()` из C рекомендуется использовать `<random>`.

**Компоненты:**
1.  **Генератор (Engine):** Создает случайные биты. Примеры: `std::mt19937`, `std::default_random_engine`.
2.  **Распределение (Distribution):** Преобразует выход генератора в нужное распределение. Примеры: `std::uniform_int_distribution`, `std::normal_distribution`.
3.  **Источник энтропии (Seed):** `std::random_device` для получения настоящих случайных чисел (если доступно).

```cpp
#include <random>
#include <vector>

std::vector<int> generate_random_ints(int count, int min, int max) {
    std::random_device rd; // Источник энтропии для инициализации
    std::mt19937 gen(rd()); // Генератор Mersenne Twister
    std::uniform_int_distribution<int> dist(min, max); // Равномерное распределение

    std::vector<int> result;
    for (int i = 0; i < count; ++i) {
        result.push_back(dist(gen));
    }
    return result;
}
```

**Преимущества перед `rand()`:**
- Лучшее качество случайности.
- Контроль над распределением (равномерное, нормальное, пуассоновское и др.).
- Независимые генераторы для разных частей программы.
- Предсказуемость и воспроизводимость (если использовать фиксированный seed).

---

### 7. Создание универсальных функций с помощью шаблонов и лямбд

Можно комбинировать шаблоны и лямбды для создания мощных и универсальных утилит.

```cpp
#include <algorithm>
#include <iterator>
#include <iostream>
#include <vector>
#include <list>

// Шаблонная функция для фильтрации контейнера
template <typename Container, typename Predicate>
Container filter(const Container& c, Predicate pred) {
    Container result;
    std::copy_if(std::begin(c), std::end(c),
                 std::back_inserter(result),
                 pred);
    return result;
}

// Шаблонная функция для вывода любого контейнера
template <typename Container>
void print_container(const Container& c, const std::string& name = "") {
    if (!name.empty()) {
        std::cout << name << ": ";
    }
    std::for_each(std::begin(c), std::end(c),
        [](const auto& elem) { std::cout << elem << " "; });
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, -2, 3, -4, 5, -6};

    // Фильтруем только положительные числа
    auto positives = filter(vec, [](int x) { return x > 0; });
    print_container(positives, "Positives");

    // Фильтруем только четные числа
    auto evens = filter(vec, [](int x) { return x % 2 == 0; });
    print_container(evens, "Evens");

    return 0;
}
// Вывод:
// Positives: 1 3 5
// Evens: -2 -4 -6
```

---

### 8. Примеры с сортировками: `sort` vs `stable_sort`

- **`std::sort`** — выполняет нестабильную сортировку. Не гарантирует сохранение относительного порядка равных элементов. Обычно быстрее.
- **`std::stable_sort`** — выполняет стабильную сортировку. Гарантирует, что равные элементы останутся в том же порядке, что и до сортировки. Может требовать больше памяти.

```cpp
#include <algorithm>
#include <vector>
#include <utility> // для std::pair

using namespace std;

int main() {
    // Вектор пар (значение, исходный индекс)
    vector<pair<int, int>> data = {
        {5, 0}, {2, 1}, {5, 2}, {1, 3}, {2, 4}
    };

    auto data_for_stable = data; // Копия для stable_sort

    // Обычная сортировка по значению
    sort(data.begin(), data.end(),
        [](const auto& a, const auto& b) { return a.first < b.first; });

    // Стабильная сортировка по значению
    stable_sort(data_for_stable.begin(), data_for_stable.end(),
        [](const auto& a, const auto& b) { return a.first < b.first; });

    cout << "After sort (value, original index):" << endl;
    for (const auto& p : data) {
        cout << "(" << p.first << ", " << p.second << ") ";
    }
    cout << endl << "After stable_sort (value, original index):" << endl;
    for (const auto& p : data_for_stable) {
        cout << "(" << p.first << ", " << p.second << ") ";
    }
    return 0;
}
// Возможный вывод:
// After sort: (1,3) (2,4) (2,1) (5,2) (5,0) // Порядок равных 2 и 5 не сохранен
// After stable_sort: (1,3) (2,1) (2,4) (5,0) (5,2) // Порядок равных сохранен
```
*В выводе `sort` порядок пар с value=2 ((2,1) и (2,4)) и value=5 ((5,0) и (5,2)) может быть произвольным. `stable_sort` гарантирует, что (2,1) будет перед (2,4), а (5,0) перед (5,2), так как они так и шли в исходной последовательности.*

---

### 9. Дополнительные алгоритмы и практические примеры

#### `std::transform` — применение функции к каждому элементу

```cpp
#include <vector>
#include <algorithm>
#include <cmath>

std::vector<double> values = {0, M_PI/4, M_PI/2};
std::vector<double> sines(values.size());

// Вычисляем синусы для каждого угла
std::transform(values.begin(), values.end(), sines.begin(),
    [](double angle) { return std::sin(angle); });
// sines: {0, ~0.707, 1}
```

#### `std::generate` — заполнение с помощью генератора

```cpp
std::vector<int> random_ints(10);
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<int> dist(1, 100);

// Заполняем вектор случайными числами
std::generate(random_ints.begin(), random_ints.end(),
    [&]() { return dist(gen); }); // Захватываем dist и gen по ссылке
```

#### Удаление элементов по условию (Erase–remove idiom)

Алгоритмы `remove` и `remove_if` не изменяют размер контейнера! Они только сдвигают элементы и возвращают итератор на новый логический конец.

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 6};

// Удаляем все четные числа
auto new_end = std::remove_if(vec.begin(), vec.end(),
    [](int x) { return x % 2 == 0; });
// vec сейчас: {1, 3, 5, 4, 5, 6}, new_end указывает на элемент после 5

// Теперь физически удаляем элементы из контейнера
vec.erase(new_end, vec.end());
// vec теперь: {1, 3, 5}
```

---

### 10. Рекомендации по использованию

1.  **Предпочитайте алгоритмы STL ручным циклам.** Это делает код более выразительным, менее подверженным ошибкам (off-by-one) и часто более эффективным.
2.  **Используйте лямбды для коротких операций,** которые используются в одном месте. Для сложной или многоразовой логики лучше использовать именованные функции или функторы.
3.  **Будьте осторожны с захватом по ссылке (`[&]`).** Убедитесь, что время жизни захваченных переменных превышает время жизни лямбды. Избегайте захвата по ссылке временных объектов или локальных переменных, которые скоро выйдут из области видимости.
4.  **Для простых предикатов и компараторов** используйте лямбды. Для сложных состояний или многократного использования考虑 функторы.
5.  **Используйте `std::function`** только если нужна возможность переназначения или если сигнатура лямбды неизвестна на этапе компиляции. В остальных случаях `auto` предпочтительнее.
6.  **Помните об `mutable`**, если нужно изменять захваченные по значению переменные.
7.  **Изучите `<algorithm>`.** Знание доступных алгоритмов сэкономит вам кучу времени и усилий.

Спасибо за внимание!
```