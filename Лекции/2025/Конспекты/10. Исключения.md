# Лекция 10: Обработка исключений в C++

## План лекции:
- Введение в обработку исключений
- Определение исключений
- Типы исключений
- Механизм обработки исключений в C++
- Синтаксис try-catch
- Оператор throw
- Блоки с гарантией завершения (finally)
- Иерархия стандартных исключений
- Создание пользовательских исключений
- Практические рекомендации и лучшие практики
- Сравнение с альтернативными подходами
- Дополнительные возможности C++17/20
- Расширенные техники обработки исключений

## Введение в обработку исключений

**Обработка исключений** — это механизм языков программирования, предназначенный для описания реакции программы на ошибки времени выполнения и другие возможные проблемы (исключения), которые могут возникнуть при выполнении программы и приводят к невозможности (бессмысленности) дальнейшей отработки программой её базового алгоритма.

**Дополнительная информация:** Обработка исключений позволяет отделить код, отвечающий за нормальное выполнение программы, от кода, обрабатывающего ошибки. Это улучшает читаемость, поддерживаемость и структуру кода. В отличие от традиционных методов обработки ошибок (коды возврата, глобальные переменные), исключения обеспечивают:
- Автоматическое распространение ошибки по стеку вызовов
- Четкое разделение кода обработки ошибок
- Возможность обработки ошибок в том месте, где есть информация для их обработки
- Гарантию выполнения критически важных операций (например, освобождение ресурсов)

## Определение исключений

**Исключительная ситуация** — это состояние программы, при котором дальнейшие вычисления в соответствии с базовым алгоритмом становятся невозможными или бессмысленными.

Примеры исключений:
- Целочисленное деление на ноль
- Ошибка при попытке считать данные с внешнего устройства
- Исчерпание доступной памяти
- Появление сигнала аварийного отключения электропитания системы
- Обращение к несуществующей памяти (выход за границы массива)
- Ошибка работы с базой данных
- Ошибка при работе с сетью
- Ошибка преобразования указателя

**Дополнительная информация:** Исключения не следует использовать для управления нормальным ходом программы. Они предназначены для обработки действительно исключительных ситуаций, которые нарушают нормальный ход выполнения программы. Например, не следует использовать исключения для обработки ожидаемых условий (например, неправильный ввод пользователя), так как это может значительно снизить производительность и усложнить чтение кода.

## Типы исключений

Исключительные ситуации можно разделить на два основных типа:

1. **Синхронные исключения** — возникают как прямой результат выполнения определенной инструкции программы:
   - Деление на ноль
   - Выход за границы массива
   - Нарушение условий контракта
   - Ошибки при выполнении операций с памятью

2. **Асинхронные исключения** — возникают независимо от выполнения конкретной инструкции:
   - Сигналы операционной системы (SIGINT, SIGTERM)
   - Прерывания от оборудования
   - Аварийное отключение питания
   - Сетевые сбои

**Дополнительная информация:** В C++ основное внимание уделяется обработке синхронных исключений. Асинхронные исключения обычно обрабатываются с помощью механизмов, специфичных для операционной системы (например, обработчики сигналов в Unix-системах).

## Механизм обработки исключений в C++

В C++ используется механизм обработки исключений, основанный на трех ключевых элементах:
- `try` — определяет блок кода, в котором могут возникнуть исключения
- `catch` — определяет блок кода, который обрабатывает исключения определенного типа
- `throw` — используется для генерации (выброса) исключения

**Принцип работы:**
1. Когда возникает исключительная ситуация, программа генерирует исключение с помощью оператора `throw`
2. Программа ищет подходящий блок `catch`, который может обработать это исключение
3. Если подходящий блок найден, управление передается в этот блок
4. Если подходящий блок не найден, программа завершается с необработанным исключением

**Дополнительная информация:** Когда исключение генерируется, происходит "раскрутка стека" (stack unwinding) — программа последовательно проверяет каждый уровень стека вызовов на наличие обработчика исключений. При этом автоматически вызываются деструкторы локальных объектов, что обеспечивает корректное освобождение ресурсов.

## Синтаксис try-catch

Базовый синтаксис обработки исключений в C++:

```cpp
try {
    // Код, который может вызвать исключение
} 
catch (тип_исключения1 параметр) {
    // Обработка исключения первого типа
}
catch (тип_исключения2 параметр) {
    // Обработка исключения второго типа
}
// Другие блоки catch...
```

**Пример:**

```cpp
#include <iostream>
#include <stdexcept>

int main() {
    try {
        int a = 10;
        int b = 0;
        
        if (b == 0) {
            throw std::runtime_error("Деление на ноль!");
        }
        
        int c = a / b;
        std::cout << "Результат: " << c << std::endl;
    }
    catch (const std::runtime_error& e) {
        std::cerr << "Ошибка времени выполнения: " << e.what() << std::endl;
    }
    catch (const std::exception& e) {
        std::cerr << "Общая ошибка: " << e.what() << std::endl;
    }
    catch (...) {
        std::cerr << "Неизвестная ошибка" << std::endl;
    }
    
    return 0;
}
```

**Важные моменты:**
- Блок `try` должен иметь хотя бы один блок `catch`
- Блоки `catch` обрабатывают исключения по порядку сверху вниз
- Блок `catch (...)` обрабатывает любые исключения (но не предоставляет доступ к объекту исключения)
- Исключения фундаментальных типов (int, char, double) могут быть пойманы по значению, но исключения классов должны быть пойманы по константной ссылке, чтобы избежать ненужного копирования

**Дополнительная информация:** Начиная с C++17, можно использовать объявление переменной в блоке catch:

```cpp
catch (const std::exception& e = *std::current_exception()) {
    // Обработка исключения
}
```

Также в C++17 добавлена возможность использования инициализаторов в блоках catch:

```cpp
catch (const std::exception& e; auto log = create_logger()) {
    log.error(e.what());
}
```

## Оператор throw

Оператор `throw` используется для генерации (выброса) исключения:

```cpp
throw выражение;
```

**Примеры:**

```cpp
throw -1;  // генерация исключения типа int
throw "Невозможно извлечь корень из отрицательного числа";  // генерация строки
throw std::out_of_range("Индекс вне диапазона");  // генерация стандартного исключения
```

**Дополнительная информация:**
- Выражение после `throw` может быть любого типа (фундаментального, класса, указателя)
- Обычно рекомендуется использовать объекты классов, производных от `std::exception`
- Можно повторно выбросить текущее исключение с помощью `throw;` без аргументов
- Начиная с C++11, можно использовать `noexcept` для указания, что функция не генерирует исключений

**Пример повторного выброса:**

```cpp
try {
    // ...
}
catch (const std::exception& e) {
    // Логирование ошибки
    std::cerr << "Ошибка: " << e.what() << std::endl;
    
    // Повторный выброс
    throw;
}
```

## Блоки с гарантией завершения

**Блок с гарантированным завершением** — это блок кода, который выполняется независимо от того, произошла ошибка или нет. В C++ аналогом такого блока является деструктор объекта, реализующего шаблон проектирования RAII (Resource Acquisition Is Initialization).

**Пример использования RAII вместо finally:**

```cpp
class FileGuard {
private:
    FILE* file;
public:
    FileGuard(const char* filename, const char* mode) {
        file = fopen(filename, mode);
        if (!file) {
            throw std::runtime_error("Не удалось открыть файл");
        }
    }
    
    ~FileGuard() {
        if (file) {
            fclose(file);
        }
    }
    
    FILE* get() { return file; }
};

void process_file() {
    FileGuard guard("data.txt", "r");
    
    // Работа с файлом
    // ...
    
    // Файл будет автоматически закрыт при выходе из функции,
    // даже если произойдет исключение
}
```

**Дополнительная информация:** В отличие от некоторых других языков (Java, C#), в C++ нет специального блока `finally`. Вместо этого используется шаблон RAII, который гарантирует освобождение ресурсов через деструкторы объектов. Это более мощный и гибкий механизм, который интегрируется с системой управления памятью C++.

## Иерархия стандартных исключений

Стандартная библиотека C++ предоставляет иерархию классов исключений, производных от базового класса `std::exception`:

```
std::exception
├── std::logic_error
│   ├── std::domain_error
│   ├── std::invalid_argument
│   ├── std::length_error
│   └── std::out_of_range
└── std::runtime_error
    ├── std::range_error
    ├── std::overflow_error
    ├── std::underflow_error
    └── std::system_error (C++11)
        └── std::ios_base::failure (C++11)
```

**Основные классы:**
- `std::exception` — базовый класс для всех стандартных исключений
- `std::logic_error` — исключения, обнаруживаемые на этапе компиляции или логические ошибки
- `std::runtime_error` — исключения, возникающие во время выполнения программы

**Пример использования стандартных исключений:**

```cpp
#include <stdexcept>
#include <vector>
#include <iostream>

int main() {
    try {
        std::vector<int> vec;
        
        // Попытка доступа к элементу вне диапазона
        int value = vec.at(10);
    }
    catch (const std::out_of_range& e) {
        std::cerr << "Ошибка диапазона: " << e.what() << std::endl;
    }
    catch (const std::exception& e) {
        std::cerr << "Общая ошибка: " << e.what() << std::endl;
    }
    
    return 0;
}
```

**Дополнительная информация:** Все стандартные исключения предоставляют метод `what()`, который возвращает строку с описанием ошибки. При создании собственных исключений рекомендуется наследоваться от соответствующих стандартных классов и переопределять метод `what()`.

## Создание пользовательских исключений

Для создания собственных исключений рекомендуется наследоваться от стандартных классов исключений:

```cpp
#include <stdexcept>
#include <string>

class MyException : public std::runtime_error {
private:
    int error_code;
public:
    MyException(const std::string& message, int code) 
        : std::runtime_error(message), error_code(code) {}
    
    int get_error_code() const {
        return error_code;
    }
    
    // Переопределение метода what() (опционально)
    const char* what() const noexcept override {
        static std::string message = 
            std::runtime_error::what() + std::string(" (код: ") + 
            std::to_string(error_code) + ")";
        return message.c_str();
    }
};
```

**Пример использования:**

```cpp
void process_data(int value) {
    if (value < 0) {
        throw MyException("Отрицательное значение недопустимо", 1001);
    }
    // ...
}

int main() {
    try {
        process_data(-5);
    }
    catch (const MyException& e) {
        std::cerr << "Ошибка: " << e.what() 
                  << ", код: " << e.get_error_code() << std::endl;
    }
    
    return 0;
}
```

**Дополнительная информация:**
- При наследовании от стандартных исключений рекомендуется переопределять метод `what()` с использованием `noexcept`, чтобы соответствовать базовому классу
- Для сложных исключений можно добавлять дополнительные методы и данные
- Следует избегать создания слишком глубокой иерархии исключений
- Пользовательские исключения должны быть легковесными, так как их создание и обработка имеет накладные расходы

## Практические рекомендации и лучшие практики

### 1. Используйте исключения правильно

- **Используйте исключения для исключительных ситуаций**, а не для управления нормальным ходом программы
- **Не используйте исключения как замену условным операторам** (if/else)
- **Не используйте исключения для часто возникающих ошибок**, так как это может значительно снизить производительность

### 2. Создавайте осмысленную иерархию исключений

- **Наследуйтесь от стандартных классов исключений**, когда это уместно
- **Создавайте специфичные исключения** для вашего приложения или библиотеки
- **Используйте иерархию исключений для группировки похожих ошибок**

### 3. Обрабатывайте исключения там, где есть информация для их обработки

- **Не перехватывайте исключения, если не знаете, как их обработать**
- **Не используйте пустые блоки catch**
- **Если перехватываете исключение, чтобы добавить информацию, повторно выбрасывайте его**

### 4. Гарантируйте освобождение ресурсов

- **Используйте RAII для управления ресурсами** (файлы, сокеты, память)
- **Не полагайтесь на блоки finally** (в C++ их нет, используйте RAII)
- **Убедитесь, что деструкторы не генерируют исключений**

### 5. Документируйте генерируемые исключения

- **Указывайте в документации, какие исключения может генерировать функция**
- **Для публичных API четко определите контракт по исключениям**
- **Используйте теги @throws в документации**

### 6. Тестируйте обработку исключений

- **Пишите тесты, проверяющие генерацию и обработку исключений**
- **Используйте средства для принудительного генерирования исключений в тестах**
- **Проверяйте корректность освобождения ресурсов при возникновении исключений**

## Сравнение с альтернативными подходами

### Исключения vs Коды возврата

| Критерий | Исключения | Коды возврата |
|----------|------------|---------------|
| **Читаемость кода** | Высокая (разделение нормального кода и обработки ошибок) | Низкая (проверка кодов после каждого вызова) |
| **Распространение ошибки** | Автоматическое по стеку вызовов | Требует явной передачи кода ошибки |
| **Типизация ошибок** | Строгая (разные типы исключений) | Слабая (обычно int или enum) |
| **Производительность** | Низкая при возникновении исключения, высокая в нормальном режиме | Высокая при отсутствии ошибок, низкая при их наличии |
| **Обработка нескольких ошибок** | Легко с помощью иерархии исключений | Сложно, требует дополнительной информации |
| **Гарантия освобождения ресурсов** | Автоматическая через RAII | Требует ручной обработки |

### Исключения vs Состояние объекта

Некоторые библиотеки (например, STL) используют комбинированный подход:
- Возвращают специальное значение или устанавливают флаг состояния при ошибке
- Предоставляют методы, которые генерируют исключения при ошибке

**Пример:**
```cpp
// Без исключений
if (!file.open("data.txt")) {
    // Обработка ошибки
}

// С исключениями
try {
    file.open("data.txt", std::ios::exceptions(std::ios::failbit));
}
catch (const std::ios_base::failure& e) {
    // Обработка ошибки
}
```

## Дополнительные возможности C++17/20

### 1. Исключения и `noexcept`

Ключевое слово `noexcept` указывает, что функция не генерирует исключений:

```cpp
void safe_function() noexcept {
    // Эта функция не должна генерировать исключений
}

void may_throw() noexcept(false) {
    // Эта функция может генерировать исключения
}
```

**Преимущества:**
- Позволяет компилятору оптимизировать код
- Улучшает читаемость и документирование
- Может использоваться в шаблонах для выбора реализации

**Важно:** Если функция, помеченная как `noexcept`, генерирует исключение, программа завершается вызовом `std::terminate()`.

### 2. Исключения и шаблоны

В C++17 добавлена возможность использования выражения `noexcept` в шаблонах:

```cpp
template <typename T>
void process(T value) noexcept(noexcept(T(value))) {
    // ...
}
```

Это позволяет функции быть `noexcept`, если конструктор копирования типа `T` является `noexcept`.

### 3. Использование `std::expected` (C++23)

C++23 вводит `std::expected<T, E>`, который предоставляет альтернативу исключениям для обработки ошибок:

```cpp
#include <expected>

std::expected<int, std::string> divide(int a, int b) {
    if (b == 0) {
        return std::unexpected("Деление на ноль");
    }
    return a / b;
}

auto result = divide(10, 0);
if (!result) {
    std::cout << "Ошибка: " << result.error() << std::endl;
} else {
    std::cout << "Результат: " << *result << std::endl;
}
```

**Преимущества:**
- Явное указание возможных ошибок в сигнатуре функции
- Не влияет на производительность в нормальном режиме
- Подходит для функционального стиля программирования

## Расширенные техники обработки исключений

### 1. Хранение исключений

C++ предоставляет класс `std::exception_ptr` для хранения и передачи исключений:

```cpp
#include <exception>
#include <thread>
#include <iostream>

void handle_exception(std::exception_ptr eptr) {
    try {
        if (eptr) {
            std::rethrow_exception(eptr);
        }
    } 
    catch (const std::exception& e) {
        std::cerr << "Ошибка: " << e.what() << std::endl;
    }
}

int main() {
    std::exception_ptr eptr;
    
    try {
        throw std::runtime_error("Пример ошибки");
    } 
    catch (...) {
        eptr = std::current_exception();
    }
    
    handle_exception(eptr);
    
    return 0;
}
```

**Применение:** Полезно для передачи исключений между потоками или отложенной обработки.

### 2. Глобальный обработчик необработанных исключений

Можно установить глобальный обработчик для необработанных исключений:

```cpp
#include <exception>
#include <iostream>

void my_terminate_handler() {
    std::cerr << "Программа завершается из-за необработанного исключения" << std::endl;
    // Дополнительная обработка (логирование, сохранение состояния)
    std::abort();
}

int main() {
    std::set_terminate(my_terminate_handler);
    
    // Код, который может сгенерировать необработанное исключение
    
    return 0;
}
```

**Важно:** Глобальный обработчик не может возобновить выполнение программы, он может только выполнить завершающие действия перед остановкой.

### 3. Исключения и многопоточность

При работе с многопоточностью важно правильно обрабатывать исключения:

```cpp
#include <thread>
#include <exception>
#include <iostream>

void thread_function() {
    try {
        // Код потока
        throw std::runtime_error("Ошибка в потоке");
    } 
    catch (...) {
        // Передача исключения в главный поток
        std::rethrow_exception(std::current_exception());
    }
}

int main() {
    std::exception_ptr eptr;
    
    std::thread t([&eptr]() {
        try {
            thread_function();
        } 
        catch (...) {
            eptr = std::current_exception();
        }
    });
    
    t.join();
    
    if (eptr) {
        try {
            std::rethrow_exception(eptr);
        } 
        catch (const std::exception& e) {
            std::cerr << "Ошибка в потоке: " << e.what() << std::endl;
        }
    }
    
    return 0;
}
```

**Рекомендации:**
- Всегда обрабатывайте исключения в потоках
- Используйте `std::exception_ptr` для передачи исключений между потоками
- Не допускайте завершения потока с необработанным исключением

### 4. Пользовательские политики обработки исключений

Можно создать собственные политики для обработки исключений:

```cpp
template <typename ErrorHandler>
class ExceptionHandler {
public:
    template <typename Function>
    static void handle(Function func) {
        try {
            func();
        } 
        catch (...) {
            ErrorHandler::handle(std::current_exception());
        }
    }
};

struct LogErrorHandler {
    static void handle(std::exception_ptr eptr) {
        try {
            if (eptr) {
                std::rethrow_exception(eptr);
            }
        } 
        catch (const std::exception& e) {
            std::cerr << "Логирование ошибки: " << e.what() << std::endl;
            // Дополнительная обработка
        }
    }
};

// Использование
ExceptionHandler<LogErrorHandler>::handle([]() {
    // Код, который может генерировать исключения
    throw std::runtime_error("Пример ошибки");
});
```

**Преимущества:**
- Централизованная обработка исключений
- Возможность изменения поведения без изменения основного кода
- Повторное использование политик обработки

## Заключение

Обработка исключений в C++ — мощный механизм, позволяющий создавать надежные и устойчивые к ошибкам программы. Правильное использование исключений требует понимания их работы, ограничений и лучших практик.

**Основные преимущества исключений:**
- Четкое разделение кода нормальной работы и обработки ошибок
- Автоматическое распространение ошибок по стеку вызовов
- Гарантия освобождения ресурсов через RAII
- Возможность создания иерархии исключений для точной обработки ошибок

**Ключевые рекомендации:**
1. Используйте исключения только для действительно исключительных ситуаций
2. Наследуйтесь от стандартных классов исключений при создании своих
3. Обрабатывайте исключения там, где есть информация для их обработки
4. Используйте RAII для гарантированного освобождения ресурсов
5. Документируйте генерируемые исключения в публичных API
6. Избегайте генерации исключений в деструкторах

Помните, что исключения — это инструмент, и как любой инструмент, они должны использоваться правильно и в подходящих ситуациях. Не пытайтесь решить все проблемы с помощью исключений — иногда проще и эффективнее использовать другие подходы к обработке ошибок.

---------
Альтернатива
--------

Отлично! Я изучил предоставленную презентацию по обработке исключений в C++. На её основе я создал развернутый Markdown-файл, дополнив его новым и уточняющим материалом.

```markdown
# Лекция 10: Обработка исключений в C++

### План лекции:

1.  Введение в обработку исключений
2.  Типы исключений: синхронные и асинхронные
3.  Механизмы обработки: с возвратом и без возврата
4.  Неструктурная vs структурная обработка
5.  Блоки с гарантией завершения
6.  Синтаксис C++: `try`, `catch`, `throw`
7.  Последовательность обработки и раскрутки стека
8.  Создание пользовательских классов исключений
9.  Стандартная иерархия исключений
10. Производительность и стоимость исключений
11. Best Practices и рекомендации
12. Альтернативы: коды ошибок, `std::optional`, `std::expected` (C++23)
13. Инструменты: макрос `assert` и `static_assert`

---

### 1. Введение в обработку исключений

**Обработка исключительных ситуаций (exception handling)** — это механизм языков программирования, предназначенный для описания реакции программы на ошибки времени выполнения и другие проблемы, которые делают дальнейшее выполнение базового алгоритма невозможным или бессмысленным.

Когда программа завершает выполнение с необработанным исключением, последней инстанцией является **операционная система**, которая может уведомить пользователя об ошибке (например, через сообщение или диалоговое окно).

**Примеры ситуаций, требующих исключений:**
- Деление на ноль
- Ошибки чтения данных с внешних устройств
- Исчерпание доступной памяти (`std::bad_alloc`)
- Обращение к несуществующей памяти (выход за границы массива, разыменование `nullptr`)
- Ошибки работы с БД или сетью
- Неудачное приведение типов (`std::bad_cast`)

---

### 2. Типы исключений

Исключения делятся на два основных типа:

#### Синхронные исключения
Возникают в определенных, заранее известных точках программы.
- *Примеры:* Ошибка чтения файла (`ifstream::failure`), нехватка памяти (`std::bad_alloc`), деление на ноль.
- *Обработка:* Обычно обрабатываются структурно с помощью `try-catch`.

#### Асинхронные исключения
Могут возникнуть в любой момент времени, независимо от выполняемой инструкции.
- *Примеры:* Аварийное отключение питания, сигналы ОС (например, `SIGINT` от Ctrl+C).
- *Обработка:* Часто требуют неструктурной обработки (например, сигналов ОС) или вообще не могут быть обработаны на уровне приложения.

> **Важно:** В C++ стандартный механизм `try/catch` предназначен в первую очередь для **синхронных** исключений.

---

### 3. Механизмы обработки

#### Обработка с возвратом
Обработчик ликвидирует проблему, и выполнение продолжается с точки возникновения исключения. Типично для асинхронных исключений.
*В чистом виде в C++ не поддерживается.*

#### Обработка без возврата
После обработки управление передается в заранее заданное место программы, а не назад к месту ошибки. Это основа механизма `try-catch` в C++.

---

### 4. Неструктурная vs структурная обработка

#### Неструктурная обработка (Устаревший/Си-подход)
Реализуется через регистрацию и разрегистрацию обработчиков (напоминает обработку сигналов в Unix). Код становится запутанным и трудно поддерживаемым ("spaghetti code").

```cpp
// Псевдокод, иллюстрирующий идею
УстановитьОбработчик(ОшибкаБД, ПерейтиНа ОшБД);
// Код, который может вызвать ОшибкуБД
РазрегистрироватьОбработчик(ОшибкаБД);
ПерейтиНа Конец; // Обход обработчика

ОшБД: // Мета-обработчик
// Код обработки ошибки БД
Конец:
```

#### Структурная обработка (Современный C++ подход)
Поддерживается на уровне языка синтаксическими конструкциями `try`, `catch`, `throw`. Чище, безопаснее и легче для понимания.

```cpp
try {
    // Код, который может выбросить исключение
    if (error_occurred) {
        throw MyDatabaseException("Connection failed");
    }
}
catch (const MyDatabaseException& e) {
    // Обработка конкретного исключения
    std::cerr << "DB Error: " << e.what() << std::endl;
}
catch (const std::exception& e) {
    // Обработка любых других исключений, производных от std::exception
    std::cerr << "Standard exception: " << e.what() << std::endl;
}
catch (...) {
    // Catch-all handler (перехват всего остального)
    std::cerr << "Unknown exception occurred" << std::endl;
}
```

---

### 5. Блоки с гарантией завершения

**Блоки с гарантированным завершением** гарантируют выполнение кода (например, освобождение ресурсов) независимо от того, как был завершен предыдущий блок — нормально или через исключение.

В C++ для этого используется идиома **RAII (Resource Acquisition Is Initialization)**, а не отдельные синтаксические блоки. Ресурсы освобождаются в деструкторах объектов, которые вызываются автоматически при выходе из области видимости (в т.ч. из-за исключения).

```cpp
#include <fstream>
#include <iostream>

void readFile(const std::string& filename) {
    // std::ifstream - классический пример RAII.
    // Файл будет закрыт автоматически в деструкторе при выходе из функции,
    // даже если будет выброшено исключение.
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Failed to open file");
    }
    // Читаем данные из файла...
    // Если здесь выбросится исключение, деструктор 'file' все равно закроет файл.
}
```

Для явного выполнения кода при выходе из области видимости можно использовать классы-обертки или, начиная с C++11, лямбда-функции с RAII.

```cpp
// Пример обертки для выполнения действия при выходе из scope
template <typename F>
class ScopeGuard {
    F func;
public:
    ScopeGuard(F f) : func(std::move(f)) {}
    ~ScopeGuard() { func(); }
};

void example() {
    auto resource = acquireResource();
    // Гарантируем, что releaseResource() будет вызван при выходе
    ScopeGuard guard([&] { releaseResource(resource); });

    workWithResource(resource); // Может бросить исключение
    // guard будет разрушен здесь, и releaseResource будет вызван
}
```

---

### 6. Синтаксис C++: `try`, `catch`, `throw`

- **`try`**: Определяет блок кода, в котором ожидаются исключения.
- **`catch`**: Определяет блок кода, обрабатывающий исключения определенного типа.
- **`throw`**: "Выбрасывает" исключение, прерывая нормальное выполнение программы.

```cpp
#include <stdexcept> // Для стандартных исключений

double divide(int numerator, int denominator) {
    if (denominator == 0) {
        // Выбрасываем исключение типа std::invalid_argument
        throw std::invalid_argument("Division by zero is not allowed.");
    }
    return static_cast<double>(numerator) / denominator;
}

int main() {
    try {
        double result = divide(10, 0);
        std::cout << "Result: " << result << std::endl;
    }
    catch (const std::invalid_argument& e) {
        // Ловим конкретное исключение по константной ссылке
        std::cerr << "Invalid argument: " << e.what() << std::endl;
    }
    catch (const std::exception& e) {
        // Ловим любое исключение, производное от std::exception
        std::cerr << "Standard exception: " << e.what() << std::endl;
    }
    catch (...) {
        // Ловим вообще всё остальное
        std::cerr << "An unknown exception occurred!" << std::endl;
    }
    return 0;
}
```

**Важно:**
- Перехватывайте исключения **по константной ссылке** (`catch (const MyException& e)`), чтобы избежать срезки (slicing) и ненужного копирования.
- Обработчик `catch (...)` должен идти последним.

---

### 7. Последовательность обработки и раскрутки стека

Когда вызывается `throw`:
1.  Нормальное выполнение программы немедленно прерывается.
2.  Начинается процесс **раскрутки стека (stack unwinding)**: деструкторы всех локальных объектов в текущей и вложенных областях видимости (на пути от `throw` до `catch`) вызываются в порядке, обратном их созданию.
3.  Компилятор ищет подходящий блок `catch` в текущем блоке `try`. Если не находит, раскрутка стека продолжается до следующего блока `try` в стеке вызовов.
4.  Если подходящий обработчик не найден во всей цепочке вызовов, вызывается стандартная функция `std::terminate()`, и программа аварийно завершается.

```cpp
void functionC() {
    std::cout << "Starting functionC" << std::endl;
    throw std::runtime_error("An error occurred in functionC");
    std::cout << "Ending functionC" << std::endl; // Не выполнится
}

void functionB() {
    std::cout << "Starting functionB" << std::endl;
    functionC();
    std::cout << "Ending functionB" << std::endl; // Не выполнится
}

void functionA() {
    std::cout << "Starting functionA" << std::endl;
    try {
        functionB();
    }
    catch (const std::exception& e) {
        std::cerr << "Caught exception in functionA: " << e.what() << std::endl;
    }
    std::cout << "Ending functionA" << std::endl; // Выполнится
}

int main() {
    functionA();
    return 0;
}
// Output:
// Starting functionA
// Starting functionB
// Starting functionC
// Caught exception in functionA: An error occurred in functionC
// Ending functionA
```

---

### 8. Создание пользовательских классов исключений

Создавайте собственные классы исключений, наследуя их от `std::exception` или его потомков. Это позволяет обрабатывать ваши исключения стандартным образом и добавлять специфичную информацию.

```cpp
#include <exception>
#include <string>

class MyDatabaseException : public std::exception {
private:
    std::string message;
    int error_code;
public:
    MyDatabaseException(const std::string& msg, int code = -1)
        : message(msg), error_code(code) {}

    // Переопределяем метод what() из std::exception
    const char* what() const noexcept override {
        return message.c_str();
    }

    int getErrorCode() const noexcept {
        return error_code;
    }
};

// Использование
void connectToDatabase() {
    // ...
    if (connection_failed) {
        throw MyDatabaseException("Could not connect to database", 1001);
    }
}
```

---

### 9. Стандартная иерархия исключений

Стандартная библиотека предоставляет готовую иерархию исключений. Наследуйте свои исключения от наиболее подходящего стандартного класса.

```
std::exception
├── std::logic_error (логические ошибки, теоретически предотвратимые)
│   ├── std::invalid_argument
│   ├── std::domain_error
│   ├── std::length_error
│   └── std::out_of_range
├── std::runtime_error (ошибки времени выполнения, часто внешние)
│   ├── std::range_error
│   ├── std::overflow_error
│   ├── std::underflow_error
│   └── std::system_error (содержит код ошибки ОС)
└── Другие (менее распространенные для прямого использования)
    ├── std::bad_alloc (неудачное выделение памяти)
    ├── std::bad_cast (неудачное приведение типов через dynamic_cast)
    └── std::bad_typeid (неудачное применение typeid к nullptr)
```

**Рекомендация:** Для большинства пользовательских исключений наследуйтесь от `std::runtime_error` или `std::logic_error`. Они уже содержат строку с описанием и реализуют `what()`.

```cpp
#include <stdexcept>

class FileNotFoundException : public std::runtime_error {
public:
    explicit FileNotFoundException(const std::string& filename)
        : std::runtime_error("File not found: " + filename) {}
};
```

---

### 10. Производительность и стоимость исключений

Исключения в C++ разработаны по принципу **"You don't pay for what you don't use"**.

- **В случае отсутствия исключений:** На большинстве современных компиляторов и архитектур используется модель **zero-cost exceptions**. Это означает, что код практически не несет накладных расходов, если исключения не выбрасываются. Цена достигается за счет увеличения размера бинарного файла (там хранится информация для раскрутки стека).
- **В случае выбрасывания исключения:** Процесс раскрутки стека и поиска обработчика является **дорогой операцией**. Не используйте исключения для контроля потока выполнения в часто вызываемом коде.

**Когда использовать исключения:**
- Ошибки являются **редкими** и **серьезными**.
- Ошибку **неудобно или невозможно обработать** локально, где она возникла.
- Нет простого способа вернуть код ошибки (например, в конструкторе).

**Когда НЕ использовать исключения:**
- Для обработки **ожидаемых частых ошибок** (например, неверный пользовательский ввод).
- В **критичных к производительности** участках кода (e.g., tight loops).
- В деструкторах! Деструкторы должны быть `noexcept` (см. ниже).

---

### 11. Best Practices и рекомендации

1.  **Используйте RAII:** Это самый важный паттерн в C++ для безопасности исключений. Ресурсы должны быть инкапсулированы в объекты, освобождаемые в деструкторах.
2.  **Безопасность исключений в деструкторах:** Деструкторы по умолчанию должны быть **`noexcept`** (не бросать исключений). Если исключение вылетает из деструктора во время раскрутки стека (из-за другого исключения), программа немедленно завершится через `std::terminate()`.
3.  **Спецификатор `noexcept`:** Явно помечайте функции, которые не должны бросать исключения, с помощью `noexcept`. Это помогает компилятору оптимизировать код.
4.  **Избегайте сырых указателей:** Используйте умные указатели (`std::unique_ptr`, `std::shared_ptr`), которые автоматически освободят память при исключении.
5.  **Не игнорируйте исключения:** Пустой блок `catch` — это почти всегда плохая идея. Как минимум, логируйте ошибку.
6.  **Не бросайте исключения из обработчиков исключений:** Это приводит к немедленному вызову `std::terminate()`.

```cpp
// Хорошо: Деструктор не бросает исключений
class MyResourceHolder {
    std::unique_ptr<Resource> ptr; // RAII!
public:
    ~MyResourceHolder() noexcept = default; // Ресурс освободится автоматически
    void doSomething() { // Может бросать исключения
        if (error) {
            throw std::runtime_error("Error");
        }
    }
};

// Плохо: Деструктор, который может бросить исключение
class BadClass {
    FILE* file;
public:
    ~BadClass() {
        if (file) {
            fclose(file); // Что если fclose fails? Лучше использовать RAII обертку!
        }
    }
};
```

---

### 12. Альтернативы исключениям

Исключения — не единственный способ обработки ошибок.

1.  **Коды возврата:** Старый, но проверенный способ. Недостатки: ими можно легко пренебречь, они "загрязняют" сигнатуру функций.
    ```cpp
    std::pair<bool, Data> loadData() {
        if (error) {
            return {false, {}};
        }
        return {true, data};
    }
    ```

2.  **`std::optional` (C++17):** Для случаев, когда результат может отсутствовать, но это не ошибка.
    ```cpp
    std::optional<double> safeDivide(int a, int b) {
        if (b == 0) {
            return std::nullopt; // "Пустое" значение
        }
        return static_cast<double>(a) / b;
    }
    ```

3.  **`std::expected` (C++23):** Более мощная альтернатива, хранящая либо результат, либо информацию об ошибке.
    ```cpp
    // Примерная сигнатура (C++23)
    std::expected<double, std::string> safeDivide(int a, int b) {
        if (b == 0) {
            return std::unexpected("Division by zero");
        }
        return static_cast<double>(a) / b;
    }
    ```

**Выбор подхода зависит от контекста:** Используйте исключения для неожиданных, фатальных ошибок, а `std::optional`/`std::expected` — для ожидаемых ситуаций с отсутствующим результатом.

---

### 13. Инструменты: `assert` и `static_assert`

- **`assert`**: Макрос из `<cassert>`. Проверяет условие во время **выполнения**. В режиме отладки (`NDEBUG` не defined) при failure вызывает аварийное завершение. В релизе (`NDEBUG` defined) проверки игнорируются. Используется для проверки инвариантов и отлавливания ошибок программиста.
    ```cpp
    #include <cassert>
    void process(int* ptr) {
        assert(ptr != nullptr && "Pointer must not be null"); // Сообщение для отладки
        // ... use ptr ...
    }
    ```

- **`static_assert`**: Проверяет условие во время **компиляции**. Если условие ложно, компиляция прекращается с ошибкой. Идеально для проверки шаблонных параметров и условий, известных на этапе компиляции.
    ```cpp
    template <typename T>
    void process() {
        static_assert(std::is_integral_v<T>, "T must be an integral type");
        // ...
    }
    static_assert(sizeof(int) >= 4, "int must be at least 4 bytes");
    ```

---

### Заключение

Обработка исключений в C++ — это мощный механизм для обработки ошибок, который при правильном использовании (в сочетании с RAII) позволяет писать надежный и легко поддерживаемый код. Ключевые принципы:
- **Предпочитайте исключения кодам возврата для серьезных, редких ошибок.**
- **Используйте RAII для управления ресурсами.**
- **Наследуйте пользовательские исключения от `std::exception`.**
- **Ловите исключения по константной ссылке.**
- **Избегайте исключений в деструкторах и критичных к производительности участках кода.**
- **Понимайте стоимость исключений и используйте их с умом.**

Спасибо за внимание!
