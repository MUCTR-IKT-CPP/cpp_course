# Лекция 3: Пользовательские типы, структуры, объединения, функции

### План лекции:

1. Файловая структура
2. Компиляция нескольких файлов
3. Namespace
4. Файлы программ и заголовочные файлы. 
5. Нулевой указатель
6. Пользовательские типы данных
7. Объединения
8. Перечисления
9. Структуры
10. Функции и структуры
11. Inline функции
12. Константные функции
13. Неопределенное кол-во аргументов
14. Аргументы по умолчанию
15. Переопределение функции
16. Понятие полиморфизма функции
17. Указатель на функции

# Конспект лекции: Пользовательские типы данных в C++

# Конспект лекции: Пользовательские типы данных в C++

## Пространства имен (namespace)

**Объяснение:** Пространства имен — это механизм для организации кода в логические группы и предотвращения конфликтов имен. Они позволяют создавать изолированные области видимости для переменных, функций и классов.

**Подробное пояснение:** В больших проектах часто возникают ситуации, когда разные библиотеки или модули используют одинаковые имена. Пространства имен решают эту проблему, предоставляя контекст для имен. Это похоже на фамилии у людей — разные люди могут иметь одинаковые имена, но их можно различить по фамилиям.

```cpp
namespace Mathematics {
    const double PI = 3.14159;
    
    double calculateCircleArea(double radius) {
        return PI * radius * radius;
    }
}

namespace Physics {
    const double PI = 3.14; // Другое значение PI в другом контексте
    
    double calculateForce(double mass, double acceleration) {
        return mass * acceleration;
    }
}

int main() {
    // Доступ к элементам через полное квалифицированное имя
    double area = Mathematics::calculateCircleArea(5.0);
    double force = Physics::calculateForce(10.0, 9.8);
    
    // Использование директивы using для упрощения доступа
    using namespace Mathematics;
    double anotherArea = calculateCircleArea(3.0);
    
    // Использование using для конкретного элемента
    using Physics::calculateForce;
    double anotherForce = calculateForce(5.0, 2.0);
    
    return 0;
}
```

**Пояснение примера:** В этом примере мы видим, что два разных пространства имен могут содержать константы с одинаковыми именами (PI), но разными значениями. Это не вызывает конфликта, потому что они находятся в разных пространствах имен.

## Нулевые указатели

**Объяснение:** Указатели — это переменные, которые хранят адреса памяти. Иногда нужно показать, что указатель ни на что не указывает. Для этого используются нулевые указатели.

**Подробное пояснение:** В C++ есть три способа обозначить нулевой указатель: NULL, 0 и nullptr. nullptr — это современный и безопасный способ, представленный в C++11. Основное преимущество nullptr в том, что он имеет собственный тип nullptr_t и не может быть случайно интерпретирован как целое число.

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void generateRandInteger(int*& pi) {
    if (pi == nullptr) {
        pi = new int{rand() % 100}; // Создаем случайное число от 0 до 99
        cout << "Generated new value: " << *pi << endl;
    } else {
        cout << "Pointer already points to value: " << *pi << endl;
    }
}

int main() {
    srand(time(nullptr)); // Инициализация генератора случайных чисел
    
    int* ptr1 = nullptr;
    int* ptr2 = nullptr;
    
    generateRandInteger(ptr1); // Сгенерирует новое значение
    generateRandInteger(ptr1); // Уже имеет значение
    
    // Разыменование нулевого указателя приведет к ошибке
    // cout << *ptr2 << endl; // Ошибка времени выполнения!
    
    delete ptr1; // Важно освобождать память!
    return 0;
}
```

**Пояснение примера:** Функция generateRandInteger проверяет, является ли переданный указатель нулевым. Если да, она выделяет память и сохраняет туда случайное число. Если нет, она просто выводит существующее значение. Это демонстрирует практическое использование проверки на nullptr.

## Перечисления (enum и enum class)

**Объяснение:** Перечисления позволяют создавать наборы именованных констант, что делает код более читаемым и безопасным.

**Подробное пояснение:** Обычные enum (перечисления) из C имеют недостатки: их элементы видны в окружающей области видимости и они неявно преобразуются к int. enum class (перечисления с областью видимости), введенные в C++11, решают эти проблемы.

```cpp
#include <iostream>
#include <string>

using namespace std;

// Обычное перечисление (устаревший подход)
enum OldColor {
    RED,    // = 0
    GREEN,  // = 1
    BLUE    // = 2
};

// Перечисление с областью видимости (современный подход)
enum class Color {
    RED,    // = 0
    GREEN,  // = 1
    BLUE    // = 2
};

// Перечисление с явными значениями
enum class HttpStatus : int {
    OK = 200,
    CREATED = 201,
    BAD_REQUEST = 400,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
};

string getColorName(Color c) {
    switch (c) {
        case Color::RED: return "Red";
        case Color::GREEN: return "Green";
        case Color::BLUE: return "Blue";
        default: return "Unknown";
    }
}

int main() {
    // Использование обычного перечисления
    OldColor old = RED;
    int oldValue = old; // Неявное преобразование (проблема!)
    
    // Использование перечисления с областью видимости
    Color color = Color::RED;
    // int value = color; // Ошибка: нет неявного преобразования
    int value = static_cast<int>(color); // Явное преобразование
    
    cout << "Color: " << getColorName(color) << endl;
    cout << "HTTP status for 404: " << static_cast<int>(HttpStatus::NOT_FOUND) << endl;
    
    return 0;
}
```

**Пояснение примера:** Этот пример показывает разницу между обычными перечислениями и enum class. Color::RED и OldColor RED — это разные сущности. enum class обеспечивает лучшую типобезопасность и предотвращает случайные ошибки.

## Структуры

**Объяснение:** Структуры позволяют группировать связанные данные в единый тип. В C++ структуры могут содержать не только данные, но и методы.

**Подробное пояснение:** Структуры — это фундаментальный строительный блок в C++. Они позволяют создавать сложные типы данных, объединяя несколько переменных под одним именем. В отличие от C, в C++ структуры могут иметь методы, конструкторы, деструкторы и наследование.

```cpp
#include <iostream>
#include <string>
#include <cmath>

using namespace std;

// Простая структура для представления точки в 2D пространстве
struct Point {
    double x;
    double y;
    
    // Метод для вычисления расстояния до другой точки
    double distanceTo(const Point& other) const {
        double dx = x - other.x;
        double dy = y - other.y;
        return sqrt(dx*dx + dy*dy);
    }
    
    // Метод для вывода координат
    void print() const {
        cout << "(" << x << ", " << y << ")";
    }
};

// Структура с конструктором
struct Person {
    string name;
    int age;
    
    // Конструктор
    Person(const string& n, int a) : name(n), age(a) {}
    
    // Метод для проверки, является ли человек совершеннолетним
    bool isAdult() const {
        return age >= 18;
    }
};

int main() {
    // Инициализация структуры
    Point p1 = {3.0, 4.0};
    Point p2;
    p2.x = 0.0;
    p2.y = 0.0;
    
    // Использование метода
    double dist = p1.distanceTo(p2);
    cout << "Distance between ";
    p1.print();
    cout << " and ";
    p2.print();
    cout << " is " << dist << endl;
    
    // Использование структуры с конструктором
    Person alice("Alice", 25);
    Person bob("Bob", 16);
    
    cout << alice.name << " is " << (alice.isAdult() ? "adult" : "minor") << endl;
    cout << bob.name << " is " << (bob.isAdult() ? "adult" : "minor") << endl;
    
    return 0;
}
```

**Пояснение примера:** Этот пример показывает, как структуры могут содержать не только данные, но и методы для работы с этими данными. Структура Point инкапсулирует концепцию точки в 2D пространстве и предоставляет методы для работы с точками.

## Объединения (union) и современные альтернативы

**Объяснение:** Объединения позволяют хранить разные типы данных в одной области памяти. Однако они небезопасны, так как не отслеживают, какой тип данных в них сохранен.

**Подробное пояснение:** В современных версиях C++ (C++17 и выше) появились более безопасные альтернативы: std::variant для хранения значений разных типов и std::optional для представления опциональных значений (которые могут отсутствовать).

```cpp
#include <iostream>
#include <variant>
#include <optional>
#include <string>

using namespace std;

// Традиционное объединение
union TraditionalUnion {
    int i;
    double d;
    char c;
};

// Современная альтернатива с std::variant
using ModernVariant = variant<int, double, string>;

// Функция для обработки variant
void processVariant(const ModernVariant& v) {
    if (holds_alternative<int>(v)) {
        cout << "Integer: " << get<int>(v) << endl;
    } else if (holds_alternative<double>(v)) {
        cout << "Double: " << get<double>(v) << endl;
    } else if (holds_alternative<string>(v)) {
        cout << "String: " << get<string>(v) << endl;
    }
}

// Функция, возвращающая optional
optional<int> findNumber(const string& text) {
    try {
        return stoi(text);
    } catch (...) {
        return nullopt; // Число не найдено
    }
}

int main() {
    // Использование традиционного union
    TraditionalUnion u;
    u.i = 42;
    cout << "Union as integer: " << u.i << endl;
    
    // Проблема: мы можем обратиться к полю, которое не устанавливали
    cout << "Union as double: " << u.d << endl; // Неопределенное поведение!
    
    // Использование variant
    ModernVariant v1 = 42;
    ModernVariant v2 = 3.14;
    ModernVariant v3 = "Hello";
    
    processVariant(v1);
    processVariant(v2);
    processVariant(v3);
    
    // Использование optional
    auto result1 = findNumber("123");
    if (result1) {
        cout << "Found number: " << *result1 << endl;
    } else {
        cout << "Number not found" << endl;
    }
    
    auto result2 = findNumber("abc");
    if (result2.has_value()) {
        cout << "Found number: " << result2.value() << endl;
    } else {
        cout << "Number not found" << endl;
    }
    
    return 0;
}
```

**Пояснение примера:** Этот пример показывает разницу между традиционными объединениями и современными альтернативами. std::variant безопасно хранит значения разных типов и позволяет проверить, какой тип сейчас хранится. std::optional представляет значение, которое может отсутствовать, что избавляет от необходимости использовать специальные значения (например, -1) для обозначения отсутствия значения.

## Выравнивание и отступы

**Объяснение:** Выравнивание — это требование архитектуры процессора, чтобы данные в памяти располагались по определенным адресам. Это влияет на размер структур и их производительность.

**Подробное пояснение:** Современные процессоры работают с памятью не побайтово, а блоками определенного размера (обычно 4, 8 или 16 байт). Если данные не выровнены properly, процессору可能需要 выполнить дополнительные операции для доступа к ним, что замедляет выполнение программы.

```cpp
#include <iostream>

using namespace std;

// Структура с неоптимальным выравниванием
struct PoorlyAligned {
    char a;      // 1 байт
    double b;    // 8 байт (требует выравнивания по 8)
    char c;      // 1 байт
    int d;       // 4 байта (требует выравнивания по 4)
};

// Структура с оптимальным выравниванием
struct WellAligned {
    double b;    // 8 байт
    int d;       // 4 байта
    char a;      // 1 байт
    char c;      // 1 байт
    // 2 байта заполнения для выравнивания
};

int main() {
    cout << "Sizeof(PoorlyAligned): " << sizeof(PoorlyAligned) << endl;
    cout << "Sizeof(WellAligned): " << sizeof(WellAligned) << endl;
    
    cout << "Offsetof(PoorlyAligned::a): " << offsetof(PoorlyAligned, a) << endl;
    cout << "Offsetof(PoorlyAligned::b): " << offsetof(PoorlyAligned, b) << endl;
    cout << "Offsetof(PoorlyAligned::c): " << offsetof(PoorlyAligned, c) << endl;
    cout << "Offsetof(PoorlyAligned::d): " << offsetof(PoorlyAligned, d) << endl;
    
    cout << "Alignof(PoorlyAligned): " << alignof(PoorlyAligned) << endl;
    cout << "Alignof(WellAligned): " << alignof(WellAligned) << endl;
    
    return 0;
}
```

**Пояснение примера:** Этот пример показывает, как порядок полей в структуре влияет на ее размер. PoorlyAligned имеет больший размер из-за необходимости добавления отступов для выравнивания. WellAligned оптимизирован путем размещения полей с наибольшими требованиями к выравниванию в начале структуры.

## Псевдонимы типов

**Объяснение:** Псевдонимы типов позволяют создавать синонимы для существующих типов, что делает код более читаемым и удобным для поддержки.

**Подробное пояснение:** В C++ есть два способа создания псевдонимов типов: typedef (унаследованный из C) и using (более современный и мощный). using особенно полезен с шаблонами.

```cpp
#include <iostream>
#include <vector>
#include <map>

using namespace std;

// Традиционный способ с typedef
typedef vector<int> IntVector;
typedef map<string, int> StringIntMap;

// Современный способ с using
using IntMatrix = vector<vector<int>>;
using StringFloatMap = map<string, float>;

// Шаблонные псевдонимы (только с using)
template<typename T>
using Matrix = vector<vector<T>>;

template<typename K, typename V>
using Dictionary = map<K, V>;

int main() {
    // Использование псевдонимов
    IntVector numbers = {1, 2, 3, 4, 5};
    IntMatrix matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    
    StringIntMap ageMap = {{"Alice", 25}, {"Bob", 30}};
    Dictionary<string, double> heightMap = {{"Alice", 1.65}, {"Bob", 1.80}};
    
    // Шаблонный псевдоним
    Matrix<double> doubleMatrix = {{1.1, 2.2}, {3.3, 4.4}};
    
    cout << "First number: " << numbers[0] << endl;
    cout << "Matrix element: " << matrix[1][1] << endl;
    cout << "Alice's age: " << ageMap["Alice"] << endl;
    cout << "Bob's height: " << heightMap["Bob"] << endl;
    
    return 0;
}
```

**Пояснение примера:** Этот пример показывает преимущества using перед typedef. using обеспечивает более читаемый синтаксис, особенно для сложных типов, и позволяет создавать шаблонные псевдонимы, что невозможно с typedef.

## Inline-функции

**Объяснение:** Inline-функции — это функции, которые компилятор пытается встроить в место вызова, чтобы избежать накладных расходов на вызов функции.

**Подробное пояснение:** Ключевое слово inline является подсказкой компилятору, что функцию следует встроить, если это возможно. Это может улучшить производительность, особенно для маленьких функций, которые часто вызываются. Однако окончательное решение о встраивании принимает компилятор.

```cpp
#include <iostream>

using namespace std;

// Обычная функция
int add(int a, int b) {
    return a + b;
}

// Inline-функция
inline int multiply(int a, int b) {
    return a * b;
}

// Функция с большим телом (вряд ли будет встроена)
inline void printLargeMessage() {
    for (int i = 0; i < 10; ++i) {
        cout << "This is a long message...\n";
    }
}

int main() {
    int x = 5, y = 3;
    
    // Вызов обычной функции
    int sum = add(x, y);
    
    // Вызов inline-функции
    // Компилятор может заменить это на: int product = x * y;
    int product = multiply(x, y);
    
    // Вызов большой inline-функции
    // Компилятор, скорее всего, не будет встраивать эту функцию
    printLargeMessage();
    
    cout << "Sum: " << sum << endl;
    cout << "Product: " << product << endl;
    
    return 0;
}
```

**Пояснение примера:** В этом примере multiply помечена как inline, и компилятор может заменить вызов функции непосредственным умножением. Однако для printLargeMessage, несмотря на спецификатор inline, компилятор, скорее всего, не будет выполнять встраивание из-за большого размера функции.

## Аргументы по умолчанию

**Объяснение:** Аргументы по умолчанию позволяют задавать значения параметров по умолчанию, которые используются, если вызывающий код не предоставляет соответствующие аргументы.

**Подробное пояснение:** Аргументы по умолчанию делают интерфейсы функций более гибкими. Они должны быть указаны только в объявлении функции (обычно в заголовочном файле) и могут быть только у последних параметров функции.

```cpp
#include <iostream>
#include <string>

using namespace std;

// Функция с аргументами по умолчанию
void printMessage(const string& message, 
                  const string& prefix = "INFO", 
                  const string& suffix = "") {
    cout << "[" << prefix << "] " << message;
    if (!suffix.empty()) {
        cout << " " << suffix;
    }
    cout << endl;
}

// Функция с несколькими аргументами по умолчанию
int power(int base, int exponent = 2) {
    int result = 1;
    for (int i = 0; i < exponent; ++i) {
        result *= base;
    }
    return result;
}

int main() {
    // Использование разных комбинаций аргументов
    printMessage("Hello");                    // [INFO] Hello
    printMessage("Hello", "DEBUG");           // [DEBUG] Hello
    printMessage("Hello", "WARNING", "!!!");  // [WARNING] Hello !!!
    
    cout << "Square of 5: " << power(5) << endl;      // 25
    cout << "5^3: " << power(5, 3) << endl;           // 125
    cout << "2^10: " << power(2, 10) << endl;         // 1024
    
    return 0;
}
```

**Пояснение примера:** Функция printMessage демонстрирует использование нескольких аргументов по умолчанию. Можно вызывать функцию с одним, двумя или тремя аргументами. Функция power показывает, как аргументы по умолчанию могут сделать функцию более универсальной.

## Перегрузка функций

**Объяснение:** Перегрузка функций позволяет создавать несколько функций с одинаковым именем, но разными параметрами.

**Подробное пояснение:** Компилятор различает перегруженные функции по их сигнатуре (типам и количеству параметров). Возвращаемый тип не является частью сигнатуры, поэтому функции не могут быть перегружены только по возвращаемому типу.

```cpp
#include <iostream>
#include <string>
#include <cmath>

using namespace std;

// Перегруженные функции для сложения
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

string add(const string& a, const string& b) {
    return a + b;
}

// Перегруженные функции для вычисления абсолютного значения
int absolute(int x) {
    return (x < 0) ? -x : x;
}

double absolute(double x) {
    return (x < 0) ? -x : x;
}

// Функции с разным количеством параметров
int multiply(int a, int b) {
    return a * b;
}

int multiply(int a, int b, int c) {
    return a * b * c;
}

int main() {
    // Вызов разных версий add
    cout << "add(2, 3) = " << add(2, 3) << endl;
    cout << "add(2.5, 3.7) = " << add(2.5, 3.7) << endl;
    cout << "add(\"Hello, \", \"world!\") = " << add("Hello, ", "world!") << endl;
    
    // Вызов разных версий absolute
    cout << "absolute(-5) = " << absolute(-5) << endl;
    cout << "absolute(-3.14) = " << absolute(-3.14) << endl;
    
    // Вызов разных версий multiply
    cout << "multiply(2, 3) = " << multiply(2, 3) << endl;
    cout << "multiply(2, 3, 4) = " << multiply(2, 3, 4) << endl;
    
    return 0;
}
```

**Пояснение примера:** Этот пример показывает различные виды перегрузки: по типам параметров (add, absolute) и по количеству параметров (multiply). Компилятор выбирает appropriate функцию на основе переданных аргументов.

## Указатели на функции

**Объяснение:** Указатели на функции позволяют хранить адреса функций и вызывать их через указатель. Это мощный инструмент для создания гибкого кода.

**Подробное пояснение:** Указатели на функции особенно полезны для реализации callback-ов, плагинов и стратегий. В современном C++ часто используются std::function и лямбда-выражения как более безопасные и удобные альтернативы.

```cpp
#include <iostream>
#include <vector>
#include <functional> // для std::function

using namespace std;

// Простые математические функции
double square(double x) {
    return x * x;
}

double cube(double x) {
    return x * x * x;
}

// Функция, принимающая указатель на функцию
void transformArray(double* arr, int size, double (*func)(double)) {
    for (int i = 0; i < size; ++i) {
        arr[i] = func(arr[i]);
    }
}

// То же самое с std::function (более современный подход)
void transformArrayModern(double* arr, int size, function<double(double)> func) {
    for (int i = 0; i < size; ++i) {
        arr[i] = func(arr[i]);
    }
}

// Функция для вывода массива
void printArray(const double* arr, int size) {
    for (int i = 0; i < size; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    const int SIZE = 5;
    double numbers[SIZE] = {1.0, 2.0, 3.0, 4.0, 5.0};
    
    // Использование указателей на функции
    cout << "Original array: ";
    printArray(numbers, SIZE);
    
    transformArray(numbers, SIZE, square);
    cout << "After squaring: ";
    printArray(numbers, SIZE);
    
    transformArray(numbers, SIZE, cube);
    cout << "After cubing: ";
    printArray(numbers, SIZE);
    
    // Сброс массива
    double reset[SIZE] = {1.0, 2.0, 3.0, 4.0, 5.0};
    for (int i = 0; i < SIZE; ++i) numbers[i] = reset[i];
    
    // Использование std::function и лямбда-выражений
    cout << "\nWith std::function:\n";
    cout << "Original array: ";
    printArray(numbers, SIZE);
    
    // Лямбда-выражение для удвоения
    auto doubleValue = [](double x) { return 2 * x; };
    
    transformArrayModern(numbers, SIZE, doubleValue);
    cout << "After doubling: ";
    printArray(numbers, SIZE);
    
    // Еще одно лямбда-выражение с захватом
    double factor = 0.5;
    auto scale = [factor](double x) { return factor * x; };
    
    transformArrayModern(numbers, SIZE, scale);
    cout << "After scaling by 0.5: ";
    printArray(numbers, SIZE);
    
    return 0;
}
```

**Пояснение примера:** Этот пример демонстрирует использование указателей на функции и их современной альтернативы — std::function. transformArray принимает указатель на функцию и применяет ее к каждому элементу массива. transformArrayModern делает то же самое, но с std::function, что позволяет использовать не только обычные функции, но и лямбда-выражения, включая те, которые захватывают переменные из окружающего контекста.

## Заключение

Пользовательские типы данных — это мощный инструмент в C++, который позволяет создавать абстракции высокого уровня и писать более выразительный и безопасный код. Понимание этих концепций необходимо для эффективного программирования на C++.

Ключевые моменты:
1. Пространства имен помогают организовать код и избежать конфликтов имен.
2. nullptr обеспечивает типобезопасную альтернативу NULL.
3. enum class решает проблемы обычных перечислений.
4. Структуры позволяют группировать данные и поведение.
5. std::variant и std::optional предоставляют безопасные альтернативы union.
6. Понимание выравнивания важно для эффективного использования памяти.
7. Псевдонимы типов делают код более читаемым.
8. Inline-функции могут улучшить производительность.
9. Аргументы по умолчанию и перегрузка функций делают интерфейсы более гибкими.
10. Указатели на функции и std::function позволяют создавать гибкие архитектуры.


