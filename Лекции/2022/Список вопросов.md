Список вопросов.
=================
1. Что такое соглашение об именовании, зачем оно используется?
2. Какие три этапа проходит написанный при сборке скомпилированной программы? В чем суть этих этапов?
3. Что такое единица трансляции, на каком этапе сборки программы происходит объединение единиц трансляции, в чем заключается суть процесса объединения?
4. На какие этапы подразделяет процесс компиляции одной единицы трансляции? В чем их суть?
5. На какие два этапа подразделяется выделение переменной? Могут ли они быть разнесены в программе? Что будет хранится в переменной если не установить ее значение?
6. На какие две группы делятся типы? Назовите примеры.
7. Какие бывают виды констант? Чем они отличаются? Какие существуют ограничения?
8. Что такое область видимости? Что является единицей области видимости в С++? Привести пример видимости переменных во вложенных и параллельных областях видимости.
9. Что такое сигнатура функции? Какие части сигнатуры есть? Чем заканчивается функция которая возвращает значение? Может ли функция не возвращать значения?
10. Что такое ссылка и указатель, чем они отличаются, в чем они похожи? Для чего используются ссылки, для чего используются указатели?
11. Какие типы памяти есть в С++? Чем они отличаются? На каком этапе жизненного цикла программы определяется их размер?
12. Операция взятия указателя и разыменования указателя, их символьные обозначения и суть?
13. Статические массивы, их представление в памяти, указатели на массивы, арифметика указателей?
14. Динамические массивы, их представление в памяти, процесс выделения?
15. Операторы new и delete, их суть, тип рабочей памяти, удаление массивов?
16. Файловая структура программы, разбиение программы на модули, указание
использование разных модулей друг в друге, стражи компиляции?
17. Область имен, стандартная область имен, директива using, как используется и
для чего?
18. Нулевой указатель, для чего он нужен, как его объявить? Указатель на пустоту, для чего он нужен, как его объявить?
19. Перечисления, что это такое, для чего используется, сигнатура описания?
20. Структура, что это такое, для чего используется, сигнатура описания, представление в памяти?
21. Объединение, что это такое, для чего используется, сигнатура описания, представление в памяти?
22. Псевдонимы, что это такое, для чего используется, сигнатура?
23. Inline функция, что это такое, для чего используется? Аргументы по умолчанию, сигнатура объявления.
24. Перегрузка функций, для чего используется? Указатель на функцию, для чего используется?
25. Что такое абстракция и абстрагирование?
26. Что такое парадигма программирования? Какую парадигму мы изучали?
27. Что такое объектно ориентированное программирование, перечислить три кита ООП?
28. Что такое класс в с++? Чем отличается класс от объекта? Сигнатура объявления класса?
29. Что такое конструктор, варианты конструкторов? Деструктор? Указатель this?
30. Что такое наследование, как оформляется наследование в с++, наследование конструкторов, наследование методов и атрибутов?
31. Что такое инкапсуляция, модификаторы доступа к полям класса, модификаторы наследования?
32. Что такое полиморфизм, перегрузка методов в наследниках, полиморфизм и наследование?
33. Дружественные функции? Перегрузка операторов? Перегрузка операторов через дружественные функции, зачем?
34. Класс, объект которого нельзя скопировать, как сделать, зачем? Класс, объект которого нельзя создать, как сделать, зачем?
35. Виртуальные методы, этап определения вызываемого кода, сигнатура? Чистые виртуальные методы? Реализация по умолчанию чистого виртуального метода?
36. Абстрактный класс, что это, зачем? Интерфейсный класс, отличие от абстрактного класса?
37. Потоки ввода вывода, стандартные потоки, операция ввода и вывода, перегрузка операции для собственного класса через дружественную функцию?
38. Контейнерные классы, типы, последовательные контейнеры, примеры последовательных контейнеров?
39. Контейнерные классы, типы, ассоциативные контейнеры, примеры ассоциативных контейнеров?
40. Итератор, что это такое, для чего нужно? Цикл фор при помощи итератора по последовательной коллекции? Цикл for each?
41. Вектор в стандартной библиотеке С++, его особенности, примерное устройство, пример использования?
42. Список в стандартной библиотеке С++, его особенности, примерное устройство, пример использования?
43. Стек и очередь, принцип работы и организации?
44. Словарь в стандартной библиотеке С++, его особенности, на чем основана его работа, пример использования?
45. Множество в стандартной библиотеке С++, его особенности, на чем основана его работа, пример использования?
46. Что такое метапрограммирование? Что такое шаблон в С++? Сигнатура шаблона функции?
47. Шаблонная функция, собственная реализация шаблонной функции, шаблонная функция и тип auto?
48. Шаблонный класс, сигнатура шаблона класса? Нетиповые аргументы шаблона? Проблемы шаблонов?
49. Стандартная библиотека С++, примеры ее составляющих, стандартная библиотека алгоритмов, что содержит, зачем нужна?
50. Предикат, что это такое, зачем он нужен, пример использования предиката?
51. Функтор, что это такое, зачем он нужен, пример функтора считающего свои вызовы?
52. Лямбда функции, что это такое, зачем нужно, пример простой лямбда функции в качестве предиката любого стандартного алгоритма?
53. Структура объявления лямбда функции, минимальное объявление лямбда функции?
54. Исключения, примеры, отлов исключений в С++, сигнатура использования try catch?
55. Порождение исключений, собственные классы исключений, отлов исключений конкретного типа?
56. Производительность исключений, как часто следует их использовать, легковесные исключения, порядок отлова исключений?

Примеры практических заданий:
---------
- Выделить память под трехмерный массив.
- Написать класс комплексного числа.
- Для класса MyInt хранящего инт переопределить вывод в поток.
- Переопределить оператор суммирования суммирования двух MyInt.
- Написать дружественную функцию копирования хранилища MyArray в вектор.
- Написать свой класс исключение.
- Продемонстрировать работу области видимости.
- Продемонстрировать работу наследования конструкторов?
- Отнаследоваться от класса и переопределить метод вызвав родительский метод.