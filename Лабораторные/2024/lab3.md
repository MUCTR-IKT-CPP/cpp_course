### Лабораторная работа номер 3
----------------------------------


Критериями выполнения базовой части являются:
- Реализация программы, возможность ее запуска, ее взаимодействие с пользователем.
- Выполнение двух и более действий взаимодействия со структурами из пункта 4, предложенными в задании вашего варианта.
- Оформление кода в соответствии с соглашением об именовании. 
- Код можно разбивать на функции, а можно не разбивать.

Критериями усложненного варианта является:
- Реализация всех предложенных в задании действий со структурами.
- Генерация набора структур случайными генераторами в рамках адекватных граничных условий (т.е. работник имеет полноценное ФИО и возраст не превышающий 70 лет, генерируется множество разнообразных банкнот, фигуры генерируются существующими, а размеры не превышающими 100 единиц).
- Все действия реализованы в виде отдельных функций с описанием их документационных строк.

Пример док-строки:
```
/*
 * Суммирование двух чисел
 *
 * @param a первое число.
 * @param b второе число.
 * @return возвращает сумму двух чисел.
 */
double sum(int const a, int const b) {
    return a + b;
}
```


#### Вариант 1

Требуется написать программу, в которой:
1. Будет реализована структура "Работник" с полями:
   * ФИО
   * Пол (Используя перечисление)
   * Год рождения (Структура Даты)
2. Пользователь вводит число N.
3. Создан массив хранящий N работников, кол-во считывается с клавиатуры.
4. Cгенерированы N работников.
5. Написаны функции которые:
   1. Проводит поиск по массиву работников и находит работника по частичному совпадению ФИО (Поиск только от начала фио в целом).
   2. Формирует срез работников из массива по году рождения (больше или меньше).
   3. Выводит распределение работников по полу и возрастным группам (группы выбираются с шагом не менее 5 лет).
   4. Сортирует массив работников по возрасту (учитываются все составляющие даты).

#### Вариант 2

Требуется написать программу, в которой:
1. Будет реализована структура "Банкнота" с полями:
   * Наименование
   * Номинал (из списка заданного перечислением 1, 5, 10, 20, 50, 100, 1000)
   * Курс к рублю
2. Пользователь вводит число N.
3. Создан массив хранящий N банкнот, который будем называть кошельком, кол-во считывается с клавиатуры.
4. Сгенерировано N банкнот различного наминала и валюты.
5. Написаны функции которые:
   1. Подсчитывают общую сумму в рублях хранимую в кошельке.
   2. Формирует срез банкнот с номиналом больше выбранного пользователем и выводит их количество разбивая их по валютам.
   3. Выводит состав кошелька отсортированный по валютам (по алфавиту) и номиналу с количеством каждой существующей банкноты.
   4. Конвертирует все банкноты в рубль через курс набирая итог банкнотами с максимальным номиналом, в случае неровной суммы округляем в большую сторону.


#### Вариант 3

Требуется написать программу, в которой:
1. Будет реализована структура Фигура с полями:
   Тип (Заданны перечислением Квадрат, Шестиугольник (С равными сторонами), Треугольник (Равносторонний), Круг)
   Сторона
2. Пользователь вводит число N.
3. Создан массив хранящий N фигур различного размера и типа.
4. Сгенерировано N фигур различного типа и размера.
5. Написать функции которые:
   1. Подсчитают суммарную площадь фигур.
   2. Подсчитать количество всех типов фигур имеющихся в массиве.
   3. Вывести все фигуры с площадью больше указанной пользователем.
   4. Найти радиус окружности в которую можно вписать все сгенерированные фигуры.

#### Вариант 4

Требуется написать программу, в которой:
1. Будет реализована структура "Строка":
   * Длинна строки
   * Указатель на массив символов строки
2. Пользователь вводит число N.
3. Создан массив хранящий N строк типа "Строка" и массив хранящий N строк типа "std::string".
4. Сгенерировать строки длинной в 50 символов и записать их в оба массива (при генерации использовать только английский алфавит).
5. Написать функции которые:  
   1. Подсчитывают количество повторений определенного символа в массиве.
   2. Ищут максимально длинную повторяющуюся последовательность символов в массиве.
   3. Складывают все строки в массиве в одну итоговую строку того же типа, что и элементы массива.
   4. Ищут сколько раз подстрока, введенная пользователем встречается в массиве.
