### Вариант 1

Вам необходимо реализовать класс оружия, который может стрелять по разному виду мишеней. При этом:
- У оружия есть магазин и он заполняется до максимума патронами.
- Огонь может вестись одиночными или очередями, при этом цель соответственно может получать урон либо от каждого патрона по очереди при стрельбе одиночными, либо от группы патронов при стрельбе очередью.
- Шанс попадания по цели лежит в границах от 0 до 1(double) и рассчитывается на основании параметров цели (зависит от видимости мишени и ее движения).
- При стрельбе генерируется случайное число в том же интервале значений, которое сверяется с шансом и если оно больше, то попадание засчитывается, меньше не засчитывается.
- Мишень может иметь ряд характеристик: расстояние до мишени на стрельбище, размер (площадь мишени, рассчитывается в зависимости от геометрии мишени, определяется разработчиком), форма мишени, материал (отсвечивает или нет), видимость мишени на стрельбище (зависит от расстояния, размера, материала, значит является расчетным), некоторые мишени могут быть движущимися, что влияет на шанс попадания по цели. 
- Количество мишеней на стрельбище генерируется случайным образом, при этом их варианты генерируется случайным образом и хранятся так, что работа с ними не зависит от их реального типа.
- Каждая мишень имеет параметр предельного количества попаданий, который определяет после какого количества выстрелов мишень разрушается и перестает быть доступной для стрельбы.
- Любая цель должна иметь следующие методы
  - Предоставления шанс попадания по цели
  - Получение урона, принимает в себя количество попаданий
  - Предоставление доступности для дальнейшей стрельбы

Требуется:
1. Реализовать класс стрельбища, на котором будет находится оружие и мишени.
2. Реализовать интерфейсный или абстрактный класс мишени и несколько конкретных классов мишеней. Каждый класс должен иметь свои характеристики, которые могут пересекаться с другими классами, но должна быть хотя бы 1 уникальная, которая будет влиять на расчет шанса попадания, а также разный порог попаданий.
3. Провести симуляцию стрельбы из оружия по мишени в течении 1 минуты. Скорострельность одиночного режима и режима стрельбы очередями генерировать для оружия перед началом симуляции, при это в процессе режим стрельбы может изменится с некоторым шансом определяемым разработчиком.
4. В конце вывести количество разрушенных мишеней, количество оставшихся, средний урон, нанесенный по мишеням.

### Вариант 2

Вам необходимо реализовать некоторое количество классов оружий которые будут тестироваться пользователем на стрельбище с целью его подбора. При этом:
- У каждого оружия есть свой магазин и вариант его перезарядки со своим временем требуемым на его перезарядку
- пистолет перезаряжается быстро, простым изъятием магазина и вставкой нового
- однозарядная винтовка, перезаряжается по 1 патрону
- помповый дробовик имеет несъемный магазин и поэтому перезаряжается по 1 патрону до заполнения всего магазина
- дробовики и винтовки со съемными магазинами перезаряжаются подобно пистолетам
- Каждое оружие имеет следующие характеристики:  как калибр, количество патронов, количество режимов стрельбы, вес, прицельная дальность стрельбы, отдельные экземпляры кучность стрельбы, количество устанавливаемых модификаций.
- Шанс попадания по мишени зависит исключительно от расстояния до нее и характеристик самого оружия, так дробовик имеет практически 0 вероятность попасть в мишень в полукилометре, пистолет на том же расстоянии имеет незначительный шанс попадания, штурмовая винтовка средние шансы, а снайперская винтовка очень приличные шансы. В итоге шанс зависит от прицельной дальности стрельбы конкретного оружия. Формулу расчета шанса попадания требуется придумать, так чтобы она описывалась графиком в котором точка максимальной прицельной дальности стрельбы соответствовала бы 100% шансу попадания из этого оружия, а дальше резко падала в зависимости от расстояния,  для этого можно использовать обратную экспоненты, для которой точка 0.1 будет прицельной дальностью, а дальше будет резко падать но никогда не приблизится к 0.
- Шанс попадания каждый последующим выстрелом для режима стрельбы очередями должен падать.
- Любое оружие должно предоставлять следующие методы:
  - Зарядка магазина, на вход принимается количество патронов на выходе выдается время зарядки, при этом количество патроном не должно превышать максимальный объем магазина, но может быть меньше.
  - Стрельба по мишени одним из режимов стрельбы, при этом оружие на вход получает мишень, а на выходе выдает количество попаданий по цели
  - Вывод характеристик оружия
Требуется:
1. Реализовать класс стрельбища на котором будет находится оружие и мишени одного типа на разном расстоянии от стрелка.
2. Реализовать интерфейсный или абстрактный класс оружия и несколько его конечных вариантов.
3. Провести симуляцию проверки работоспособности оружия стрелком, при проверки работоспособности оружия, требуется вывести информацию о нем, а также провести стрельбы на все расстояния, по каждой мишени требуется совершить по 100 выстрелов и замерить среднюю скорострельность в минуту(с учетом времени перезарядки на все выстрелы) и точность на каждое из доступных расстояний мишеней. 
4. В конце симуляции вывести собранную статистику по всем оружиям.


### Вариант 3

Вам необходимо реализовать механизм проверяемого ввода данных с потока ввода.
При этом:
- Существует интерфейсный класс ввода который будет иметь только 1 метод:
  - Считывание с потока ввода >>
- Существует интерфейсный класс валидатора, который будет иметь только 1 метод:
  - Проверка считанного значения(принимает в себя значение)
- Существует несколько классов считывания значений для типов: int, double, bool, string, char, array, при этом у каждого ввода должен быть строго определен свой формат, если формат не соблюден считывание должен повторятся до тех пор пока пользователь не прервет его вводом какого либо спец символа(выбираем на свое усмотрение, можно например CTRL+D признак конца ввода).
- Существует несколько классов валидаторов например проверка больше меньше какого либо значения, проверка на формат строки, проверка на соответствие определенному символу.
- Весь процесс считывания тогда будет выглядеть следующим образом, из потока ввода считываем данные в класс считыватель который проверяет их на соответствие типу, если не возникает ошибки ввода, тогда вызывается проверка на соответствие дополнительным правилам, которые заранее подаются в считыватель при помощи конструктора.
- Считыватель может принимать в качестве аргумента конструктора параметр определяющий реакцию на ошибку ввода, который будет при своем наличии требовать немедленного завершения программы в случае ошибки. 
Требуется:
1. Реализовать интерфейсные классы считывателя и валидаторов, а также несколько конечных реализаций.
2. Реализовать конвейер считывания информации, в котором будет производиться последовательное считывание из потока ввод нескольких данных разного формата с разным набором дополнительных проверок.
3. Провести тестовое считывание данных из файлов (с ошибкой (аварийное завершение программы) и без ошибок) и из стандартного потока ввода с ошибками при повторяющемся ввода.


```cpp
#include <istream>

class Validator{
  public:
    bool validate(void* value);
}

class IntValidatorExample: public Validator {
  public:
    bool validate(void* value){
      int* int_value = (int*)value;
      // or
      int int_value = (int)(*value);
      // checks
    }
}

class Reader {
  public:
    void read(istream& in) = 0;
    friend istream& operator>>(istream& in, Reader* r);
    friend istream& operator>>(istream& in, Reader& r);
}

istream& operator>>(istream& in, Reader* r){
  r.read(in);
  return in;
}
istream& operator>>(istream& in, Reader& r){
  return in >> &r;
}

class IntReader: public {
  vector<Validator*>* validators;
  int* readable;
  public:
    IntReader(int* readable, vector<Validator*>* validators):
      readable(readable), validators(validators){

      }
    void read(istream& in){
      // проверка ввода
      // вызов валидаторо в цикле
      // если все ок, запись результата в переменную скрытую за указателем readable
    };
}


```