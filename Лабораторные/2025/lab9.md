### Лабораторная работа номер 9
----------------------------------

### Вариант 1

Базовый вариант:

1. Контейнер и данные: Создай vector, содержащий 20 случайных целых чисел в диапазоне от -100 до 100.
2. Обработка лямбдой и алгоритмом: Используя алгоритм for_each и лямбда-функцию без захвата, выведи все элементы вектора в консоль в одну строку, разделенные запятыми.
3. Сортировка с предикатом: Отсортируй вектор по убыванию, используя алгоритм sort и лямбда-функцию в качестве бинарного предиката.
4. Поиск по условию: Используя алгоритм find_if, найди первый элемент, который является четным и положительным. Выведи его и его индекс (или итератор) в консоль.

Усложненный вариант:

1. Замыкание для статистики: Модифицируй лямбда-функцию из шага 2 базового варианта. Добавь захват по ссылке двух внешних целочисленных переменных: positive_count и negative_count. При выводе каждого элемента лямбда должна увеличивать соответствующую переменную-счетчик. После выполнения for_each выведи значения этих счетчиков.
2. Функция высшего порядка: Напиши функцию высшего порядка createStatisticsLambda, которая возвращает лямбда-функцию. Эта лямбда должна захватывать по значению параметр threshold (порог) и принимать на вход число. При вызове она должна возвращать true, если число больше порога, и false в противном случае.
3. Применение функции высшего порядка: Используй возвращенную функцию для подсчета количества элементов в векторе, больших заданного порога (например, 50), с помощью алгоритма count_if. Выведи результат.

---

### Вариант 2

Базовый вариант:

1. Контейнер и данные: Создай list из 15 случайных строк. Строки должны генерироваться из набора символов "abcde" случайной длины от 3 до 7 символов.
2. Алгоритм преобразования: Используя алгоритм transform и лямбда-функцию, преобразуй все строки в списке, сделав первый символ каждой строки заглавным.
3. Удаление по условию: Используя алгоритм remove_if и лямбда-функцию, удали из списка все строки, длина которых меньше 5 символов.
4. Стабильная сортировка: Отсортируй список в лексикографическом порядке с помощью stable_sort.

Усложненный вариант:

1. Замыкание для модификации: Создай локальную переменную char_to_remove (символ для удаления). Напиши лямбда-функцию, которая захватывает эту переменную по значению и принимает строку. Лямбда должна использовать алгоритм remove и erase (в своем теле) для удаления всех вхождений char_to_remove из переданной строки и возвращать измененную строку.
2. Применение с transform: Примени эту лямбда-функцию с помощью transform ко всему списку, чтобы удалить, например, символ 'b' из всех строк.
3. Генерация с состоянием: Используя алгоритм generate и лямбда-функцию с захватом по ссылке внешнего генератора случайных чисел, перегенерируй первые 5 элементов списка новыми случайными строками.

---

### Вариант 3

Базовый вариант:

1. Контейнер и данные: Создай vector пар (pair), где первый элемент — случайное целое число (от 1 до 10), а второй — случайное число с плавающей точкой (от 0.0 до 1.0). Заполни вектор 25 такими парами.
2. Поиск минимума/максимума: Используя алгоритм min_element с лямбда-функцией, найди пару с наименьшим целочисленным значением. Аналогично найди пару с наибольшим дробным значением.
3. Группировка (partition): Используя алгоритм partition и лямбда-функцию, переставь элементы вектора так, чтобы в начале оказались все пары, у которых дробная часть больше 0.5.
4. Суммирование: Используя алгоритм accumulate и лямбда-функцию, посчитай сумму всех целочисленных элементов в парах.

Усложненный вариант:

1. Замыкание для агрегации: Создай внешнюю структуру Statistics с полями sum_int, sum_double, count. Напиши лямбда-функцию, которая захватывает эту структуру по ссылке. Лямбда должна принимать пару и добавлять ее значения к полям структуры.
2. Итерация и агрегация: С помощью for_each примени эту лямбда-функцию ко всему вектору. Выведи полученные средние значения (для целых и для дробных).
3. Функция высшего порядка для фильтрации: Напиши функцию createFilter, которая принимает пороговое значение для дробной части и возвращает лямбда-функцию-предикат. Эта лямбда должна проверять, что дробная часть пары больше переданного порога. Используй эту функцию для подсчета количества таких пар с помощью count_if.

---

### Вариант 4

Базовый вариант:

1. Контейнер и данные: Создай map, где ключ — это номер (целое число от 1 до N), а значение — это vector из 5 случайных целых чисел (от 1 до 100).
2. Обработка вложенных контейнеров: Используя вложенный цикл for_each и лямбда-функции, выведи содержимое всей мапы в читаемом виде (ключ: [значения]).
3. Алгоритм для каждого элемента: Для каждого вектора в мапе отсортируй его по возрастанию, используя sort и лямбду внутри алгоритма for_each, применяемого к мапе.
4. Поиск по ключу и значению: Найди в мапе элемент по ключу. Затем в найденном векторе используй find_if, чтобы найти первое число, кратное 7.

Усложненный вариант:

1. Замыкание для сложной логики: Объяви внешний vector для хранения "особых" чисел. Напиши лямбда-функцию, которая захватывает этот вектор по ссылке. Эта лямбда должна принимать пару (ключ и вектор) из мапы. Она должна проверять, есть ли в векторе числа, попадающие в определенный диапазон (например, от 80 до 100). Если да, то добавлять эти числа в внешний вектор.
2. Сбор данных: С помощью for_each примени эту лямбду ко всем элементам мапы. Выведи собранный вектор "особых" чисел.
3. Шаблонная функция: Сделай функцию вывода содержимого мапы (из шага 2 базового варианта) шаблонной, чтобы она могла работать с map любого типа, если для его ключей и значений определен оператор <<.

---

### Вариант 5

Базовый вариант:

1. Контейнер и данные: Создай set из 30 случайных целых чисел (от 1 до 50).
2. Проверка на вхождение: Используя алгоритм includes, проверь, содержится ли небольшой заранее заданный vector чисел (например, [5, 10, 15]) внутри сета.
3. Удаление по сложному условию: Используя алгоритм erase_if (или комбинацию remove_if и erase для других контейнеров) и лямбда-функцию, удали из сета все числа, которые не являются простыми. (Функцию проверки на простоту нужно написать отдельно, можно вызывать ее из лямбды).
4. Объединение множеств: Создай второй set и выполни его объединение с первым, используя алгоритм set_union. Результат запиши в третий сет.
   Усложненный вариант:
5. Замыкание для кэширования: Реализуй проверку на простоту с помощью лямбда-функции с захватом. Лямбда должна захватывать по ссылке внешний unordered_map (кэш), где ключ 1 число, значение 1 булево (простое/нет). Перед вычислением лямбда должна проверять, есть ли число в кэше.
6. Оптимизированное удаление: Используй эту лямбду в алгоритме удаления из Базового Варианта (шаг 3). Сравни производительность (по количеству операций) до и после использования кэша для большого набора данных (можно увеличить N до 1000).
7. Генератор с замыканием: Создай лямбда-функцию-генератор, которая захватывает по ссылке внешний генератор случайных чисел и предыдущее сгенерированное значение. При каждом вызове она должна возвращать следующее число Фибоначчи. Используй ее с generate_n, чтобы заполнить vector первыми 15 числами Фибоначчи.

---

### Вариант 6

Базовый вариант:

1. Контейнер и данные: Создай vector из 100 случайных целых чисел в диапазоне от 0 до 9.
2. Подсчет частот: Используя алгоритм count_if и 10 различных лямбда-функций (или одну, захватывающую параметр), подсчитай количество вхождений каждой цифры (от 0 до 9) в вектор. Результаты сохрани в отдельный vector или array.
3. Поиск последовательности: Используя алгоритм search, найди в векторе первую последовательность из трех пятерок подряд ({5, 5, 5}).
4. Замена элементов: Используя алгоритм replace_if, замени все четные числа в векторе на значение -1.

Усложненный вариант:

1. Замыкание для гистограммы: Создай внешний map, где ключ — цифра, а значение — количество ее вхождений. Напиши лямбда-функцию, которая захватывает эту мапу по ссылке. Лямбда должна принимать число и увеличивать соответствующий счетчик в мапе.
2. Построение гистограммы: С помощью for_each примени эту лямбду ко всему вектору. Выведи получившуюся гистограмму (цифра: количество).
3. Функция высшего порядка для генерации предиката: Напиши функцию createRangePredicate, которая принимает нижнюю и верхнюю границу и возвращает лямбда-функцию. Эта лямбда должна проверять, попадает ли число в этот диапазон. Используй ее, чтобы с помощью count_if посчитать количество чисел в векторе, попадающих в диапазон [3, 7].

---

### Вариант 7

Базовый вариант:

1. Контейнер и данные: Создай deque из 20 объектов пользовательского класса Student, содержащего поля name (строка) и average_grade (дробное число). Данные можно сгенерировать случайно.
2. Сортировка по полю: Отсортируй дек по убыванию среднего балла, используя sort и лямбда-функцию, обращающуюся к полю average_grade.
3. Поиск по критерию: Используя find_if, найди первого студента, чье имя начинается с буквы 'А' и средний балл которого выше 4.0.
4. Копирование по условию: Используя copy_if, скопируй всех студентов с баллом выше 4.5 в новый vector.

Усложненный вариант:

1. Замыкание для модификации объектов: Создай внешнюю переменную grade_bonus (надбавка к баллу). Напиши лямбда-функцию, которая захватывает эту переменную по значению и принимает ссылку на Student. Лямбда должна увеличивать средний балл студента на значение grade_bonus.
2. Массовая модификация: Примени эту лямбду ко всем студентам в деке с помощью for_each. Выведи список студентов до и после применения надбавки.
3. Функция высшего порядка для компаратора: Напиши функцию createGradeComparator, которая принимает булев параметр ascending и возвращает лямбда-функцию для сравнения двух студентов. Эта лямбда должна сравнивать студентов по баллу в порядке, заданном параметром. Используй ее для сортировки вектора "отличников" из шага 4 Базового Варианта.

---

### Вариант 8

Базовый вариант:

1. Контейнер и данные: Создай vector из 50 случайных целых чисел (от 1 до 20).
2. Удаление дубликатов: Скопируй вектор в list и с помощью методов sort и unique удали дубликаты из списка.
3. Числовые алгоритмы: Вычислий сумму, произведение и среднее арифметическое элементов исходного вектора, используя алгоритмы accumulate и соответствующие лямбда-функции.
4. Генерация части последовательности: Используя generate и лямбда-функцию, которая возвращает случайное число, возведенное в квадрат, заполни первые 10 элементов вектора.

Усложненный вариант:

1. Замыкание для аккумуляции сложных данных: Создай внешнюю структуру AggregateData с полями: min, max, sum. Напиши лямбда-функцию, которая захватывает экземпляр этой структуры по ссылке. Лямбда должна обновлять поля структуры при обработке каждого числа (искать минимум, максимум, аккумулировать сумму).
2. Однопроходная агрегация: С помощью for_each и этой лямбды вычисли минимум, максимум и сумму элементов вектора за один проход. Выведи результаты.
3. Шаблонная функция высшего порядка: Напиши шаблонную функцию createAggregator, которая возвращает лямбда-функцию. Эта лямбда должна захватывать внешнюю переменную initial_value и операцию (например, std::plus или std::multiplies). Она должна аккумулировать переданные ей значения, начиная с initial_value, применяя указанную операцию. Продемонстрируй ее работу для вычисления суммы и произведения.
