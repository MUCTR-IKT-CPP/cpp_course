# Лабораторная работа номер 7
----------------------------------
# Вариант 1 — Геометрические фигуры и единицы измерения

**Идея:** реализовать шаблонные классы фигур (Rectangle, Circle), интерфейс IShape, а затем добавить поддержку единиц измерения и агрегатор Scene.

## Базовый вариант

1. Создать интерфейс IShape со следующими методами:
   - `double area() const` — возвращает площадь фигуры
   - `std::string name() const` — возвращает имя фигуры

2. Создать концепт Numeric, который допускает только целые и вещественные типы данных.

3. Реализовать шаблонные классы:
   - `Rectangle<T>` с полями ширина и высота
   - `Circle<T>` с полем радиус

4. Описание поведения:
   - Метод `area()` должен возвращать площадь в стандартных единицах измерения (width * height или πr²)
   - Метод `name()` должен возвращать строки "Rectangle" или "Circle" соответственно

5. В функции `main()` создать несколько фигур разных типов и вывести информацию об их названии и площади.

## Усложнённый вариант

1. Создать шаблон `Quantity<T, Unit>` с полем value:
   - Метод `get()` возвращает числовое значение
   - Реализовать операцию сложения только для одинаковых единиц измерения

2. Определить классы единиц измерения: `Meters` и `Centimeters`

3. Создать специализированные версии фигур `RectangleWithUnits<T, Unit>` и `CircleWithUnits<T, Unit>` с размерами, выраженными через `Quantity`

4. Создать класс `Scene`, который агрегирует вектор `std::unique_ptr<IShape>`:
   - Метод `add()` добавляет фигуру в сцену
   - Метод `total_area()` вычисляет суммарную площадь всех фигур

5. Описание поведения:
   - Метод `total_area()` должен суммировать площади всех добавленных фигур и возвращать результат типа `double`

# Вариант 2 — Плагинный процессор сообщений с политиками логирования

**Идея:** система обработки сообщений с политиками логирования и агрегатором MessageBus.

## Базовый вариант

1. Создать интерфейс `IMessage` с методом `type()`

2. Реализовать класс `TextMessage`, содержащий строку content:
   - Метод `type()` возвращает "Text"

3. Создать интерфейс `IMessageHandler` с методом `handle(const IMessage&)`

4. Создать две политики логирования:
   - `ConsoleLoggingPolicy` — выводит сообщение "Processing message: <type>" в консоль
   - `SilentPolicy` — не выполняет никаких действий

5. Создать шаблонный класс `MessageProcessor<Policy>`, который наследует `IMessageHandler` и использует поведение из выбранной политики

6. Поведение: при вызове `handle()` обработчик должен вывести сообщение о типе входящего сообщения (если используется логирующая политика)

## Усложнённый вариант

1. Создать класс `MessageBus`, который агрегирует обработчики:
   - Метод `subscribe()` добавляет обработчик
   - Метод `publish()` вызывает метод `handle()` у всех подписанных обработчиков

2. Создать CRTP-обработчик:
   - Шаблон `HandlerCRTP<Derived>` с методом `handle()`, вызывающим `Derived::process()`
   - Пример: `JsonHandler`, в котором метод `process()` должен выводить JSON-строку с типом сообщения:
     ```json
     { "type": "<message_type>" }
     ```

3. Поведение: при вызове `publish()` все подписанные обработчики должны отреагировать на сообщение в соответствии со своей политикой

# Вариант 3 — Фабрика игровых сущностей с политиками поведения

**Идея:** создание игровых персонажей (NPC) с шаблонными политиками поведения (AI и физика) и миром World, который агрегирует сущности.

## Базовый вариант

1. Создать интерфейс `IEntity` с методами `update(double dt)` и `name()`

2. Создать концепты `AIModel` и `PhysicsModel`, проверяющие наличие методов `decide()` и `apply()` соответственно

3. Реализовать классы:
   - `SimpleAI` с методом `decide(IEntity&)`
   - `SimplePhysics` с методом `apply(IEntity&, double)`

4. Реализовать шаблонный класс `NPC<A, P>`, наследующий `IEntity`

5. Описание поведения:
   - `SimpleAI::decide()` должен выводить сообщение о том, что персонаж думает
   - `SimplePhysics::apply()` — сообщение о том, что персонаж перемещается на dt единиц

## Усложнённый вариант

1. Создать класс `World`, который агрегирует вектор `std::unique_ptr<IEntity>`:
   - Метод `add()` добавляет сущность
   - Метод `tick(double dt)` вызывает `update(dt)` у всех сущностей

2. Создать два класса поведения:
   - `AggressiveAI` — метод `decide()` должен выводить сообщение "Персонаж атакует врага!"
   - `PassiveAI` — метод `decide()` должен выводить сообщение "Персонаж избегает боя и восстанавливает силы."

3. Поведение:
   - `World::tick()` вызывает поведение всех NPC
   - Каждый NPC отображает своё имя и реакцию

# Вариант 4 — Коллекция контейнеров с итераторами и CRTP

**Идея:** создание шаблонного контейнера Array, интерфейса IContainer, агрегатора Collection и сортировки через CRTP.

## Базовый вариант

1. Создать интерфейс `IContainer` с методами `size()` и `at(index)`

2. Реализовать шаблон `Array<T, N>`, реализующий `IContainer`

3. Реализовать вложенный класс `Iterator`, предоставляющий итерацию по элементам

4. Поведение:
   - Конструктор `Array` должен принимать `std::initializer_list<T>`
   - Метод `at()` возвращает элемент по индексу
   - Итератор должен позволять проходить по элементам в цикле

## Усложнённый вариант

1. Создать класс `Collection`, агрегирующий `std::vector<std::shared_ptr<IContainer>>`:
   - Метод `add()` добавляет контейнер
   - Метод `flatten()` возвращает вектор со всеми элементами всех контейнеров

2. Создать шаблон `Sortable<Derived>` с методом `sort()`

3. Реализовать `SortableArray`, который наследует `Array` и `Sortable`

4. Поведение:
   - Метод `sort_impl()` в потомке должен сортировать данные по возрастанию
   - Метод `flatten()` должен возвращать объединённый список всех элементов всех контейнеров в порядке их добавления

# Вариант 5 — Менеджер ресурсов с политиками загрузки

**Идея:** шаблонный менеджер ресурсов ResourceManager с политиками загрузки и агрегатором ResourceCollection.

## Базовый вариант

1. Создать интерфейс `IResource` с методом `id()`

2. Реализовать пример ресурса: `Texture` с именем

3. Создать концепт `Loader`, проверяющий наличие метода `load(std::string)`

4. Реализовать шаблон `ResourceManager<Resource, Loader>`

5. Поведение:
   - Метод `get(id)` должен искать ресурс в кэше
   - Если ресурс не найден — вызывать метод `load()` из политики и добавить результат в кэш

## Усложнённый вариант

1. Реализовать две политики загрузки:
   - `FileLoader`: при вызове `load()` выводит сообщение "Загрузка ресурса из файла <имя>"
   - `DummyLoader`: при вызове `load()` выводит "Создание заглушки ресурса <имя>"

2. Создать класс `ResourceCollection`, агрегирующий несколько менеджеров

3. Поведение:
   - Метод `load_all()` вызывает `get()` у обоих менеджеров
   - После вызова в консоли должны появиться сообщения о загрузке и создании заглушек

# Вариант 6 — Система метрик и телеметрии

**Идея:** реализовать шаблонные метрики, агрегатор Telemetry и политики отправки отчётов.

## Базовый вариант

1. Создать интерфейс `IMetric` с методами `name()` и `value()`

2. Реализовать шаблон `Metric<T, Unit>` с полями `val` и `metric_name`

3. Поведение:
   - Метод `value()` возвращает числовое значение метрики
   - Метод `name()` возвращает её имя

4. Создать классы единиц измерения `Seconds` и `Milliseconds`

## Усложнённый вариант

1. Создать класс `Telemetry`, агрегирующий `std::vector<std::unique_ptr<IMetric>>`:
   - Метод `add()` добавляет метрику
   - Метод `report()` формирует строку отчёта вида:
     ```
     metric_name=value
     ```

2. Реализовать политики отправки:
   - `NoCompression`: метод `send()` выводит полный отчёт
   - `SimpleCompression`: метод `send()` выводит длину отчёта, делённую на 2

3. Создать шаблон `TelemetrySender<Policy>`, вызывающий `Policy::send()`

4. Поведение:
   - `Telemetry::report()` должен собирать все метрики в одну строку
   - `TelemetrySender<NoCompression>` выводит полный отчёт, `TelemetrySender<SimpleCompression>` — сообщает длину сжатого отчёта

# Вариант 7 — Типобезопасная работа с валютами

**Идея:** шаблон Money<T, Currency>, агрегатор Wallet, политика конвертации FixedRateConverter.

## Базовый вариант

1. Создать концепт `CurrencyTag` с проверкой наличия поля `code`

2. Реализовать классы валют `USD`, `EUR`

3. Создать шаблон `Money<T, C>` с полем `amount`

4. Поведение:
   - Конструктор принимает значение суммы
   - Оператор `+` разрешён только между одинаковыми валютами и возвращает новую сумму

## Усложнённый вариант

1. Создать класс `FixedRateConverter` с методом `rate(from, to)`:
   - Для пары USD/EUR задать курс (например, 1 USD = 0.9 EUR)

2. Реализовать шаблон `Wallet<Converter>` с картой валют и сумм:
   - Метод `add(currency, amount)` увеличивает баланс
   - Метод `total_in(base_currency)` пересчитывает все суммы в базовую валюту

3. Поведение:
   - При вызове `total_in("USD")` программа должна вывести общую сумму в долларах, пересчитав по заданным курсам

# Вариант 8 — Система команд с шаблонной диспетчеризацией

**Идея:** шаблонная система команд с обработчиками и диспетчером.

## Базовый вариант

1. Создать интерфейс `ICommand` с методом `name()`

2. Реализовать пример команды `CreateUserCommand` с именем пользователя

3. Создать интерфейс `ICommandHandler<Cmd>` с методом `handle(const Cmd&)`

4. Поведение:
   - При вызове `handle()` должен выводиться текст "Создан пользователь <имя>"

## Усложнённый вариант

1. Реализовать шаблон `HandlerCRTP<Derived, Cmd>` с методом `handle()`, вызывающим `Derived::process()`

2. Создать `CreateUserHandler`, в котором метод `process()` выводит "Пользователь создан: <имя>"

3. Реализовать класс `Dispatcher`, агрегирующий обработчики:
   - Метод `register_handler(name, handler)` добавляет обработчик
   - Метод `dispatch(cmd)` вызывает `handle()` у всех обработчиков, зарегистрированных под данным именем команды

4. Поведение:
   - При вызове `dispatch(CreateUserCommand("Bob"))` обработчик должен напечатать "Пользователь создан: Bob"
