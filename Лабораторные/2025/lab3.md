# Лабораторная работа номер 3

**Тема:** Работа с пользовательскими типами данных (структурами), массивами структур и алгоритмами их обработки.

## Описание

Основной частью всех вариантов является написание программы, которая решает поставленную задачу и выводит результат в терминал. Программа должна быть корректной, аккуратно оформленной и сопровождаться комментариями. Код программы должен быть размещен в репозитории на github.

**Критерии выполнения базовой части:**

* Реализация программы, возможность её запуска, взаимодействие с пользователем.
* Выполнение двух и более действий взаимодействия со структурами из пункта 5 предложенного варианта.
* Оформление кода в соответствии с соглашением об именовании (например, `snake_case` или `camelCase`).
* Код можно разбивать на функции, а можно не разбивать.

**Критерии усложненного варианта:**

* Реализация **всех** предложенных в задании действий со структурами.
* Генерация набора структур случайными генераторами в рамках адекватных граничных условий (например, возраст человека не может быть отрицательным, рейтинг фильма находится в разумных пределах).
* Все действия реализованы в виде отдельных функций с описанием их документационных строк (docstring).


**Пример док-строки:**
```cpp
/**
 * Calculates the sum of two integers.
 *
 * @param a The first integer to add.
 * @param b The second integer to add.
 * @return The sum of a and b.
 */
int calculate_sum(int a, int b) {
    return a + b;
}
```

---

## Вариант 1: «Система управления контентом»

1. Реализуйте структуру `MediaFile` с полями:
    * `id` (уникальный идентификатор, целое число)
    * `filename` (строка)
    * `size` (размер в мегабайтах, число с плавающей точкой)
    * `type` (перечисление: `Audio`, `Video`, `Image`, `Document`)
    * `creation_date` (структура `Date` с полями день, месяц, год).

2. Пользователь вводит целое число `N`.

3. Программа создаёт массив (вектор) из `N` элементов типа `MediaFile`.

4. Программа заполняет массив сгенерированными случайным образом данными.

5. Реализуйте следующие функции для работы с массивом:
    1. **Поиск по имени:** находит все файлы, имя которых содержит подстроку, введённую пользователем (без учёта регистра).
    2. **Фильтр по типу и размеру:** формирует новый массив файлов указанного пользователем типа и размером больше заданного значения.
    3. **Статистика:** выводит общее количество файлов, их суммарный размер, а также распределение файлов по типам (например: `Video: 5, Audio: 3, ...`).
    4. **Сортировка:** сортирует массив по дате создания (от newest к oldest), а при совпадении дат — по имени файла в алфавитном порядке.

**Усложнение:** Реализуйте функцию для сохранения отсортированного массива в текстовый файл и его загрузки оттуда.

---

## Вариант 2: «Платформа для онлайн-курсов»

1. Реализуйте структуру `Course` с полями:
    * `title` (название курса, строка)
    * `instructor` (имя преподавателя, строка)
    * `duration` (продолжительность в часах, целое число)
    * `rating` (рейтинг от 0.0 до 5.0, число с плавающей точкой)
    * `price` (стоимость в условных единицах, число с плавающей точкой)
    * `is_advanced` (флаг, указывающий, является ли курс продвинутым).

2. Пользователь вводит целое число `N`.

3. Программа создаёт массив (вектор) из `N` элементов типа `Course`.

4. Программа заполняет массив сгенерированными случайным образом данными.

5. Реализуйте следующие функции для работы с массивом:
    1. **Рекомендация:** находит все курсы с рейтингом выше указанного пользователем значения и стоимостью ниже указанной.
    2. **Сравнение по продолжительности:** выводит название и продолжительность самого короткого и самого длинного курса в каталоге.
    3. **Группировка:** подсчитывает и выводит средний рейтинг для базовых (`is_advanced = false`) и для продвинутых (`is_advanced = true`) курсов.
    4. **Сортировка:** сортирует массив по рейтингу (по убыванию), а при совпадении рейтинга — по цене (по возрастанию).

**Усложнение:** Реализуйте функцию, которая "покупает" курсы, останавливая выбор на курсах с наилучшим соотношением рейтинга и цены, до достижения ограничения по бюджету и суммарной продолжительности обучения.

---

## Вариант 3: «Система мониторинга метеоданных»

1. Реализуйте структуру `WeatherReading` с полями:
    * `city` (название города, строка)
    * `temperature` (температура в °C, число с плавающей точкой)
    * `humidity` (влажность в %, целое число)
    * `pressure` (давление в мм рт. ст., число с плавающей точкой)
    * `timestamp` (время измерения, можно использовать строку в формате "YYYY-MM-DD HH:MM" или структуру `DateTime`).

2. Пользователь вводит целое число `N`.

3. Программа создаёт массив (вектор) из `N` элементов типа `WeatherReading`.

4. Программа заполняет массив сгенерированными случайным образом данными для разных городов и времени.

5. Реализуйте следующие функции для работы с массивом:
    1. **Поиск по городу:** находит все записи для указанного города и выводит их в хронологическом порядке.
    2. **Анализ экстремумов:** находит самую высокую и самую низкую температуру во всём массиве, указывая город и время измерения.
    3. **Расчёт средних значений:** для указанного пользователем города вычисляет среднюю температуру, влажность и давление за весь период наблюдений.
    4. **Сортировка:** сортирует массив по названию города (по алфавиту), а для записей одного города — по времени измерения (от старых к новым).

**Усложнение:** Реализуйте функцию, которая определяет, в каком городе зафиксирован наибольший перепад температуры между двумя последовательными измерениями.

---

## Вариант 4: «База данных умных устройств»

1. Реализуйте структуру `SmartDevice` с полями:
    * `device_id` (уникальный идентификатор, целое число)
    * `name` (модель устройства, строка)
    * `type` (перечисление: `Light`, `Thermostat`, `Camera`, `Speaker`, `Sensor`)
    * `is_online` (флаг, указывающий, подключено ли устройство к сети)
    * `last_active` (количество минут с последней активности, целое число).

2. Пользователь вводит целое число `N`.

3. Программа создаёт массив (вектор) из `N` элементов типа `SmartDevice`.

4. Программа заполняет массив сгенерированными случайным образом данными.

5. Реализуйте следующие функции для работы с массивом:
    1. **Проверка состояния:** выводит список всех устройств, которые в данный момент offline (`is_online = false`).
    2. **Поиск по типу:** формирует массив устройств указанного типа и сортирует его по времени последней активности (от самых "старых" к самым "свежим").
    3. **Статистика системы:** подсчитывает общее количество устройств, количество онлайн-устройств, а также количество устройств каждого типа.
    4. **Сортировка:** сортирует массив по типу устройства (в порядке, определённом перечислением), а внутри одного типа — по имени устройства.

**Усложнение:** Реализуйте функцию, которая имитирует команду "Перезагрузить все offline устройства", изменяя их статус на online и сбрасывая счётчик `last_active` до нуля.

---

### Вариант 5: «Библиотечный каталог»

1. Реализуйте структуру `Book` с полями:
    * `isbn` (уникальный идентификатор, строка формата "XXX-X-XXX-XXXXX-X")
    * `title` (название книги, строка)
    * `author` (имя автора, строка)
    * `year` (год публикации, целое число)
    * `is_available` (флаг, доступна ли книга для выдачи)
    * `pages` (количество страниц, целое число).

2. Пользователь вводит целое число `N`.

3. Программа создаёт массив (вектор) из `N` элементов типа `Book`.

4. Программа заполняет массив сгенерированными случайным образом данными.

5. Реализуйте следующие функции для работы с массивом:
    1. **Поиск по автору и названию:** находит все книги, в авторстве или названии которых содержится подстрока, введённая пользователем.
    2. **Фильтр по году:** формирует массив книг, опубликованных в указанный пользователем период (между двумя годами).
    3. **Статистика:** подсчитывает и выводит общее количество книг, среднее количество страниц, а также количество доступных и недоступных книг.
    4. **Сортировка:** сортирует массив по году публикации (от самых новых к самым старым), а при совпадении года — по фамилии автора.

**Усложнение:** Реализуйте функцию "выдачи" и "возврата" книги, которая изменяет статус `is_available` по её `isbn`. Добавьте проверку на корректность операций (нельзя выдать уже выданную книгу).

---

### Вариант 6: «База данных игровых персонажей»

1. Реализуйте структуру `GameCharacter` с полями:
    * `name` (имя персонажа, строка)
    * `character_class` (перечисление: `Warrior`, `Mage`, `Rogue`, `Cleric`)
    * `level` (уровень, целое число от 1 до 60)
    * `health` (здоровье, целое число)
    * `mana` (мана, целое число)
    * `inventory` (указатель на массив строк - названия предметов, или `std::vector<std::string>`).

2. Пользователь вводит целое число `N`.

3. Программа создаёт массив (вектор) из `N` элементов типа `GameCharacter`.

4. Программа заполняет массив сгенерированными случайным образом данными. Для инвентаря каждого персонажа сгенерируйте от 0 до 5 случайных предметов.

5. Реализуйте следующие функции для работы с массивом:
    1. **Поиск предмета:** находит всех персонажей, у которых в инвентаре есть указанный пользователем предмет.
    2. **Сравнение характеристик:** для указанного пользователем класса персонажей находит персонажа с максимальным и минимальным уровнем.
    3. **Анализ инвентаря:** подсчитывает и выводит общее количество уникальных предметов во всем массиве персонажей и самый часто встречающийся предмет.
    4. **Сортировка:** сортирует массив по уровню (по убыванию), а при совпадении уровня — по количеству предметов в инвентаре (по убыванию).

**Усложнение:** Реализуйте функцию "экипировки предмета", которая добавляет случайный предмет в инвентарь всем персонажам указанного класса.

---

### Вариант 7: «Система учета финансовых транзакций»

1. Реализуйте структуру `FinancialTransaction` с полями:
    * `transaction_id` (уникальный идентификатор, целое число)
    * `amount` (сумма транзакции, число с плавающей точкой)
    * `currency` (валюта, перечисление: `USD`, `EUR`, `RUB`, `CNY`)
    * `type` (тип операции: `Income`, `Expense`)
    * `category` (категория операции, строка, например: "Food", "Salary", "Transport")
    * `date` (структура `Date` с полями день, месяц, год).

2. Пользователь вводит целое число `N`.

3. Программа создаёт массив (вектор) из `N` элементов типа `FinancialTransaction`.

4. Программа заполняет массив сгенерированными случайным образом данными.

5. Реализуйте следующие функции для работы с массивом:
    1. **Расчет баланса:** подсчитывает общую сумму доходов и расходов в рублях (конвертируя из других валют по фиксированному курсу) и выводит итоговый баланс.
    2. **Анализ по категориям:** для указанного типа операций (`Income`/`Expense`) выводит список категорий и сумму трат/доходов в каждой.
    3. **Поиск по периоду:** формирует массив транзакций за указанный пользователем месяц и год и выводит его.
    4. **Сортировка:** сортирует массив по дате (от самых старых к самым новым), а при совпадении даты — по сумме (от большей к меньшей).

**Усложнение:** Реализуйте функцию конвертации валют по динамическому курсу (курс для каждой валюты задается в начале программы). Реализуйте сохранение и загрузку массива транзакций в файл.

---

### Вариант 8: «База данных пользователей социальной сети»

1. Реализуйте структуру `SocialMediaProfile` с полями:
    * `username` (уникальное имя пользователя, строка)
    * `age` (возраст, целое число)
    * `number_of_friends` (количество друзей, целое число)
    * `registration_year` (год регистрации, целое число)
    * `is_premium` (флаг, является ли пользователь премиум-подписчиком)
    * `last_login` (количество дней с последнего входа, целое число).

2. Пользователь вводит целое число `N`.

3. Программа создаёт массив (вектор) из `N` элементов типа `SocialMediaProfile`.

4. Программа заполняет массив сгенерированными случайным образом данными.

5. Реализуйте следующие функции для работы с массивом:
    1. **Поиск по активности:** находит всех пользователей, которые не заходили в систему более `X` дней (значение `X` вводит пользователь).
    2. **Анализ аудитории:** подсчитывает и выводит средний возраст пользователей, среднее количество друзей, а также количество премиум-пользователей.
    3. **Поиск "старожилов":** формирует массив пользователей, зарегистрированных не позднее указанного пользователем года, и сортирует их по количеству друзей.
    4. **Сортировка:** сортирует массив по имени пользователя (в алфавитном порядке). Для усложнения, реализуйте сортировку, которая игнорирует регистр символов.

**Усложнение:** Реализуйте функцию "отправки уведомления", которая имитирует отправку сообщения всем пользователям, которые не заходили в систему больше 30 дней. Функция должна выводить список этих пользователей.