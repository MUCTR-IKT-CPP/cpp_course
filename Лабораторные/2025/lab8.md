### Лабораторная работа номер 8
----------------------------------

## Задание 1. Система управления медиа-библиотекой

### Базовый этап  
**От вас требуется реализовать** ядро системы хранения медиа-ресурсов: книги и аудиозаписи. Необходимо создать интерфейсы для медиа и репозитория, а также конкретные классы для хранения данных. Все объекты должны храниться в памяти, поддерживать добавление, поиск по идентификатору, удаление и получение полного списка.

**Интерфейсы**  
- `IMedia`: позволяет получить идентификатор, название и тип (книга или аудио).  
- `IMediaRepository`: поддерживает добавление медиа, удаление по идентификатору, поиск по идентификатору и получение всех сохранённых объектов.

**Классы**  
- `Book` и `Audio` реализуют `IMedia`. `Book` дополнительно хранит имя автора, `Audio` — длительность в секундах.  
- `InMemoryMediaRepository` хранит все медиа в последовательном контейнере (для сохранения порядка добавления) и индексирует их по идентификатору с помощью ассоциативного контейнера.

**Поведение методов**  
- При добавлении проверяется уникальность идентификатора; дубликаты игнорируются.  
- Удаление не уменьшает размер последовательного контейнера — вместо удалённого элемента сохраняется пустой указатель.  
- Поиск по идентификатору возвращает объект или признак отсутствия.  
- Получение всех объектов возвращает список без пустых указателей.

### Усложнённый этап  
**От вас требуется реализовать** расширенную логику выдачи медиа-ресурсов пользователям. Система должна учитывать, кому и что выдано, и не позволять выдавать один и тот же ресурс нескольким пользователям одновременно. Для этого вводятся пользователи и агрегирующий компонент — библиотека.

**Агрегация**  
Класс `Library` агрегирует репозиторий медиа и менеджер пользователей: он использует их, но не управляет их жизненным циклом.

**Новые сущности**  
- `User` хранит идентификатор, имя и список идентификаторов выданных ему медиа.  
- `InMemoryUserManager` управляет пользователями: добавляет, проверяет существование и предоставляет доступ к данным.

**Новая операция**  
- Метод выдачи медиа проверяет, что и пользователь, и медиа существуют, и что медиа ещё никому не выдан. Если все условия выполнены — идентификатор медиа добавляется в список пользователя.

---

## Задание 2. Каталог курсов и расписание преподавателей

### Базовый этап  
**От вас требуется реализовать** систему учёта учебных курсов и преподавателей с возможностью назначать преподавателя на курс при условии, что он ведёт соответствующую дисциплину.

**Интерфейсы**  
- `ICourse`: предоставляет идентификатор, название и количество кредитов.  
- `IInstructor`: предоставляет идентификатор, имя и список преподаваемых предметов.  
- `ICatalog`: позволяет добавлять курсы и преподавателей, назначать преподавателя на курс и получать преподавателя по курсу.

**Классы**  
- `Course` и `Instructor` — простые реализации с хранением данных.  
- `Catalog` использует один последовательный и один ассоциативный контейнер для хранения курсов и преподавателей.

**Поведение методов**  
- Назначение преподавателя возможно только если название курса совпадает с одним из его предметов. В этом случае создаётся связь между курсом и преподавателем.

### Усложнённый этап  
**От вас требуется реализовать** учёт расписания занятий и предотвращение конфликтов: один преподаватель не может вести два занятия одновременно.

**Агрегация**  
Класс `Department` агрегирует каталог курсов.

**Новые сущности**  
- `Schedule` хранит расписание как отображение «день недели → список временных интервалов».  
- Временной интервал задаётся началом и окончанием (целые числа, например, часы).

**Новая операция**  
- При назначении преподавателя дополнительно резервируется временной слот в расписании. Если в этот день и время у преподавателя уже есть занятие, операция отклоняется.

---

## Задание 3. Управление заказами и складом

### Базовый этап  
**От вас требуется реализовать** систему обработки заказов на основе наличия товаров на складе. Заказ может быть выполнен только если все запрошенные товары доступны в нужном количестве.

**Интерфейсы**  
- `IProduct`: предоставляет идентификатор, название и количество на складе.  
- `IInventory`: позволяет добавлять товары, получать товар по идентификатору и уменьшать остаток.  
- `IOrder`: предоставляет идентификатор, список позиций (товар + количество) и статус.

**Классы**  
- `Product` — простая реализация товара.  
- `InventoryInMemory` хранит товары в ассоциативном контейнере и порядок поставки в последовательном.  
- `Order` хранит позиции в последовательном контейнере.

**Поведение методов**  
- Уменьшение остатка возможно только если запрашиваемое количество не превышает доступное.  
- При размещении заказа все позиции обрабатываются последовательно; если хотя бы одна не может быть выполнена, все ранее изменённые остатки восстанавливаются.

### Усложнённый этап  
**От вас требуется реализовать** механизм резервирования товаров и интеграцию с сервисом доставки. Товары должны резервироваться при создании заказа и окончательно списываться только при отправке.

**Агрегация**  
Класс `OrderManager` агрегирует склад и сервис доставки.

**Новые сущности**  
- В товар добавляется поле «зарезервированное количество».  
- `ShippingQueue` управляет заказами, готовыми к отправке, используя последовательный и ассоциативный контейнеры.

**Новые операции**  
- При создании заказа сначала резервируются товары (проверяется, что резерв не превышает доступный остаток).  
- При отправке резерв снимается, и уменьшается основной остаток.  
- При отмене заказа резерв просто снимается.

---

## Задание 4. Менеджер задач с категориями

### Базовый этап  
**От вас требуется реализовать** систему управления задачами, назначенными пользователям. Должна поддерживаться фильтрация задач по исполнителю и возможность переназначения.

**Интерфейсы**  
- `ITask`: предоставляет идентификатор, название, приоритет и идентификатор исполнителя.  
- `ITaskRepository`: поддерживает добавление, удаление, поиск по идентификатору и получение всех задач конкретного исполнителя.

**Классы**  
- `Task` хранит данные задачи.  
- `TaskRepo` использует последовательный контейнер для хранения задач и ассоциативный — для быстрого поиска по идентификатору.

**Поведение методов**  
- Получение задач по исполнителю выполняется полным перебором с фильтрацией.  
- Переназначение задачи обновляет идентификатор исполнителя у соответствующего объекта.

### Усложнённый этап  
**От вас требуется реализовать** поддержку категорий задач и массовую переназначение всех задач из категории одному исполнителю с возможностью отката при ошибке.

**Агрегация**  
Класс `Project` агрегирует репозиторий задач и репозиторий пользователей.

**Новые сущности**  
- Категории представлены как отображение «название категории → список идентификаторов задач».

**Новая операция**  
- При массовом переназначении все задачи категории последовательно передаются новому исполнителю. Если хотя бы одна задача не найдена, все изменения отменяются.

---

## Задание 5. Управление подписками

### Базовый этап  
**От вас требуется реализовать** систему учёта подписок пользователей на тарифные планы. Подписка может быть активной или отменённой, но не удаляется физически.

**Интерфейсы**  
- `IPlan`: предоставляет идентификатор, название и месячную стоимость.  
- `ISubscription`: предоставляет идентификатор, идентификатор пользователя, идентификатор плана и статус активности.  
- `ISubscriptionRepo`: поддерживает добавление, отмену и поиск всех подписок пользователя.

**Классы**  
- `Plan` и `Subscription` — простые реализации.  
- `SubscriptionRepoInMemory` хранит подписки в последовательном контейнере и индексирует по пользователям с помощью ассоциативного.

**Поведение методов**  
- Отмена подписки лишь помечает её как неактивную.  
- Поиск по пользователю возвращает все его подписки, включая отменённые.

### Усложнённый этап  
**От вас требуется реализовать** логику смены тарифного плана с пропорциональным перерасчётом стоимости и взаимодействием с платёжной системой.

**Агрегация**  
Класс `BillingService` агрегирует репозиторий подписок и платёжный шлюз.

**Новые сущности**  
- Платёжный шлюз — интерфейс с методом списания средств.  
- История транзакций хранится с использованием последовательного и ассоциативного контейнеров.

**Новая операция**  
- При смене плана вычисляется разница в стоимости за оставшиеся дни. Система пытается списать её. Если платёж прошёл — план обновляется; иначе — изменения отменяются.

---

## Задание 6. Управление контактами и группами

### Базовый этап  
**От вас требуется реализовать** адресную книгу с возможностью хранения контактов и получения их в порядке добавления.

**Интерфейсы**  
- `IContact`: предоставляет идентификатор, имя и телефон.  
- `IContactRepo`: поддерживает добавление, удаление, поиск по идентификатору и получение всех контактов.  
- `IGroup`: предоставляет название и список идентификаторов участников.

**Классы**  
- `Contact` — простая реализация.  
- `ContactRepo` хранит контакты в ассоциативном контейнере и порядок добавления — в последовательном.

**Поведение методов**  
- Получение всех контактов возвращает их в том порядке, в котором они были добавлены.

### Усложнённый этап  
**От вас требуется реализовать** управление группами контактов и операцию слияния двух групп без дублирования участников.

**Агрегация**  
Класс `AddressBook` агрегирует репозиторий контактов и менеджер групп.

**Новые сущности**  
- Группы хранятся как отображение «название → список идентификаторов».

**Новая операция**  
- При слиянии все участники исходной группы добавляются в целевую, но только если их ещё нет в ней. Новые участники добавляются в конец списка.

---

## Задание 7. Простая CRM: клиенты и сделки

### Базовый этап  
**От вас требуется реализовать** систему учёта клиентов и сделок, где тип продукта в сделке может быть произвольным (поддержка шаблонов).

**Интерфейсы**  
- `IClient`: предоставляет идентификатор, имя и контактные данные.  
- `IDeal`: предоставляет идентификатор, идентификатор клиента и сумму сделки.

**Классы**  
- `Client` — простая реализация.  
- `Deal<TProduct>` — шаблонный класс, хранящий продукт, сумму и клиента.  
- `DealRepo` использует последовательный контейнер для хранения сделок и ассоциативный — для поиска по идентификатору.

**Поведение методов**  
- Добавление сделки сохраняет её в обоих контейнерах.  
- Поиск по клиенту выполняется полным перебором с фильтрацией.

### Усложнённый этап  
**От вас требуется реализовать** воронку продаж: сделки могут находиться на разных стадиях («новая», «переговоры» и т.п.), и их можно перемещать между стадиями.

**Агрегация**  
Класс `CRM` агрегирует репозитории клиентов и сделок.

**Новые сущности**  
- Воронка (`Pipeline`) хранит стадии как отображение «название стадии → список идентификаторов сделок».  
- Дополнительно поддерживается обратный индекс «сделка → текущая стадия».

**Новая операция**  
- При смене стадии идентификатор сделки удаляется из списка старой стадии и добавляется в список новой. Обратный индекс обновляется.

---

## Задание 8. Система заметок с тегами

### Базовый этап  
**От вас требуется реализовать** систему хранения заметок с поддержкой тегов и поиском по ним.

**Интерфейсы**  
- `INote`: предоставляет идентификатор, заголовок, тело и список тегов.  
- `INoteRepo`: поддерживает добавление, удаление, поиск по идентификатору и поиск всех заметок по тегу.

**Классы**  
- `Note` хранит данные и теги в последовательном контейнере.  
- `NoteRepo` использует последовательный контейнер для хранения заметок и ассоциативный — для инвертированного индекса «тег → список идентификаторов заметок».

**Поведение методов**  
- При добавлении заметки её идентификатор добавляется в списки всех её тегов.  
- Поиск по тегу возвращает полные объекты заметок, соответствующих этому тегу.

### Усложнённый этап  
**От вас требуется реализовать** массовую замену одного тега на другой во всех заметках с сохранением целостности данных и без дублирования тегов внутри заметки.

**Агрегация**  
Класс `Notebook` агрегирует репозиторий заметок и компонент пользовательских настроек.

**Новая операция**  
- Для всех заметок, содержащих старый тег, он заменяется на новый. Перед добавлением нового тега проверяется, не содержится ли он уже в заметке. Инвертированный индекс обновляется: идентификатор заметки удаляется из списка старого тега и добавляется в список нового.
